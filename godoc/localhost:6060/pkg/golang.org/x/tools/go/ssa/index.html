<!DOCTYPE html>
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<meta name="theme-color" content="#375EAB">

  <title>ssa - The Go Programming Language</title>

<link type="text/css" rel="stylesheet" href="../../../../../../lib/godoc/style.css">


<script>window.initFuncs = [];</script>

<script src="../../../../../../lib/godoc/jquery.js" defer></script>



<script>var goVersion = "go1.11.5";</script>
<script src="../../../../../../lib/godoc/godocs.js" defer></script>
</head>
<body>

<div id='lowframe' style="position: fixed; bottom: 0; left: 0; height: 0; width: 100%; border-top: thin solid grey; background-color: white; overflow: auto;">
...
</div><!-- #lowframe -->

<div id="topbar" class="wide"><div class="container">
<div class="top-heading" id="heading-wide"><a href="http://localhost:6060/">The Go Programming Language</a></div>
<div class="top-heading" id="heading-narrow"><a href="http://localhost:6060/">Go</a></div>
<a href="index.html#" id="menu-button"><span id="menu-button-arrow">&#9661;</span></a>
<form method="GET" action="http://localhost:6060/search">
<div id="menu">
<a href="http://localhost:6060/doc/">Documents</a>
<a href="../../../../../index.html">Packages</a>
<a href="http://localhost:6060/project/">The Project</a>
<a href="http://localhost:6060/help/">Help</a>

<a href="http://localhost:6060/blog/">Blog</a>


<span class="search-box"><input type="search" id="search" name="q" placeholder="Search" aria-label="Search" required><button type="submit"><span><!-- magnifying glass: --><svg width="24" height="24" viewBox="0 0 24 24"><title>submit search</title><path d="M15.5 14h-.79l-.28-.27C15.41 12.59 16 11.11 16 9.5 16 5.91 13.09 3 9.5 3S3 5.91 3 9.5 5.91 16 9.5 16c1.61 0 3.09-.59 4.23-1.57l.27.28v.79l5 4.99L20.49 19l-4.99-5zm-6 0C7.01 14 5 11.99 5 9.5S7.01 5 9.5 5 14 7.01 14 9.5 11.99 14 9.5 14z"/><path d="M0 0h24v24H0z" fill="none"/></svg></span></button></span>
</div>
</form>

</div></div>



<div id="page" class="wide">
<div class="container">


  <h1>
    Package ssa
    <span class="text-muted"></span>
  </h1>







<div id="nav"></div>


<!--
	Copyright 2009 The Go Authors. All rights reserved.
	Use of this source code is governed by a BSD-style
	license that can be found in the LICENSE file.
-->
<!--
	Note: Static (i.e., not template-generated) href and id
	attributes start with "pkg-" to make it impossible for
	them to conflict with generated attributes (some of which
	correspond to Go identifiers).
-->

	<script>
	document.ANALYSIS_DATA = null;
	document.CALLGRAPH = null;
	</script>

	
		
		<div id="short-nav">
			<dl>
			<dd><code>import "golang.org/x/tools/go/ssa"</code></dd>
			</dl>
			<dl>
			<dd><a href="index.html#pkg-overview" class="overviewLink">Overview</a></dd>
			<dd><a href="index.html#pkg-index" class="indexLink">Index</a></dd>
			
				<dd><a href="index.html#pkg-examples" class="examplesLink">Examples</a></dd>
			
			
				<dd><a href="index.html#pkg-subdirectories">Subdirectories</a></dd>
			
			</dl>
		</div>
		<!-- The package's Name is printed as title by the top-level template -->
		<div id="pkg-overview" class="toggleVisible">
			<div class="collapsed">
				<h2 class="toggleButton" title="Click to show Overview section">Overview ▹</h2>
			</div>
			<div class="expanded">
				<h2 class="toggleButton" title="Click to hide Overview section">Overview ▾</h2>
				<p>
Package ssa defines a representation of the elements of Go programs
(packages, types, functions, variables and constants) using a
static single-assignment (SSA) form intermediate representation
(IR) for the bodies of functions.
</p>
<p>
THIS INTERFACE IS EXPERIMENTAL AND IS LIKELY TO CHANGE.
</p>
<p>
For an introduction to SSA form, see
<a href="http://en.wikipedia.org/wiki/Static_single_assignment_form">http://en.wikipedia.org/wiki/Static_single_assignment_form</a>.
This page provides a broader reading list:
<a href="http://www.dcs.gla.ac.uk/~jsinger/ssa.html">http://www.dcs.gla.ac.uk/~jsinger/ssa.html</a>.
</p>
<p>
The level of abstraction of the SSA form is intentionally close to
the source language to facilitate construction of source analysis
tools.  It is not intended for machine code generation.
</p>
<p>
All looping, branching and switching constructs are replaced with
unstructured control flow.  Higher-level control flow constructs
such as multi-way branch can be reconstructed as needed; see
ssautil.Switches() for an example.
</p>
<p>
The simplest way to create the SSA representation of a package is
to load typed syntax trees using golang.org/x/tools/go/packages, then
invoke the ssautil.Packages helper function. See ExampleLoadPackages
and ExampleWholeProgram for examples.
The resulting ssa.Program contains all the packages and their
members, but SSA code is not created for function bodies until a
subsequent call to (*Package).Build or (*Program).Build.
</p>
<p>
The builder initially builds a naive SSA form in which all local
variables are addresses of stack locations with explicit loads and
stores.  Registerisation of eligible locals and φ-node insertion
using dominance and dataflow are then performed as a second pass
called &#34;lifting&#34; to improve the accuracy and performance of
subsequent analyses; this pass can be skipped by setting the
NaiveForm builder flag.
</p>
<p>
The primary interfaces of this package are:
</p>
<pre>- Member: a named member of a Go package.
- Value: an expression that yields a value.
- Instruction: a statement that consumes values and performs computation.
- Node: a Value or Instruction (emphasizing its membership in the SSA value graph)
</pre>
<p>
A computation that yields a result implements both the Value and
Instruction interfaces.  The following table shows for each
concrete type which of these interfaces it implements.
</p>
<pre>                   Value?          Instruction?    Member?
*Alloc             ✔               ✔
*BinOp             ✔               ✔
*Builtin           ✔
*Call              ✔               ✔
*ChangeInterface   ✔               ✔
*ChangeType        ✔               ✔
*Const             ✔
*Convert           ✔               ✔
*DebugRef                          ✔
*Defer                             ✔
*Extract           ✔               ✔
*Field             ✔               ✔
*FieldAddr         ✔               ✔
*FreeVar           ✔
*Function          ✔                               ✔ (func)
*Global            ✔                               ✔ (var)
*Go                                ✔
*If                                ✔
*Index             ✔               ✔
*IndexAddr         ✔               ✔
*Jump                              ✔
*Lookup            ✔               ✔
*MakeChan          ✔               ✔
*MakeClosure       ✔               ✔
*MakeInterface     ✔               ✔
*MakeMap           ✔               ✔
*MakeSlice         ✔               ✔
*MapUpdate                         ✔
*NamedConst                                        ✔ (const)
*Next              ✔               ✔
*Panic                             ✔
*Parameter         ✔
*Phi               ✔               ✔
*Range             ✔               ✔
*Return                            ✔
*RunDefers                         ✔
*Select            ✔               ✔
*Send                              ✔
*Slice             ✔               ✔
*Store                             ✔
*Type                                              ✔ (type)
*TypeAssert        ✔               ✔
*UnOp              ✔               ✔
</pre>
<p>
Other key types in this package include: Program, Package, Function
and BasicBlock.
</p>
<p>
The program representation constructed by this package is fully
resolved internally, i.e. it does not rely on the names of Values,
Packages, Functions, Types or BasicBlocks for the correct
interpretation of the program.  Only the identities of objects and
the topology of the SSA and type graphs are semantically
significant.  (There is one exception: Ids, used to identify field
and method names, contain strings.)  Avoidance of name-based
operations simplifies the implementation of subsequent passes and
can make them very efficient.  Many objects are nonetheless named
to aid in debugging, but it is not essential that the names be
either accurate or unambiguous.  The public API exposes a number of
name-based maps for client convenience.
</p>
<p>
The ssa/ssautil package provides various utilities that depend only
on the public API of this package.
</p>
<p>
TODO(adonovan): Consider the exceptional control-flow implications
of defer and recover().
</p>
<p>
TODO(adonovan): write a how-to document for all the various cases
of trying to determine corresponding elements across the four
domains of source locations, ast.Nodes, types.Objects,
ssa.Values/Instructions.
</p>

				<div id="example__buildPackage" class="toggle">
	<div class="collapsed">
		<p class="exampleHeading toggleButton">▹ <span class="text">Example (BuildPackage)</span></p>
	</div>
	<div class="expanded">
		<p class="exampleHeading toggleButton">▾ <span class="text">Example (BuildPackage)</span></p>
		<p>This program demonstrates how to run the SSA builder on a single
package of one or more already-parsed files.  Its dependencies are
loaded from compiler export data.  This is what you&#39;d typically use
for a compiler; it does not depend on golang.org/x/tools/go/loader.

It shows the printed representation of packages, functions, and
instructions.  Within the function listing, the name of each
BasicBlock such as &#34;.0.entry&#34; is printed left-aligned, followed by
the block&#39;s Instructions.

For each instruction that defines an SSA virtual register
(i.e. implements Value), the type of that value is shown in the
right column.

Build and run the ssadump.go program if you want a standalone tool
with similar functionality. It is located at
golang.org/x/tools/cmd/ssadump.
</p>
		
		
			<p>Code:</p>
			<pre class="code"><span class="comment">// Parse the source files.</span>
fset := token.NewFileSet()
f, err := parser.ParseFile(fset, &#34;hello.go&#34;, hello, parser.ParseComments)
if err != nil {
    fmt.Print(err) <span class="comment">// parse error</span>
    return
}
files := []*ast.File{f}

<span class="comment">// Create the type-checker&#39;s package.</span>
pkg := types.NewPackage(&#34;hello&#34;, &#34;&#34;)

<span class="comment">// Type-check the package, load dependencies.</span>
<span class="comment">// Create and build the SSA program.</span>
hello, _, err := ssautil.BuildPackage(
    &amp;types.Config{Importer: importer.Default()}, fset, pkg, files, ssa.SanityCheckFunctions)
if err != nil {
    fmt.Print(err) <span class="comment">// type error in some package</span>
    return
}

<span class="comment">// Print out the package.</span>
hello.WriteTo(os.Stdout)

<span class="comment">// Print out the package-level functions.</span>
hello.Func(&#34;init&#34;).WriteTo(os.Stdout)
hello.Func(&#34;main&#34;).WriteTo(os.Stdout)

<span class="comment"></pre>
			
			<p>Output:</p>
			<pre class="output">
package hello:
  func  init       func()
  var   init$guard bool
  func  main       func()
  const message    message = &#34;Hello, World!&#34;:untyped string

# Name: hello.init
# Package: hello
# Synthetic: package initializer
func init():
0:                                                                entry P:0 S:2
	t0 = *init$guard                                                   bool
	if t0 goto 2 else 1
1:                                                           init.start P:1 S:1
	*init$guard = true:bool
	t1 = fmt.init()                                                      ()
	jump 2
2:                                                            init.done P:2 S:0
	return

# Name: hello.main
# Package: hello
# Location: hello.go:8:6
func main():
0:                                                                entry P:0 S:0
	t0 = new [1]interface{} (varargs)                       *[1]interface{}
	t1 = &amp;t0[0:int]                                            *interface{}
	t2 = make interface{} &lt;- string (&#34;Hello, World!&#34;:string)    interface{}
	*t1 = t2
	t3 = slice t0[:]                                          []interface{}
	t4 = fmt.Println(t3...)                              (n int, err error)
	return
</pre>
			
		
	</div>
</div>
<div id="example__loadPackages" class="toggle">
	<div class="collapsed">
		<p class="exampleHeading toggleButton">▹ <span class="text">Example (LoadPackages)</span></p>
	</div>
	<div class="expanded">
		<p class="exampleHeading toggleButton">▾ <span class="text">Example (LoadPackages)</span></p>
		<p>This example builds SSA code for a set of packages using the
x/tools/go/packages API. This is what you would typically use for a
analysis capable of operating on a single package.
</p>
		
		
			<p>Code:</p>
			<pre class="code">
<span class="comment">// Load, parse, and type-check the initial packages.</span>
cfg := &amp;packages.Config{Mode: packages.LoadSyntax}
initial, err := packages.Load(cfg, &#34;fmt&#34;, &#34;net/http&#34;)
if err != nil {
    log.Fatal(err)
}

<span class="comment">// Stop if any package had errors.</span>
<span class="comment">// This step is optional; without it, the next step</span>
<span class="comment">// will create SSA for only a subset of packages.</span>
if packages.PrintErrors(initial) &gt; 0 {
    log.Fatalf(&#34;packages contain errors&#34;)
}

<span class="comment">// Create SSA packages for all well-typed packages.</span>
prog, pkgs := ssautil.Packages(initial, ssa.PrintPackages)
_ = prog

<span class="comment">// Build SSA code for the well-typed initial packages.</span>
for _, p := range pkgs {
    if p != nil {
        p.Build()
    }
}
</pre>
			
		
	</div>
</div>
<div id="example__loadWholeProgram" class="toggle">
	<div class="collapsed">
		<p class="exampleHeading toggleButton">▹ <span class="text">Example (LoadWholeProgram)</span></p>
	</div>
	<div class="expanded">
		<p class="exampleHeading toggleButton">▾ <span class="text">Example (LoadWholeProgram)</span></p>
		<p>This example builds SSA code for a set of packages plus all their dependencies,
using the x/tools/go/packages API.
This is what you&#39;d typically use for a whole-program analysis.
</p>
		
		
			<p>Code:</p>
			<pre class="code">
<span class="comment">// Load, parse, and type-check the whole program.</span>
cfg := packages.Config{Mode: packages.LoadAllSyntax}
initial, err := packages.Load(&amp;cfg, &#34;fmt&#34;, &#34;net/http&#34;)
if err != nil {
    log.Fatal(err)
}

<span class="comment">// Create SSA packages for well-typed packages and their dependencies.</span>
prog, pkgs := ssautil.AllPackages(initial, ssa.PrintPackages)
_ = pkgs

<span class="comment">// Build SSA code for the whole program.</span>
prog.Build()
</pre>
			
		
	</div>
</div>

			</div>
		</div>

		<div id="pkg-index" class="toggleVisible">
		<div class="collapsed">
			<h2 class="toggleButton" title="Click to show Index section">Index ▹</h2>
		</div>
		<div class="expanded">
			<h2 class="toggleButton" title="Click to hide Index section">Index ▾</h2>

		<!-- Table of contents for API; must be named manual-nav to turn off auto nav. -->
			<div id="manual-nav">
			<dl>
			
				<dd><a href="index.html#pkg-constants">Constants</a></dd>
			
			
			
				
				<dd><a href="index.html#DefaultType">func DefaultType(typ types.Type) types.Type</a></dd>
			
				
				<dd><a href="index.html#FindTests">func FindTests(pkg *Package) (tests, benchmarks, examples []*Function, main *Function)</a></dd>
			
				
				<dd><a href="index.html#HasEnclosingFunction">func HasEnclosingFunction(pkg *Package, path []ast.Node) bool</a></dd>
			
				
				<dd><a href="index.html#WriteFunction">func WriteFunction(buf *bytes.Buffer, f *Function)</a></dd>
			
				
				<dd><a href="index.html#WritePackage">func WritePackage(buf *bytes.Buffer, p *Package)</a></dd>
			
			
				
				<dd><a href="index.html#Alloc">type Alloc</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#Alloc.Name">func (v *Alloc) Name() string</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#Alloc.Operands">func (v *Alloc) Operands(rands []*Value) []*Value</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#Alloc.Pos">func (v *Alloc) Pos() token.Pos</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#Alloc.Referrers">func (v *Alloc) Referrers() *[]Instruction</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#Alloc.String">func (v *Alloc) String() string</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#Alloc.Type">func (v *Alloc) Type() types.Type</a></dd>
				
			
				
				<dd><a href="index.html#BasicBlock">type BasicBlock</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#BasicBlock.Dominates">func (b *BasicBlock) Dominates(c *BasicBlock) bool</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#BasicBlock.Dominees">func (b *BasicBlock) Dominees() []*BasicBlock</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#BasicBlock.Idom">func (b *BasicBlock) Idom() *BasicBlock</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#BasicBlock.Parent">func (b *BasicBlock) Parent() *Function</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#BasicBlock.String">func (b *BasicBlock) String() string</a></dd>
				
			
				
				<dd><a href="index.html#BinOp">type BinOp</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#BinOp.Name">func (v *BinOp) Name() string</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#BinOp.Operands">func (v *BinOp) Operands(rands []*Value) []*Value</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#BinOp.Pos">func (v *BinOp) Pos() token.Pos</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#BinOp.Referrers">func (v *BinOp) Referrers() *[]Instruction</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#BinOp.String">func (v *BinOp) String() string</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#BinOp.Type">func (v *BinOp) Type() types.Type</a></dd>
				
			
				
				<dd><a href="index.html#BuilderMode">type BuilderMode</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#BuilderMode.Get">func (m BuilderMode) Get() interface{}</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#BuilderMode.Set">func (m *BuilderMode) Set(s string) error</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#BuilderMode.String">func (m BuilderMode) String() string</a></dd>
				
			
				
				<dd><a href="index.html#Builtin">type Builtin</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#Builtin.Name">func (v *Builtin) Name() string</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#Builtin.Object">func (v *Builtin) Object() types.Object</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#Builtin.Operands">func (v *Builtin) Operands(rands []*Value) []*Value</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#Builtin.Parent">func (v *Builtin) Parent() *Function</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#Builtin.Pos">func (v *Builtin) Pos() token.Pos</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#Builtin.Referrers">func (*Builtin) Referrers() *[]Instruction</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#Builtin.String">func (v *Builtin) String() string</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#Builtin.Type">func (v *Builtin) Type() types.Type</a></dd>
				
			
				
				<dd><a href="index.html#Call">type Call</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#Call.Common">func (s *Call) Common() *CallCommon</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#Call.Name">func (v *Call) Name() string</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#Call.Operands">func (s *Call) Operands(rands []*Value) []*Value</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#Call.Pos">func (v *Call) Pos() token.Pos</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#Call.Referrers">func (v *Call) Referrers() *[]Instruction</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#Call.String">func (v *Call) String() string</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#Call.Type">func (v *Call) Type() types.Type</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#Call.Value">func (s *Call) Value() *Call</a></dd>
				
			
				
				<dd><a href="index.html#CallCommon">type CallCommon</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#CallCommon.Description">func (c *CallCommon) Description() string</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#CallCommon.IsInvoke">func (c *CallCommon) IsInvoke() bool</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#CallCommon.Operands">func (c *CallCommon) Operands(rands []*Value) []*Value</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#CallCommon.Pos">func (c *CallCommon) Pos() token.Pos</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#CallCommon.Signature">func (c *CallCommon) Signature() *types.Signature</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#CallCommon.StaticCallee">func (c *CallCommon) StaticCallee() *Function</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#CallCommon.String">func (c *CallCommon) String() string</a></dd>
				
			
				
				<dd><a href="index.html#CallInstruction">type CallInstruction</a></dd>
				
				
			
				
				<dd><a href="index.html#ChangeInterface">type ChangeInterface</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#ChangeInterface.Name">func (v *ChangeInterface) Name() string</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#ChangeInterface.Operands">func (v *ChangeInterface) Operands(rands []*Value) []*Value</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#ChangeInterface.Pos">func (v *ChangeInterface) Pos() token.Pos</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#ChangeInterface.Referrers">func (v *ChangeInterface) Referrers() *[]Instruction</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#ChangeInterface.String">func (v *ChangeInterface) String() string</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#ChangeInterface.Type">func (v *ChangeInterface) Type() types.Type</a></dd>
				
			
				
				<dd><a href="index.html#ChangeType">type ChangeType</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#ChangeType.Name">func (v *ChangeType) Name() string</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#ChangeType.Operands">func (v *ChangeType) Operands(rands []*Value) []*Value</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#ChangeType.Pos">func (v *ChangeType) Pos() token.Pos</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#ChangeType.Referrers">func (v *ChangeType) Referrers() *[]Instruction</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#ChangeType.String">func (v *ChangeType) String() string</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#ChangeType.Type">func (v *ChangeType) Type() types.Type</a></dd>
				
			
				
				<dd><a href="index.html#Const">type Const</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#NewConst">func NewConst(val constant.Value, typ types.Type) *Const</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#Const.Complex128">func (c *Const) Complex128() complex128</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#Const.Float64">func (c *Const) Float64() float64</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#Const.Int64">func (c *Const) Int64() int64</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#Const.IsNil">func (c *Const) IsNil() bool</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#Const.Name">func (c *Const) Name() string</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#Const.Operands">func (v *Const) Operands(rands []*Value) []*Value</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#Const.Parent">func (c *Const) Parent() *Function</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#Const.Pos">func (c *Const) Pos() token.Pos</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#Const.Referrers">func (c *Const) Referrers() *[]Instruction</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#Const.RelString">func (c *Const) RelString(from *types.Package) string</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#Const.String">func (c *Const) String() string</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#Const.Type">func (c *Const) Type() types.Type</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#Const.Uint64">func (c *Const) Uint64() uint64</a></dd>
				
			
				
				<dd><a href="index.html#Convert">type Convert</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#Convert.Name">func (v *Convert) Name() string</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#Convert.Operands">func (v *Convert) Operands(rands []*Value) []*Value</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#Convert.Pos">func (v *Convert) Pos() token.Pos</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#Convert.Referrers">func (v *Convert) Referrers() *[]Instruction</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#Convert.String">func (v *Convert) String() string</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#Convert.Type">func (v *Convert) Type() types.Type</a></dd>
				
			
				
				<dd><a href="index.html#DebugRef">type DebugRef</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#DebugRef.Block">func (v *DebugRef) Block() *BasicBlock</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#DebugRef.Operands">func (s *DebugRef) Operands(rands []*Value) []*Value</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#DebugRef.Parent">func (v *DebugRef) Parent() *Function</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#DebugRef.Pos">func (s *DebugRef) Pos() token.Pos</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#DebugRef.Referrers">func (v *DebugRef) Referrers() *[]Instruction</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#DebugRef.String">func (s *DebugRef) String() string</a></dd>
				
			
				
				<dd><a href="index.html#Defer">type Defer</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#Defer.Block">func (v *Defer) Block() *BasicBlock</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#Defer.Common">func (s *Defer) Common() *CallCommon</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#Defer.Operands">func (s *Defer) Operands(rands []*Value) []*Value</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#Defer.Parent">func (v *Defer) Parent() *Function</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#Defer.Pos">func (s *Defer) Pos() token.Pos</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#Defer.Referrers">func (v *Defer) Referrers() *[]Instruction</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#Defer.String">func (s *Defer) String() string</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#Defer.Value">func (s *Defer) Value() *Call</a></dd>
				
			
				
				<dd><a href="index.html#Extract">type Extract</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#Extract.Name">func (v *Extract) Name() string</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#Extract.Operands">func (v *Extract) Operands(rands []*Value) []*Value</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#Extract.Pos">func (v *Extract) Pos() token.Pos</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#Extract.Referrers">func (v *Extract) Referrers() *[]Instruction</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#Extract.String">func (v *Extract) String() string</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#Extract.Type">func (v *Extract) Type() types.Type</a></dd>
				
			
				
				<dd><a href="index.html#Field">type Field</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#Field.Name">func (v *Field) Name() string</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#Field.Operands">func (v *Field) Operands(rands []*Value) []*Value</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#Field.Pos">func (v *Field) Pos() token.Pos</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#Field.Referrers">func (v *Field) Referrers() *[]Instruction</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#Field.String">func (v *Field) String() string</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#Field.Type">func (v *Field) Type() types.Type</a></dd>
				
			
				
				<dd><a href="index.html#FieldAddr">type FieldAddr</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#FieldAddr.Name">func (v *FieldAddr) Name() string</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#FieldAddr.Operands">func (v *FieldAddr) Operands(rands []*Value) []*Value</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#FieldAddr.Pos">func (v *FieldAddr) Pos() token.Pos</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#FieldAddr.Referrers">func (v *FieldAddr) Referrers() *[]Instruction</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#FieldAddr.String">func (v *FieldAddr) String() string</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#FieldAddr.Type">func (v *FieldAddr) Type() types.Type</a></dd>
				
			
				
				<dd><a href="index.html#FreeVar">type FreeVar</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#FreeVar.Name">func (v *FreeVar) Name() string</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#FreeVar.Operands">func (v *FreeVar) Operands(rands []*Value) []*Value</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#FreeVar.Parent">func (v *FreeVar) Parent() *Function</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#FreeVar.Pos">func (v *FreeVar) Pos() token.Pos</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#FreeVar.Referrers">func (v *FreeVar) Referrers() *[]Instruction</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#FreeVar.String">func (v *FreeVar) String() string</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#FreeVar.Type">func (v *FreeVar) Type() types.Type</a></dd>
				
			
				
				<dd><a href="index.html#Function">type Function</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#EnclosingFunction">func EnclosingFunction(pkg *Package, path []ast.Node) *Function</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#Function.DomPreorder">func (f *Function) DomPreorder() []*BasicBlock</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#Function.Name">func (v *Function) Name() string</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#Function.Object">func (v *Function) Object() types.Object</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#Function.Operands">func (v *Function) Operands(rands []*Value) []*Value</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#Function.Package">func (v *Function) Package() *Package</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#Function.Parent">func (v *Function) Parent() *Function</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#Function.Pos">func (v *Function) Pos() token.Pos</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#Function.Referrers">func (v *Function) Referrers() *[]Instruction</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#Function.RelString">func (f *Function) RelString(from *types.Package) string</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#Function.String">func (v *Function) String() string</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#Function.Syntax">func (f *Function) Syntax() ast.Node</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#Function.Token">func (v *Function) Token() token.Token</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#Function.Type">func (v *Function) Type() types.Type</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#Function.ValueForExpr">func (f *Function) ValueForExpr(e ast.Expr) (value Value, isAddr bool)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#Function.WriteTo">func (f *Function) WriteTo(w io.Writer) (int64, error)</a></dd>
				
			
				
				<dd><a href="index.html#Global">type Global</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#Global.Name">func (v *Global) Name() string</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#Global.Object">func (v *Global) Object() types.Object</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#Global.Operands">func (v *Global) Operands(rands []*Value) []*Value</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#Global.Package">func (v *Global) Package() *Package</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#Global.Parent">func (v *Global) Parent() *Function</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#Global.Pos">func (v *Global) Pos() token.Pos</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#Global.Referrers">func (v *Global) Referrers() *[]Instruction</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#Global.RelString">func (v *Global) RelString(from *types.Package) string</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#Global.String">func (v *Global) String() string</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#Global.Token">func (v *Global) Token() token.Token</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#Global.Type">func (v *Global) Type() types.Type</a></dd>
				
			
				
				<dd><a href="index.html#Go">type Go</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#Go.Block">func (v *Go) Block() *BasicBlock</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#Go.Common">func (s *Go) Common() *CallCommon</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#Go.Operands">func (s *Go) Operands(rands []*Value) []*Value</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#Go.Parent">func (v *Go) Parent() *Function</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#Go.Pos">func (s *Go) Pos() token.Pos</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#Go.Referrers">func (v *Go) Referrers() *[]Instruction</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#Go.String">func (s *Go) String() string</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#Go.Value">func (s *Go) Value() *Call</a></dd>
				
			
				
				<dd><a href="index.html#If">type If</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#If.Block">func (v *If) Block() *BasicBlock</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#If.Operands">func (s *If) Operands(rands []*Value) []*Value</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#If.Parent">func (v *If) Parent() *Function</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#If.Pos">func (s *If) Pos() token.Pos</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#If.Referrers">func (v *If) Referrers() *[]Instruction</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#If.String">func (s *If) String() string</a></dd>
				
			
				
				<dd><a href="index.html#Index">type Index</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#Index.Name">func (v *Index) Name() string</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#Index.Operands">func (v *Index) Operands(rands []*Value) []*Value</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#Index.Pos">func (v *Index) Pos() token.Pos</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#Index.Referrers">func (v *Index) Referrers() *[]Instruction</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#Index.String">func (v *Index) String() string</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#Index.Type">func (v *Index) Type() types.Type</a></dd>
				
			
				
				<dd><a href="index.html#IndexAddr">type IndexAddr</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#IndexAddr.Name">func (v *IndexAddr) Name() string</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#IndexAddr.Operands">func (v *IndexAddr) Operands(rands []*Value) []*Value</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#IndexAddr.Pos">func (v *IndexAddr) Pos() token.Pos</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#IndexAddr.Referrers">func (v *IndexAddr) Referrers() *[]Instruction</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#IndexAddr.String">func (v *IndexAddr) String() string</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#IndexAddr.Type">func (v *IndexAddr) Type() types.Type</a></dd>
				
			
				
				<dd><a href="index.html#Instruction">type Instruction</a></dd>
				
				
			
				
				<dd><a href="index.html#Jump">type Jump</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#Jump.Block">func (v *Jump) Block() *BasicBlock</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#Jump.Operands">func (*Jump) Operands(rands []*Value) []*Value</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#Jump.Parent">func (v *Jump) Parent() *Function</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#Jump.Pos">func (s *Jump) Pos() token.Pos</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#Jump.Referrers">func (v *Jump) Referrers() *[]Instruction</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#Jump.String">func (s *Jump) String() string</a></dd>
				
			
				
				<dd><a href="index.html#Lookup">type Lookup</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#Lookup.Name">func (v *Lookup) Name() string</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#Lookup.Operands">func (v *Lookup) Operands(rands []*Value) []*Value</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#Lookup.Pos">func (v *Lookup) Pos() token.Pos</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#Lookup.Referrers">func (v *Lookup) Referrers() *[]Instruction</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#Lookup.String">func (v *Lookup) String() string</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#Lookup.Type">func (v *Lookup) Type() types.Type</a></dd>
				
			
				
				<dd><a href="index.html#MakeChan">type MakeChan</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#MakeChan.Name">func (v *MakeChan) Name() string</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#MakeChan.Operands">func (v *MakeChan) Operands(rands []*Value) []*Value</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#MakeChan.Pos">func (v *MakeChan) Pos() token.Pos</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#MakeChan.Referrers">func (v *MakeChan) Referrers() *[]Instruction</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#MakeChan.String">func (v *MakeChan) String() string</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#MakeChan.Type">func (v *MakeChan) Type() types.Type</a></dd>
				
			
				
				<dd><a href="index.html#MakeClosure">type MakeClosure</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#MakeClosure.Name">func (v *MakeClosure) Name() string</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#MakeClosure.Operands">func (v *MakeClosure) Operands(rands []*Value) []*Value</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#MakeClosure.Pos">func (v *MakeClosure) Pos() token.Pos</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#MakeClosure.Referrers">func (v *MakeClosure) Referrers() *[]Instruction</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#MakeClosure.String">func (v *MakeClosure) String() string</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#MakeClosure.Type">func (v *MakeClosure) Type() types.Type</a></dd>
				
			
				
				<dd><a href="index.html#MakeInterface">type MakeInterface</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#MakeInterface.Name">func (v *MakeInterface) Name() string</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#MakeInterface.Operands">func (v *MakeInterface) Operands(rands []*Value) []*Value</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#MakeInterface.Pos">func (v *MakeInterface) Pos() token.Pos</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#MakeInterface.Referrers">func (v *MakeInterface) Referrers() *[]Instruction</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#MakeInterface.String">func (v *MakeInterface) String() string</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#MakeInterface.Type">func (v *MakeInterface) Type() types.Type</a></dd>
				
			
				
				<dd><a href="index.html#MakeMap">type MakeMap</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#MakeMap.Name">func (v *MakeMap) Name() string</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#MakeMap.Operands">func (v *MakeMap) Operands(rands []*Value) []*Value</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#MakeMap.Pos">func (v *MakeMap) Pos() token.Pos</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#MakeMap.Referrers">func (v *MakeMap) Referrers() *[]Instruction</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#MakeMap.String">func (v *MakeMap) String() string</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#MakeMap.Type">func (v *MakeMap) Type() types.Type</a></dd>
				
			
				
				<dd><a href="index.html#MakeSlice">type MakeSlice</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#MakeSlice.Name">func (v *MakeSlice) Name() string</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#MakeSlice.Operands">func (v *MakeSlice) Operands(rands []*Value) []*Value</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#MakeSlice.Pos">func (v *MakeSlice) Pos() token.Pos</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#MakeSlice.Referrers">func (v *MakeSlice) Referrers() *[]Instruction</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#MakeSlice.String">func (v *MakeSlice) String() string</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#MakeSlice.Type">func (v *MakeSlice) Type() types.Type</a></dd>
				
			
				
				<dd><a href="index.html#MapUpdate">type MapUpdate</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#MapUpdate.Block">func (v *MapUpdate) Block() *BasicBlock</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#MapUpdate.Operands">func (v *MapUpdate) Operands(rands []*Value) []*Value</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#MapUpdate.Parent">func (v *MapUpdate) Parent() *Function</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#MapUpdate.Pos">func (s *MapUpdate) Pos() token.Pos</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#MapUpdate.Referrers">func (v *MapUpdate) Referrers() *[]Instruction</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#MapUpdate.String">func (s *MapUpdate) String() string</a></dd>
				
			
				
				<dd><a href="index.html#Member">type Member</a></dd>
				
				
			
				
				<dd><a href="index.html#NamedConst">type NamedConst</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#NamedConst.Name">func (c *NamedConst) Name() string</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#NamedConst.Object">func (c *NamedConst) Object() types.Object</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#NamedConst.Package">func (c *NamedConst) Package() *Package</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#NamedConst.Pos">func (c *NamedConst) Pos() token.Pos</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#NamedConst.RelString">func (c *NamedConst) RelString(from *types.Package) string</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#NamedConst.String">func (c *NamedConst) String() string</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#NamedConst.Token">func (c *NamedConst) Token() token.Token</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#NamedConst.Type">func (c *NamedConst) Type() types.Type</a></dd>
				
			
				
				<dd><a href="index.html#Next">type Next</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#Next.Name">func (v *Next) Name() string</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#Next.Operands">func (v *Next) Operands(rands []*Value) []*Value</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#Next.Pos">func (v *Next) Pos() token.Pos</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#Next.Referrers">func (v *Next) Referrers() *[]Instruction</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#Next.String">func (v *Next) String() string</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#Next.Type">func (v *Next) Type() types.Type</a></dd>
				
			
				
				<dd><a href="index.html#Node">type Node</a></dd>
				
				
			
				
				<dd><a href="index.html#Package">type Package</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#Package.Build">func (p *Package) Build()</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#Package.Const">func (p *Package) Const(name string) (c *NamedConst)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#Package.Func">func (p *Package) Func(name string) (f *Function)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#Package.SetDebugMode">func (pkg *Package) SetDebugMode(debug bool)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#Package.String">func (p *Package) String() string</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#Package.Type">func (p *Package) Type(name string) (t *Type)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#Package.Var">func (p *Package) Var(name string) (g *Global)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#Package.WriteTo">func (p *Package) WriteTo(w io.Writer) (int64, error)</a></dd>
				
			
				
				<dd><a href="index.html#Panic">type Panic</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#Panic.Block">func (v *Panic) Block() *BasicBlock</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#Panic.Operands">func (s *Panic) Operands(rands []*Value) []*Value</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#Panic.Parent">func (v *Panic) Parent() *Function</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#Panic.Pos">func (s *Panic) Pos() token.Pos</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#Panic.Referrers">func (v *Panic) Referrers() *[]Instruction</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#Panic.String">func (s *Panic) String() string</a></dd>
				
			
				
				<dd><a href="index.html#Parameter">type Parameter</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#Parameter.Name">func (v *Parameter) Name() string</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#Parameter.Object">func (v *Parameter) Object() types.Object</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#Parameter.Operands">func (v *Parameter) Operands(rands []*Value) []*Value</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#Parameter.Parent">func (v *Parameter) Parent() *Function</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#Parameter.Pos">func (v *Parameter) Pos() token.Pos</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#Parameter.Referrers">func (v *Parameter) Referrers() *[]Instruction</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#Parameter.String">func (v *Parameter) String() string</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#Parameter.Type">func (v *Parameter) Type() types.Type</a></dd>
				
			
				
				<dd><a href="index.html#Phi">type Phi</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#Phi.Name">func (v *Phi) Name() string</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#Phi.Operands">func (v *Phi) Operands(rands []*Value) []*Value</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#Phi.Pos">func (v *Phi) Pos() token.Pos</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#Phi.Referrers">func (v *Phi) Referrers() *[]Instruction</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#Phi.String">func (v *Phi) String() string</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#Phi.Type">func (v *Phi) Type() types.Type</a></dd>
				
			
				
				<dd><a href="index.html#Program">type Program</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#NewProgram">func NewProgram(fset *token.FileSet, mode BuilderMode) *Program</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#Program.AllPackages">func (prog *Program) AllPackages() []*Package</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#Program.Build">func (prog *Program) Build()</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#Program.ConstValue">func (prog *Program) ConstValue(obj *types.Const) *Const</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#Program.CreatePackage">func (prog *Program) CreatePackage(pkg *types.Package, files []*ast.File, info *types.Info, importable bool) *Package</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#Program.CreateTestMainPackage">func (prog *Program) CreateTestMainPackage(pkg *Package) *Package</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#Program.FuncValue">func (prog *Program) FuncValue(obj *types.Func) *Function</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#Program.ImportedPackage">func (prog *Program) ImportedPackage(path string) *Package</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#Program.LookupMethod">func (prog *Program) LookupMethod(T types.Type, pkg *types.Package, name string) *Function</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#Program.MethodValue">func (prog *Program) MethodValue(sel *types.Selection) *Function</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#Program.NewFunction">func (prog *Program) NewFunction(name string, sig *types.Signature, provenance string) *Function</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#Program.Package">func (prog *Program) Package(obj *types.Package) *Package</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#Program.RuntimeTypes">func (prog *Program) RuntimeTypes() []types.Type</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#Program.VarValue">func (prog *Program) VarValue(obj *types.Var, pkg *Package, ref []ast.Node) (value Value, isAddr bool)</a></dd>
				
			
				
				<dd><a href="index.html#Range">type Range</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#Range.Name">func (v *Range) Name() string</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#Range.Operands">func (v *Range) Operands(rands []*Value) []*Value</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#Range.Pos">func (v *Range) Pos() token.Pos</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#Range.Referrers">func (v *Range) Referrers() *[]Instruction</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#Range.String">func (v *Range) String() string</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#Range.Type">func (v *Range) Type() types.Type</a></dd>
				
			
				
				<dd><a href="index.html#Return">type Return</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#Return.Block">func (v *Return) Block() *BasicBlock</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#Return.Operands">func (s *Return) Operands(rands []*Value) []*Value</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#Return.Parent">func (v *Return) Parent() *Function</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#Return.Pos">func (s *Return) Pos() token.Pos</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#Return.Referrers">func (v *Return) Referrers() *[]Instruction</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#Return.String">func (s *Return) String() string</a></dd>
				
			
				
				<dd><a href="index.html#RunDefers">type RunDefers</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#RunDefers.Block">func (v *RunDefers) Block() *BasicBlock</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#RunDefers.Operands">func (*RunDefers) Operands(rands []*Value) []*Value</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#RunDefers.Parent">func (v *RunDefers) Parent() *Function</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#RunDefers.Pos">func (s *RunDefers) Pos() token.Pos</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#RunDefers.Referrers">func (v *RunDefers) Referrers() *[]Instruction</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#RunDefers.String">func (*RunDefers) String() string</a></dd>
				
			
				
				<dd><a href="index.html#Select">type Select</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#Select.Name">func (v *Select) Name() string</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#Select.Operands">func (v *Select) Operands(rands []*Value) []*Value</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#Select.Pos">func (v *Select) Pos() token.Pos</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#Select.Referrers">func (v *Select) Referrers() *[]Instruction</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#Select.String">func (s *Select) String() string</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#Select.Type">func (v *Select) Type() types.Type</a></dd>
				
			
				
				<dd><a href="index.html#SelectState">type SelectState</a></dd>
				
				
			
				
				<dd><a href="index.html#Send">type Send</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#Send.Block">func (v *Send) Block() *BasicBlock</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#Send.Operands">func (s *Send) Operands(rands []*Value) []*Value</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#Send.Parent">func (v *Send) Parent() *Function</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#Send.Pos">func (s *Send) Pos() token.Pos</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#Send.Referrers">func (v *Send) Referrers() *[]Instruction</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#Send.String">func (s *Send) String() string</a></dd>
				
			
				
				<dd><a href="index.html#Slice">type Slice</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#Slice.Name">func (v *Slice) Name() string</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#Slice.Operands">func (v *Slice) Operands(rands []*Value) []*Value</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#Slice.Pos">func (v *Slice) Pos() token.Pos</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#Slice.Referrers">func (v *Slice) Referrers() *[]Instruction</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#Slice.String">func (v *Slice) String() string</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#Slice.Type">func (v *Slice) Type() types.Type</a></dd>
				
			
				
				<dd><a href="index.html#Store">type Store</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#Store.Block">func (v *Store) Block() *BasicBlock</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#Store.Operands">func (s *Store) Operands(rands []*Value) []*Value</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#Store.Parent">func (v *Store) Parent() *Function</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#Store.Pos">func (s *Store) Pos() token.Pos</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#Store.Referrers">func (v *Store) Referrers() *[]Instruction</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#Store.String">func (s *Store) String() string</a></dd>
				
			
				
				<dd><a href="index.html#Type">type Type</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#Type.Name">func (t *Type) Name() string</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#Type.Object">func (t *Type) Object() types.Object</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#Type.Package">func (t *Type) Package() *Package</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#Type.Pos">func (t *Type) Pos() token.Pos</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#Type.RelString">func (t *Type) RelString(from *types.Package) string</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#Type.String">func (t *Type) String() string</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#Type.Token">func (t *Type) Token() token.Token</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#Type.Type">func (t *Type) Type() types.Type</a></dd>
				
			
				
				<dd><a href="index.html#TypeAssert">type TypeAssert</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#TypeAssert.Name">func (v *TypeAssert) Name() string</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#TypeAssert.Operands">func (v *TypeAssert) Operands(rands []*Value) []*Value</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#TypeAssert.Pos">func (v *TypeAssert) Pos() token.Pos</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#TypeAssert.Referrers">func (v *TypeAssert) Referrers() *[]Instruction</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#TypeAssert.String">func (v *TypeAssert) String() string</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#TypeAssert.Type">func (v *TypeAssert) Type() types.Type</a></dd>
				
			
				
				<dd><a href="index.html#UnOp">type UnOp</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#UnOp.Name">func (v *UnOp) Name() string</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#UnOp.Operands">func (v *UnOp) Operands(rands []*Value) []*Value</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#UnOp.Pos">func (v *UnOp) Pos() token.Pos</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#UnOp.Referrers">func (v *UnOp) Referrers() *[]Instruction</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#UnOp.String">func (v *UnOp) String() string</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#UnOp.Type">func (v *UnOp) Type() types.Type</a></dd>
				
			
				
				<dd><a href="index.html#Value">type Value</a></dd>
				
				
			
			
			</dl>
			</div><!-- #manual-nav -->

		
		<div id="pkg-examples">
			<h3>Examples</h3>
			<div class="js-expandAll expandAll collapsed">(Expand All)</div>
			<dl>
			
			<dd><a class="exampleLink" href="index.html#example__buildPackage">Package (BuildPackage)</a></dd>
			
			<dd><a class="exampleLink" href="index.html#example__loadPackages">Package (LoadPackages)</a></dd>
			
			<dd><a class="exampleLink" href="index.html#example__loadWholeProgram">Package (LoadWholeProgram)</a></dd>
			
			</dl>
		</div>
		

		
			<h3>Package files</h3>
			<p>
			<span style="font-size:90%">
			
				<a href="http://localhost:6060/src/golang.org/x/tools/go/ssa/blockopt.go">blockopt.go</a>
			
				<a href="http://localhost:6060/src/golang.org/x/tools/go/ssa/builder.go">builder.go</a>
			
				<a href="http://localhost:6060/src/golang.org/x/tools/go/ssa/const.go">const.go</a>
			
				<a href="http://localhost:6060/src/golang.org/x/tools/go/ssa/create.go">create.go</a>
			
				<a href="http://localhost:6060/src/golang.org/x/tools/go/ssa/doc.go">doc.go</a>
			
				<a href="http://localhost:6060/src/golang.org/x/tools/go/ssa/dom.go">dom.go</a>
			
				<a href="http://localhost:6060/src/golang.org/x/tools/go/ssa/emit.go">emit.go</a>
			
				<a href="http://localhost:6060/src/golang.org/x/tools/go/ssa/func.go">func.go</a>
			
				<a href="http://localhost:6060/src/golang.org/x/tools/go/ssa/identical.go">identical.go</a>
			
				<a href="http://localhost:6060/src/golang.org/x/tools/go/ssa/lift.go">lift.go</a>
			
				<a href="http://localhost:6060/src/golang.org/x/tools/go/ssa/lvalue.go">lvalue.go</a>
			
				<a href="http://localhost:6060/src/golang.org/x/tools/go/ssa/methods.go">methods.go</a>
			
				<a href="http://localhost:6060/src/golang.org/x/tools/go/ssa/mode.go">mode.go</a>
			
				<a href="http://localhost:6060/src/golang.org/x/tools/go/ssa/print.go">print.go</a>
			
				<a href="http://localhost:6060/src/golang.org/x/tools/go/ssa/sanity.go">sanity.go</a>
			
				<a href="http://localhost:6060/src/golang.org/x/tools/go/ssa/source.go">source.go</a>
			
				<a href="http://localhost:6060/src/golang.org/x/tools/go/ssa/ssa.go">ssa.go</a>
			
				<a href="http://localhost:6060/src/golang.org/x/tools/go/ssa/testmain.go">testmain.go</a>
			
				<a href="http://localhost:6060/src/golang.org/x/tools/go/ssa/util.go">util.go</a>
			
				<a href="http://localhost:6060/src/golang.org/x/tools/go/ssa/wrappers.go">wrappers.go</a>
			
			</span>
			</p>
		
		</div><!-- .expanded -->
		</div><!-- #pkg-index -->

		

		
			<h2 id="pkg-constants">Constants</h2>
			
				
				<pre>const <span id="BuilderModeDoc">BuilderModeDoc</span> = `Options controlling the SSA builder.
The value is a sequence of zero or more of these letters:
C	perform sanity [C]hecking of the SSA form.
D	include [D]ebug info for every function.
P	print [P]ackage inventory.
F	print [F]unction SSA code.
S	log [S]ource locations as SSA builder progresses.
L	build distinct packages seria[L]ly instead of in parallel.
N	build [N]aive SSA form: don&#39;t replace local loads/stores with registers.
I	build bare [I]nit functions: no init guards or calls to dependent inits.
`</pre>
			
		
		
		
			
			
			<h2 id="DefaultType">func <a href="http://localhost:6060/src/golang.org/x/tools/go/ssa/util.go?s=1559:1602#L53">DefaultType</a>
				<a class="permalink" href="index.html#DefaultType">&#xb6;</a>
				
				
			</h2>
			<pre>func DefaultType(typ <a href="http://localhost:6060/pkg/go/types/">types</a>.<a href="http://localhost:6060/pkg/go/types/#Type">Type</a>) <a href="http://localhost:6060/pkg/go/types/">types</a>.<a href="http://localhost:6060/pkg/go/types/#Type">Type</a></pre>
			<p>
DefaultType returns the default &#34;typed&#34; type for an &#34;untyped&#34; type;
it returns the incoming type for all other types.  The default type
for untyped nil is untyped nil.
</p>
<p>
Exported to ssa/interp.
</p>
<p>
TODO(adonovan): use go/types.DefaultType after 1.8.
</p>

			
			

		
			
			
			<h2 id="FindTests">func <a href="http://localhost:6060/src/golang.org/x/tools/go/ssa/testmain.go?s=855:941#L22">FindTests</a>
				<a class="permalink" href="index.html#FindTests">&#xb6;</a>
				
				
			</h2>
			<pre>func FindTests(pkg *<a href="index.html#Package">Package</a>) (tests, benchmarks, examples []*<a href="index.html#Function">Function</a>, main *<a href="index.html#Function">Function</a>)</pre>
			<p>
FindTests returns the Test, Benchmark, and Example functions
(as defined by &#34;go test&#34;) defined in the specified package,
and its TestMain function, if any.
</p>
<p>
Deprecated: Use golang.org/x/tools/go/packages to access synthetic
testmain packages.
</p>

			
			

		
			
			
			<h2 id="HasEnclosingFunction">func <a href="http://localhost:6060/src/golang.org/x/tools/go/ssa/source.go?s=2051:2112#L59">HasEnclosingFunction</a>
				<a class="permalink" href="index.html#HasEnclosingFunction">&#xb6;</a>
				
				
			</h2>
			<pre>func HasEnclosingFunction(pkg *<a href="index.html#Package">Package</a>, path []<a href="http://localhost:6060/pkg/go/ast/">ast</a>.<a href="http://localhost:6060/pkg/go/ast/#Node">Node</a>) <a href="http://localhost:6060/pkg/builtin/#bool">bool</a></pre>
			<p>
HasEnclosingFunction returns true if the AST node denoted by path
is contained within the declaration of some function or
package-level variable.
</p>
<p>
Unlike EnclosingFunction, the behaviour of this function does not
depend on whether SSA code for pkg has been built, so it can be
used to quickly reject check inputs that will cause
EnclosingFunction to fail, prior to SSA building.
</p>

			
			

		
			
			
			<h2 id="WriteFunction">func <a href="http://localhost:6060/src/golang.org/x/tools/go/ssa/func.go?s=14627:14677#L540">WriteFunction</a>
				<a class="permalink" href="index.html#WriteFunction">&#xb6;</a>
				
				
			</h2>
			<pre>func WriteFunction(buf *<a href="http://localhost:6060/pkg/bytes/">bytes</a>.<a href="http://localhost:6060/pkg/bytes/#Buffer">Buffer</a>, f *<a href="index.html#Function">Function</a>)</pre>
			<p>
WriteFunction writes to buf a human-readable &#34;disassembly&#34; of f.
</p>

			
			

		
			
			
			<h2 id="WritePackage">func <a href="http://localhost:6060/src/golang.org/x/tools/go/ssa/print.go?s=9187:9235#L376">WritePackage</a>
				<a class="permalink" href="index.html#WritePackage">&#xb6;</a>
				
				
			</h2>
			<pre>func WritePackage(buf *<a href="http://localhost:6060/pkg/bytes/">bytes</a>.<a href="http://localhost:6060/pkg/bytes/#Buffer">Buffer</a>, p *<a href="index.html#Package">Package</a>)</pre>
			<p>
WritePackage writes to buf a human-readable summary of p.
</p>

			
			

		
		
			
			
			<h2 id="Alloc">type <a href="http://localhost:6060/src/golang.org/x/tools/go/ssa/ssa.go?s=18980:19086#L483">Alloc</a>
				<a class="permalink" href="index.html#Alloc">&#xb6;</a>
				
				
			</h2>
			<p>
The Alloc instruction reserves space for a variable of the given type,
zero-initializes it, and yields its address.
</p>
<p>
Alloc values are always addresses, and have pointer types, so the
type of the allocated variable is actually
Type().Underlying().(*types.Pointer).Elem().
</p>
<p>
If Heap is false, Alloc allocates space in the function&#39;s
activation record (frame); we refer to an Alloc(Heap=false) as a
&#34;local&#34; alloc.  Each local Alloc returns the same address each time
it is executed within the same activation; the space is
re-initialized to zero.
</p>
<p>
If Heap is true, Alloc allocates space in the heap; we
refer to an Alloc(Heap=true) as a &#34;new&#34; alloc.  Each new Alloc
returns a different address each time it is executed.
</p>
<p>
When Alloc is applied to a channel, map or slice type, it returns
the address of an uninitialized (nil) reference of that kind; store
the result of MakeSlice, MakeMap or MakeChan in that location to
instantiate these types.
</p>
<p>
Pos() returns the ast.CompositeLit.Lbrace for a composite literal,
or the ast.CallExpr.Rparen for a call to new() or for a call that
allocates a varargs slice.
</p>
<p>
Example printed form:
</p>
<pre>t0 = local int
t1 = new int
</pre>

			<pre>type Alloc struct {
<span id="Alloc.Comment"></span>    Comment <a href="http://localhost:6060/pkg/builtin/#string">string</a>
<span id="Alloc.Heap"></span>    Heap    <a href="http://localhost:6060/pkg/builtin/#bool">bool</a>
    <span class="comment">// contains filtered or unexported fields</span>
}
</pre>

			

			

			
			
			

			

			
				
				<h3 id="Alloc.Name">func (*Alloc) <a href="http://localhost:6060/src/golang.org/x/tools/go/ssa/ssa.go?s=49432:49464#L1442">Name</a>
					<a class="permalink" href="index.html#Alloc.Name">&#xb6;</a>
					
					
				</h3>
				<pre>func (v *<a href="index.html#Alloc">Alloc</a>) Name() <a href="http://localhost:6060/pkg/builtin/#string">string</a></pre>
				
				
				
				
			
				
				<h3 id="Alloc.Operands">func (*Alloc) <a href="http://localhost:6060/src/golang.org/x/tools/go/ssa/ssa.go?s=52792:52841#L1518">Operands</a>
					<a class="permalink" href="index.html#Alloc.Operands">&#xb6;</a>
					
					
				</h3>
				<pre>func (v *<a href="index.html#Alloc">Alloc</a>) Operands(rands []*<a href="index.html#Value">Value</a>) []*<a href="index.html#Value">Value</a></pre>
				
				
				
				
			
				
				<h3 id="Alloc.Pos">func (*Alloc) <a href="http://localhost:6060/src/golang.org/x/tools/go/ssa/ssa.go?s=49246:49277#L1438">Pos</a>
					<a class="permalink" href="index.html#Alloc.Pos">&#xb6;</a>
					
					
				</h3>
				<pre>func (v *<a href="index.html#Alloc">Alloc</a>) Pos() <a href="http://localhost:6060/pkg/go/token/">token</a>.<a href="http://localhost:6060/pkg/go/token/#Pos">Pos</a></pre>
				
				
				
				
			
				
				<h3 id="Alloc.Referrers">func (*Alloc) <a href="http://localhost:6060/src/golang.org/x/tools/go/ssa/ssa.go?s=49179:49221#L1437">Referrers</a>
					<a class="permalink" href="index.html#Alloc.Referrers">&#xb6;</a>
					
					
				</h3>
				<pre>func (v *<a href="index.html#Alloc">Alloc</a>) Referrers() *[]<a href="index.html#Instruction">Instruction</a></pre>
				
				
				
				
			
				
				<h3 id="Alloc.String">func (*Alloc) <a href="http://localhost:6060/src/golang.org/x/tools/go/ssa/print.go?s=1845:1876#L65">String</a>
					<a class="permalink" href="index.html#Alloc.String">&#xb6;</a>
					
					
				</h3>
				<pre>func (v *<a href="index.html#Alloc">Alloc</a>) String() <a href="http://localhost:6060/pkg/builtin/#string">string</a></pre>
				
				
				
				
			
				
				<h3 id="Alloc.Type">func (*Alloc) <a href="http://localhost:6060/src/golang.org/x/tools/go/ssa/ssa.go?s=49119:49152#L1436">Type</a>
					<a class="permalink" href="index.html#Alloc.Type">&#xb6;</a>
					
					
				</h3>
				<pre>func (v *<a href="index.html#Alloc">Alloc</a>) Type() <a href="http://localhost:6060/pkg/go/types/">types</a>.<a href="http://localhost:6060/pkg/go/types/#Type">Type</a></pre>
				
				
				
				
			
		
			
			
			<h2 id="BasicBlock">type <a href="http://localhost:6060/src/golang.org/x/tools/go/ssa/ssa.go?s=14040:14613#L335">BasicBlock</a>
				<a class="permalink" href="index.html#BasicBlock">&#xb6;</a>
				
				
			</h2>
			<p>
BasicBlock represents an SSA basic block.
</p>
<p>
The final element of Instrs is always an explicit transfer of
control (If, Jump, Return, or Panic).
</p>
<p>
A block may contain no Instructions only if it is unreachable,
i.e., Preds is nil.  Empty blocks are typically pruned.
</p>
<p>
BasicBlocks and their Preds/Succs relation form a (possibly cyclic)
graph independent of the SSA Value graph: the control-flow graph or
CFG.  It is illegal for multiple edges to exist between the same
pair of blocks.
</p>
<p>
Each BasicBlock is also a node in the dominator tree of the CFG.
The tree may be navigated using Idom()/Dominees() and queried using
Dominates().
</p>
<p>
The order of Preds and Succs is significant (to Phi and If
instructions, respectively).
</p>

			<pre>type BasicBlock struct {
<span id="BasicBlock.Index"></span>    Index   <a href="http://localhost:6060/pkg/builtin/#int">int</a>    <span class="comment">// index of this block within Parent().Blocks</span>
<span id="BasicBlock.Comment"></span>    Comment <a href="http://localhost:6060/pkg/builtin/#string">string</a> <span class="comment">// optional label; no semantic significance</span>

<span id="BasicBlock.Instrs"></span>    Instrs       []<a href="index.html#Instruction">Instruction</a> <span class="comment">// instructions in order</span>
<span id="BasicBlock.Preds"></span>    Preds, Succs []*<a href="index.html#BasicBlock">BasicBlock</a> <span class="comment">// predecessors and successors</span>
    <span class="comment">// contains filtered or unexported fields</span>
}
</pre>

			

			

			
			
			

			

			
				
				<h3 id="BasicBlock.Dominates">func (*BasicBlock) <a href="http://localhost:6060/src/golang.org/x/tools/go/ssa/dom.go?s=1258:1308#L31">Dominates</a>
					<a class="permalink" href="index.html#BasicBlock.Dominates">&#xb6;</a>
					
					
				</h3>
				<pre>func (b *<a href="index.html#BasicBlock">BasicBlock</a>) Dominates(c *<a href="index.html#BasicBlock">BasicBlock</a>) <a href="http://localhost:6060/pkg/builtin/#bool">bool</a></pre>
				<p>
Dominates reports whether b dominates c.
</p>

				
				
				
			
				
				<h3 id="BasicBlock.Dominees">func (*BasicBlock) <a href="http://localhost:6060/src/golang.org/x/tools/go/ssa/dom.go?s=1141:1186#L28">Dominees</a>
					<a class="permalink" href="index.html#BasicBlock.Dominees">&#xb6;</a>
					
					
				</h3>
				<pre>func (b *<a href="index.html#BasicBlock">BasicBlock</a>) Dominees() []*<a href="index.html#BasicBlock">BasicBlock</a></pre>
				<p>
Dominees returns the list of blocks that b immediately dominates:
its children in the dominator tree.
</p>

				
				
				
			
				
				<h3 id="BasicBlock.Idom">func (*BasicBlock) <a href="http://localhost:6060/src/golang.org/x/tools/go/ssa/dom.go?s=967:1006#L23">Idom</a>
					<a class="permalink" href="index.html#BasicBlock.Idom">&#xb6;</a>
					
					
				</h3>
				<pre>func (b *<a href="index.html#BasicBlock">BasicBlock</a>) Idom() *<a href="index.html#BasicBlock">BasicBlock</a></pre>
				<p>
Idom returns the block that immediately dominates b:
its parent in the dominator tree, if any.
Neither the entry node (b.Index==0) nor recover node
(b==b.Parent().Recover()) have a parent.
</p>

				
				
				
			
				
				<h3 id="BasicBlock.Parent">func (*BasicBlock) <a href="http://localhost:6060/src/golang.org/x/tools/go/ssa/func.go?s=543:582#L17">Parent</a>
					<a class="permalink" href="index.html#BasicBlock.Parent">&#xb6;</a>
					
					
				</h3>
				<pre>func (b *<a href="index.html#BasicBlock">BasicBlock</a>) Parent() *<a href="index.html#Function">Function</a></pre>
				<p>
Parent returns the function that contains block b.
</p>

				
				
				
			
				
				<h3 id="BasicBlock.String">func (*BasicBlock) <a href="http://localhost:6060/src/golang.org/x/tools/go/ssa/func.go?s=715:751#L22">String</a>
					<a class="permalink" href="index.html#BasicBlock.String">&#xb6;</a>
					
					
				</h3>
				<pre>func (b *<a href="index.html#BasicBlock">BasicBlock</a>) String() <a href="http://localhost:6060/pkg/builtin/#string">string</a></pre>
				<p>
String returns a human-readable label of this block.
It is not guaranteed unique within the function.
</p>

				
				
				
			
		
			
			
			<h2 id="BinOp">type <a href="http://localhost:6060/src/golang.org/x/tools/go/ssa/ssa.go?s=20369:20582#L535">BinOp</a>
				<a class="permalink" href="index.html#BinOp">&#xb6;</a>
				
				
			</h2>
			<p>
The BinOp instruction yields the result of binary operation X Op Y.
</p>
<p>
Pos() returns the ast.BinaryExpr.OpPos, if explicit in the source.
</p>
<p>
Example printed form:
</p>
<pre>t1 = t0 + 1:int
</pre>

			<pre>type BinOp struct {

    <span class="comment">// One of:</span>
    <span class="comment">// ADD SUB MUL QUO REM          + - * / %</span>
    <span class="comment">// AND OR XOR SHL SHR AND_NOT   &amp; | ^ &lt;&lt; &gt;&gt; &amp;^</span>
    <span class="comment">// EQL NEQ LSS LEQ GTR GEQ      == != &lt; &lt;= &lt; &gt;=</span>
<span id="BinOp.Op"></span>    Op   <a href="http://localhost:6060/pkg/go/token/">token</a>.<a href="http://localhost:6060/pkg/go/token/#Token">Token</a>
<span id="BinOp.X"></span>    X, Y <a href="index.html#Value">Value</a>
    <span class="comment">// contains filtered or unexported fields</span>
}
</pre>

			

			

			
			
			

			

			
				
				<h3 id="BinOp.Name">func (*BinOp) <a href="http://localhost:6060/src/golang.org/x/tools/go/ssa/ssa.go?s=49432:49464#L1442">Name</a>
					<a class="permalink" href="index.html#BinOp.Name">&#xb6;</a>
					
					
				</h3>
				<pre>func (v *<a href="index.html#BinOp">BinOp</a>) Name() <a href="http://localhost:6060/pkg/builtin/#string">string</a></pre>
				
				
				
				
			
				
				<h3 id="BinOp.Operands">func (*BinOp) <a href="http://localhost:6060/src/golang.org/x/tools/go/ssa/ssa.go?s=52861:52910#L1522">Operands</a>
					<a class="permalink" href="index.html#BinOp.Operands">&#xb6;</a>
					
					
				</h3>
				<pre>func (v *<a href="index.html#BinOp">BinOp</a>) Operands(rands []*<a href="index.html#Value">Value</a>) []*<a href="index.html#Value">Value</a></pre>
				
				
				
				
			
				
				<h3 id="BinOp.Pos">func (*BinOp) <a href="http://localhost:6060/src/golang.org/x/tools/go/ssa/ssa.go?s=49647:49681#L1445">Pos</a>
					<a class="permalink" href="index.html#BinOp.Pos">&#xb6;</a>
					
					
				</h3>
				<pre>func (v *<a href="index.html#BinOp">BinOp</a>) Pos() <a href="http://localhost:6060/pkg/go/token/">token</a>.<a href="http://localhost:6060/pkg/go/token/#Pos">Pos</a></pre>
				
				
				
				
			
				
				<h3 id="BinOp.Referrers">func (*BinOp) <a href="http://localhost:6060/src/golang.org/x/tools/go/ssa/ssa.go?s=49577:49622#L1444">Referrers</a>
					<a class="permalink" href="index.html#BinOp.Referrers">&#xb6;</a>
					
					
				</h3>
				<pre>func (v *<a href="index.html#BinOp">BinOp</a>) Referrers() *[]<a href="index.html#Instruction">Instruction</a></pre>
				
				
				
				
			
				
				<h3 id="BinOp.String">func (*BinOp) <a href="http://localhost:6060/src/golang.org/x/tools/go/ssa/print.go?s=3263:3294#L135">String</a>
					<a class="permalink" href="index.html#BinOp.String">&#xb6;</a>
					
					
				</h3>
				<pre>func (v *<a href="index.html#BinOp">BinOp</a>) String() <a href="http://localhost:6060/pkg/builtin/#string">string</a></pre>
				
				
				
				
			
				
				<h3 id="BinOp.Type">func (*BinOp) <a href="http://localhost:6060/src/golang.org/x/tools/go/ssa/ssa.go?s=49307:49343#L1440">Type</a>
					<a class="permalink" href="index.html#BinOp.Type">&#xb6;</a>
					
					
				</h3>
				<pre>func (v *<a href="index.html#BinOp">BinOp</a>) Type() <a href="http://localhost:6060/pkg/go/types/">types</a>.<a href="http://localhost:6060/pkg/go/types/#Type">Type</a></pre>
				
				
				
				
			
		
			
			
			<h2 id="BuilderMode">type <a href="http://localhost:6060/src/golang.org/x/tools/go/ssa/mode.go?s=510:531#L11">BuilderMode</a>
				<a class="permalink" href="index.html#BuilderMode">&#xb6;</a>
				
				
			</h2>
			<p>
BuilderMode is a bitmask of options for diagnostics and checking.
</p>
<p>
*BuilderMode satisfies the flag.Value interface.  Example:
</p>
<pre>var mode = ssa.BuilderMode(0)
func init() { flag.Var(&amp;mode, &#34;build&#34;, ssa.BuilderModeDoc) }
</pre>

			<pre>type BuilderMode <a href="http://localhost:6060/pkg/builtin/#uint">uint</a></pre>

			
				
				<pre>const (
    <span id="PrintPackages">PrintPackages</span>        <a href="index.html#BuilderMode">BuilderMode</a> = 1 &lt;&lt; <a href="http://localhost:6060/pkg/builtin/#iota">iota</a> <span class="comment">// Print package inventory to stdout</span>
    <span id="PrintFunctions">PrintFunctions</span>                               <span class="comment">// Print function SSA code to stdout</span>
    <span id="LogSource">LogSource</span>                                    <span class="comment">// Log source locations as SSA builder progresses</span>
    <span id="SanityCheckFunctions">SanityCheckFunctions</span>                         <span class="comment">// Perform sanity checking of function bodies</span>
    <span id="NaiveForm">NaiveForm</span>                                    <span class="comment">// Build naïve SSA form: don&#39;t replace local loads/stores with registers</span>
    <span id="BuildSerially">BuildSerially</span>                                <span class="comment">// Build packages serially, not in parallel.</span>
    <span id="GlobalDebug">GlobalDebug</span>                                  <span class="comment">// Enable debug info for all packages</span>
    <span id="BareInits">BareInits</span>                                    <span class="comment">// Build init functions without guards or calls to dependent inits</span>
)</pre>
			

			

			
			
			

			

			
				
				<h3 id="BuilderMode.Get">func (BuilderMode) <a href="http://localhost:6060/src/golang.org/x/tools/go/ssa/mode.go?s=2827:2865#L90">Get</a>
					<a class="permalink" href="index.html#BuilderMode.Get">&#xb6;</a>
					
					
				</h3>
				<pre>func (m <a href="index.html#BuilderMode">BuilderMode</a>) Get() interface{}</pre>
				<p>
Get returns m.
</p>

				
				
				
			
				
				<h3 id="BuilderMode.Set">func (*BuilderMode) <a href="http://localhost:6060/src/golang.org/x/tools/go/ssa/mode.go?s=2332:2373#L63">Set</a>
					<a class="permalink" href="index.html#BuilderMode.Set">&#xb6;</a>
					
					
				</h3>
				<pre>func (m *<a href="index.html#BuilderMode">BuilderMode</a>) Set(s <a href="http://localhost:6060/pkg/builtin/#string">string</a>) <a href="http://localhost:6060/pkg/builtin/#error">error</a></pre>
				<p>
Set parses the flag characters in s and updates *m.
</p>

				
				
				
			
				
				<h3 id="BuilderMode.String">func (BuilderMode) <a href="http://localhost:6060/src/golang.org/x/tools/go/ssa/mode.go?s=1837:1873#L36">String</a>
					<a class="permalink" href="index.html#BuilderMode.String">&#xb6;</a>
					
					
				</h3>
				<pre>func (m <a href="index.html#BuilderMode">BuilderMode</a>) String() <a href="http://localhost:6060/pkg/builtin/#string">string</a></pre>
				
				
				
				
			
		
			
			
			<h2 id="Builtin">type <a href="http://localhost:6060/src/golang.org/x/tools/go/ssa/ssa.go?s=17606:17665#L446">Builtin</a>
				<a class="permalink" href="index.html#Builtin">&#xb6;</a>
				
				
			</h2>
			<p>
A Builtin represents a specific use of a built-in function, e.g. len.
</p>
<p>
Builtins are immutable values.  Builtins do not have addresses.
Builtins can only appear in CallCommon.Func.
</p>
<p>
Name() indicates the function: one of the built-in functions from the
Go spec (excluding &#34;make&#34; and &#34;new&#34;) or one of these ssa-defined
intrinsics:
</p>
<pre>// wrapnilchk returns ptr if non-nil, panics otherwise.
// (For use in indirection wrappers.)
func ssa:wrapnilchk(ptr *T, recvType, methodName string) *T
</pre>
<p>
Object() returns a *types.Builtin for built-ins defined by the spec,
nil for others.
</p>
<p>
Type() returns a *types.Signature representing the effective
signature of the built-in for this call.
</p>

			<pre>type Builtin struct {
    <span class="comment">// contains filtered or unexported fields</span>
}
</pre>

			

			

			
			
			

			

			
				
				<h3 id="Builtin.Name">func (*Builtin) <a href="http://localhost:6060/src/golang.org/x/tools/go/ssa/ssa.go?s=46718:46749#L1391">Name</a>
					<a class="permalink" href="index.html#Builtin.Name">&#xb6;</a>
					
					
				</h3>
				<pre>func (v *<a href="index.html#Builtin">Builtin</a>) Name() <a href="http://localhost:6060/pkg/builtin/#string">string</a></pre>
				
				
				
				
			
				
				<h3 id="Builtin.Object">func (*Builtin) <a href="http://localhost:6060/src/golang.org/x/tools/go/ssa/ssa.go?s=46903:46942#L1394">Object</a>
					<a class="permalink" href="index.html#Builtin.Object">&#xb6;</a>
					
					
				</h3>
				<pre>func (v *<a href="index.html#Builtin">Builtin</a>) Object() <a href="http://localhost:6060/pkg/go/types/">types</a>.<a href="http://localhost:6060/pkg/go/types/#Object">Object</a></pre>
				
				
				
				
			
				
				<h3 id="Builtin.Operands">func (*Builtin) <a href="http://localhost:6060/src/golang.org/x/tools/go/ssa/ssa.go?s=56318:56369#L1680">Operands</a>
					<a class="permalink" href="index.html#Builtin.Operands">&#xb6;</a>
					
					
				</h3>
				<pre>func (v *<a href="index.html#Builtin">Builtin</a>) Operands(rands []*<a href="index.html#Value">Value</a>) []*<a href="index.html#Value">Value</a></pre>
				<p>
Non-Instruction Values:
</p>

				
				
				
			
				
				<h3 id="Builtin.Parent">func (*Builtin) <a href="http://localhost:6060/src/golang.org/x/tools/go/ssa/ssa.go?s=46987:47023#L1395">Parent</a>
					<a class="permalink" href="index.html#Builtin.Parent">&#xb6;</a>
					
					
				</h3>
				<pre>func (v *<a href="index.html#Builtin">Builtin</a>) Parent() *<a href="index.html#Function">Function</a></pre>
				
				
				
				
			
				
				<h3 id="Builtin.Pos">func (*Builtin) <a href="http://localhost:6060/src/golang.org/x/tools/go/ssa/ssa.go?s=46837:46870#L1393">Pos</a>
					<a class="permalink" href="index.html#Builtin.Pos">&#xb6;</a>
					
					
				</h3>
				<pre>func (v *<a href="index.html#Builtin">Builtin</a>) Pos() <a href="http://localhost:6060/pkg/go/token/">token</a>.<a href="http://localhost:6060/pkg/go/token/#Pos">Pos</a></pre>
				
				
				
				
			
				
				<h3 id="Builtin.Referrers">func (*Builtin) <a href="http://localhost:6060/src/golang.org/x/tools/go/ssa/ssa.go?s=46779:46821#L1392">Referrers</a>
					<a class="permalink" href="index.html#Builtin.Referrers">&#xb6;</a>
					
					
				</h3>
				<pre>func (*<a href="index.html#Builtin">Builtin</a>) Referrers() *[]<a href="index.html#Instruction">Instruction</a></pre>
				
				
				
				
			
				
				<h3 id="Builtin.String">func (*Builtin) <a href="http://localhost:6060/src/golang.org/x/tools/go/ssa/print.go?s=1737:1770#L59">String</a>
					<a class="permalink" href="index.html#Builtin.String">&#xb6;</a>
					
					
				</h3>
				<pre>func (v *<a href="index.html#Builtin">Builtin</a>) String() <a href="http://localhost:6060/pkg/builtin/#string">string</a></pre>
				
				
				
				
			
				
				<h3 id="Builtin.Type">func (*Builtin) <a href="http://localhost:6060/src/golang.org/x/tools/go/ssa/ssa.go?s=46658:46693#L1390">Type</a>
					<a class="permalink" href="index.html#Builtin.Type">&#xb6;</a>
					
					
				</h3>
				<pre>func (v *<a href="index.html#Builtin">Builtin</a>) Type() <a href="http://localhost:6060/pkg/go/types/">types</a>.<a href="http://localhost:6060/pkg/go/types/#Type">Type</a></pre>
				
				
				
				
			
		
			
			
			<h2 id="Call">type <a href="http://localhost:6060/src/golang.org/x/tools/go/ssa/ssa.go?s=20125:20172#L523">Call</a>
				<a class="permalink" href="index.html#Call">&#xb6;</a>
				
				
			</h2>
			<p>
The Call instruction represents a function or method call.
</p>
<p>
The Call instruction yields the function result if there is exactly
one.  Otherwise it returns a tuple, the components of which are
accessed via Extract.
</p>
<p>
See CallCommon for generic function call documentation.
</p>
<p>
Pos() returns the ast.CallExpr.Lparen, if explicit in the source.
</p>
<p>
Example printed form:
</p>
<pre>t2 = println(t0, t1)
t4 = t3()
t7 = invoke t5.Println(...t6)
</pre>

			<pre>type Call struct {
<span id="Call.Call"></span>    Call <a href="index.html#CallCommon">CallCommon</a>
    <span class="comment">// contains filtered or unexported fields</span>
}
</pre>

			

			

			
			
			

			

			
				
				<h3 id="Call.Common">func (*Call) <a href="http://localhost:6060/src/golang.org/x/tools/go/ssa/ssa.go?s=46355:46390#L1382">Common</a>
					<a class="permalink" href="index.html#Call.Common">&#xb6;</a>
					
					
				</h3>
				<pre>func (s *<a href="index.html#Call">Call</a>) Common() *<a href="index.html#CallCommon">CallCommon</a></pre>
				
				
				
				
			
				
				<h3 id="Call.Name">func (*Call) <a href="http://localhost:6060/src/golang.org/x/tools/go/ssa/ssa.go?s=49432:49464#L1442">Name</a>
					<a class="permalink" href="index.html#Call.Name">&#xb6;</a>
					
					
				</h3>
				<pre>func (v *<a href="index.html#Call">Call</a>) Name() <a href="http://localhost:6060/pkg/builtin/#string">string</a></pre>
				
				
				
				
			
				
				<h3 id="Call.Operands">func (*Call) <a href="http://localhost:6060/src/golang.org/x/tools/go/ssa/ssa.go?s=53204:53252#L1538">Operands</a>
					<a class="permalink" href="index.html#Call.Operands">&#xb6;</a>
					
					
				</h3>
				<pre>func (s *<a href="index.html#Call">Call</a>) Operands(rands []*<a href="index.html#Value">Value</a>) []*<a href="index.html#Value">Value</a></pre>
				
				
				
				
			
				
				<h3 id="Call.Pos">func (*Call) <a href="http://localhost:6060/src/golang.org/x/tools/go/ssa/ssa.go?s=52111:52141#L1503">Pos</a>
					<a class="permalink" href="index.html#Call.Pos">&#xb6;</a>
					
					
				</h3>
				<pre>func (v *<a href="index.html#Call">Call</a>) Pos() <a href="http://localhost:6060/pkg/go/token/">token</a>.<a href="http://localhost:6060/pkg/go/token/#Pos">Pos</a></pre>
				
				
				
				
			
				
				<h3 id="Call.Referrers">func (*Call) <a href="http://localhost:6060/src/golang.org/x/tools/go/ssa/ssa.go?s=49577:49622#L1444">Referrers</a>
					<a class="permalink" href="index.html#Call.Referrers">&#xb6;</a>
					
					
				</h3>
				<pre>func (v *<a href="index.html#Call">Call</a>) Referrers() *[]<a href="index.html#Instruction">Instruction</a></pre>
				
				
				
				
			
				
				<h3 id="Call.String">func (*Call) <a href="http://localhost:6060/src/golang.org/x/tools/go/ssa/print.go?s=3193:3223#L131">String</a>
					<a class="permalink" href="index.html#Call.String">&#xb6;</a>
					
					
				</h3>
				<pre>func (v *<a href="index.html#Call">Call</a>) String() <a href="http://localhost:6060/pkg/builtin/#string">string</a></pre>
				
				
				
				
			
				
				<h3 id="Call.Type">func (*Call) <a href="http://localhost:6060/src/golang.org/x/tools/go/ssa/ssa.go?s=49307:49343#L1440">Type</a>
					<a class="permalink" href="index.html#Call.Type">&#xb6;</a>
					
					
				</h3>
				<pre>func (v *<a href="index.html#Call">Call</a>) Type() <a href="http://localhost:6060/pkg/go/types/">types</a>.<a href="http://localhost:6060/pkg/go/types/#Type">Type</a></pre>
				
				
				
				
			
				
				<h3 id="Call.Value">func (*Call) <a href="http://localhost:6060/src/golang.org/x/tools/go/ssa/ssa.go?s=46524:46552#L1386">Value</a>
					<a class="permalink" href="index.html#Call.Value">&#xb6;</a>
					
					
				</h3>
				<pre>func (s *<a href="index.html#Call">Call</a>) Value() *<a href="index.html#Call">Call</a></pre>
				
				
				
				
			
		
			
			
			<h2 id="CallCommon">type <a href="http://localhost:6060/src/golang.org/x/tools/go/ssa/ssa.go?s=44175:44485#L1311">CallCommon</a>
				<a class="permalink" href="index.html#CallCommon">&#xb6;</a>
				
				
			</h2>
			<p>
CallCommon is contained by Go, Defer and Call to hold the
common parts of a function or method call.
</p>
<p>
Each CallCommon exists in one of two modes, function call and
interface method invocation, or &#34;call&#34; and &#34;invoke&#34; for short.
</p>
<p>
1. &#34;call&#34; mode: when Method is nil (!IsInvoke), a CallCommon
represents an ordinary function call of the value in Value,
which may be a *Builtin, a *Function or any other value of kind
&#39;func&#39;.
</p>
<p>
Value may be one of:
</p>
<pre>(a) a *Function, indicating a statically dispatched call
    to a package-level function, an anonymous function, or
    a method of a named type.
(b) a *MakeClosure, indicating an immediately applied
    function literal with free variables.
(c) a *Builtin, indicating a statically dispatched call
    to a built-in function.
(d) any other value, indicating a dynamically dispatched
    function call.
</pre>
<p>
StaticCallee returns the identity of the callee in cases
(a) and (b), nil otherwise.
</p>
<p>
Args contains the arguments to the call.  If Value is a method,
Args[0] contains the receiver parameter.
</p>
<p>
Example printed form:
</p>
<pre>t2 = println(t0, t1)
go t3()
defer t5(...t6)
</pre>
<p>
2. &#34;invoke&#34; mode: when Method is non-nil (IsInvoke), a CallCommon
represents a dynamically dispatched call to an interface method.
In this mode, Value is the interface value and Method is the
interface&#39;s abstract method.  Note: an abstract method may be
shared by multiple interfaces due to embedding; Value.Type()
provides the specific interface used for this call.
</p>
<p>
Value is implicitly supplied to the concrete method implementation
as the receiver parameter; in other words, Args[0] holds not the
receiver but the first true argument.
</p>
<p>
Example printed form:
</p>
<pre>t1 = invoke t0.String()
go invoke t3.Run(t2)
defer invoke t4.Handle(...t5)
</pre>
<p>
For all calls to variadic functions (Signature().Variadic()),
the last element of Args is a slice.
</p>

			<pre>type CallCommon struct {
<span id="CallCommon.Value"></span>    Value  <a href="index.html#Value">Value</a>       <span class="comment">// receiver (invoke mode) or func value (call mode)</span>
<span id="CallCommon.Method"></span>    Method *<a href="http://localhost:6060/pkg/go/types/">types</a>.<a href="http://localhost:6060/pkg/go/types/#Func">Func</a> <span class="comment">// abstract method (invoke mode)</span>
<span id="CallCommon.Args"></span>    Args   []<a href="index.html#Value">Value</a>     <span class="comment">// actual parameters (in static method call, includes receiver)</span>
    <span class="comment">// contains filtered or unexported fields</span>
}
</pre>

			

			

			
			
			

			

			
				
				<h3 id="CallCommon.Description">func (*CallCommon) <a href="http://localhost:6060/src/golang.org/x/tools/go/ssa/ssa.go?s=45539:45580#L1354">Description</a>
					<a class="permalink" href="index.html#CallCommon.Description">&#xb6;</a>
					
					
				</h3>
				<pre>func (c *<a href="index.html#CallCommon">CallCommon</a>) Description() <a href="http://localhost:6060/pkg/builtin/#string">string</a></pre>
				<p>
Description returns a description of the mode of this call suitable
for a user interface, e.g., &#34;static method call&#34;.
</p>

				
				
				
			
				
				<h3 id="CallCommon.IsInvoke">func (*CallCommon) <a href="http://localhost:6060/src/golang.org/x/tools/go/ssa/ssa.go?s=44557:44593#L1319">IsInvoke</a>
					<a class="permalink" href="index.html#CallCommon.IsInvoke">&#xb6;</a>
					
					
				</h3>
				<pre>func (c *<a href="index.html#CallCommon">CallCommon</a>) IsInvoke() <a href="http://localhost:6060/pkg/builtin/#bool">bool</a></pre>
				<p>
IsInvoke returns true if this call has &#34;invoke&#34; (not &#34;call&#34;) mode.
</p>

				
				
				
			
				
				<h3 id="CallCommon.Operands">func (*CallCommon) <a href="http://localhost:6060/src/golang.org/x/tools/go/ssa/ssa.go?s=52950:53004#L1526">Operands</a>
					<a class="permalink" href="index.html#CallCommon.Operands">&#xb6;</a>
					
					
				</h3>
				<pre>func (c *<a href="index.html#CallCommon">CallCommon</a>) Operands(rands []*<a href="index.html#Value">Value</a>) []*<a href="index.html#Value">Value</a></pre>
				
				
				
				
			
				
				<h3 id="CallCommon.Pos">func (*CallCommon) <a href="http://localhost:6060/src/golang.org/x/tools/go/ssa/ssa.go?s=44623:44659#L1323">Pos</a>
					<a class="permalink" href="index.html#CallCommon.Pos">&#xb6;</a>
					
					
				</h3>
				<pre>func (c *<a href="index.html#CallCommon">CallCommon</a>) Pos() <a href="http://localhost:6060/pkg/go/token/">token</a>.<a href="http://localhost:6060/pkg/go/token/#Pos">Pos</a></pre>
				
				
				
				
			
				
				<h3 id="CallCommon.Signature">func (*CallCommon) <a href="http://localhost:6060/src/golang.org/x/tools/go/ssa/ssa.go?s=44963:45012#L1333">Signature</a>
					<a class="permalink" href="index.html#CallCommon.Signature">&#xb6;</a>
					
					
				</h3>
				<pre>func (c *<a href="index.html#CallCommon">CallCommon</a>) Signature() *<a href="http://localhost:6060/pkg/go/types/">types</a>.<a href="http://localhost:6060/pkg/go/types/#Signature">Signature</a></pre>
				<p>
Signature returns the signature of the called function.
</p>
<p>
For an &#34;invoke&#34;-mode call, the signature of the interface method is
returned.
</p>
<p>
In either &#34;call&#34; or &#34;invoke&#34; mode, if the callee is a method, its
receiver is represented by sig.Recv, not sig.Params().At(0).
</p>

				
				
				
			
				
				<h3 id="CallCommon.StaticCallee">func (*CallCommon) <a href="http://localhost:6060/src/golang.org/x/tools/go/ssa/ssa.go?s=45242:45287#L1342">StaticCallee</a>
					<a class="permalink" href="index.html#CallCommon.StaticCallee">&#xb6;</a>
					
					
				</h3>
				<pre>func (c *<a href="index.html#CallCommon">CallCommon</a>) StaticCallee() *<a href="index.html#Function">Function</a></pre>
				<p>
StaticCallee returns the callee if this is a trivially static
&#34;call&#34;-mode call to a function.
</p>

				
				
				
			
				
				<h3 id="CallCommon.String">func (*CallCommon) <a href="http://localhost:6060/src/golang.org/x/tools/go/ssa/print.go?s=3121:3157#L127">String</a>
					<a class="permalink" href="index.html#CallCommon.String">&#xb6;</a>
					
					
				</h3>
				<pre>func (c *<a href="index.html#CallCommon">CallCommon</a>) String() <a href="http://localhost:6060/pkg/builtin/#string">string</a></pre>
				
				
				
				
			
		
			
			
			<h2 id="CallInstruction">type <a href="http://localhost:6060/src/golang.org/x/tools/go/ssa/ssa.go?s=46153:46353#L1376">CallInstruction</a>
				<a class="permalink" href="index.html#CallInstruction">&#xb6;</a>
				
				
			</h2>
			<p>
The CallInstruction interface, implemented by *Go, *Defer and *Call,
exposes the common parts of function-calling instructions,
yet provides a way back to the Value defined by *Call alone.
</p>

			<pre>type CallInstruction interface {
    <a href="index.html#Instruction">Instruction</a>
    Common() *<a href="index.html#CallCommon">CallCommon</a> <span class="comment">// returns the common parts of the call</span>
    Value() *<a href="index.html#Call">Call</a>        <span class="comment">// returns the result value of the call (*Call) or nil (*Go, *Defer)</span>
}</pre>

			

			

			
			
			

			

			
		
			
			
			<h2 id="ChangeInterface">type <a href="http://localhost:6060/src/golang.org/x/tools/go/ssa/ssa.go?s=23615:23665#L638">ChangeInterface</a>
				<a class="permalink" href="index.html#ChangeInterface">&#xb6;</a>
				
				
			</h2>
			<p>
ChangeInterface constructs a value of one interface type from a
value of another interface type known to be assignable to it.
This operation cannot fail.
</p>
<p>
Pos() returns the ast.CallExpr.Lparen if the instruction arose from
an explicit T(e) conversion; the ast.TypeAssertExpr.Lparen if the
instruction arose from an explicit e.(T) operation; or token.NoPos
otherwise.
</p>
<p>
Example printed form:
</p>
<pre>t1 = change interface interface{} &lt;- I (t0)
</pre>

			<pre>type ChangeInterface struct {
<span id="ChangeInterface.X"></span>    X <a href="index.html#Value">Value</a>
    <span class="comment">// contains filtered or unexported fields</span>
}
</pre>

			

			

			
			
			

			

			
				
				<h3 id="ChangeInterface.Name">func (*ChangeInterface) <a href="http://localhost:6060/src/golang.org/x/tools/go/ssa/ssa.go?s=49432:49464#L1442">Name</a>
					<a class="permalink" href="index.html#ChangeInterface.Name">&#xb6;</a>
					
					
				</h3>
				<pre>func (v *<a href="index.html#ChangeInterface">ChangeInterface</a>) Name() <a href="http://localhost:6060/pkg/builtin/#string">string</a></pre>
				
				
				
				
			
				
				<h3 id="ChangeInterface.Operands">func (*ChangeInterface) <a href="http://localhost:6060/src/golang.org/x/tools/go/ssa/ssa.go?s=53375:53434#L1546">Operands</a>
					<a class="permalink" href="index.html#ChangeInterface.Operands">&#xb6;</a>
					
					
				</h3>
				<pre>func (v *<a href="index.html#ChangeInterface">ChangeInterface</a>) Operands(rands []*<a href="index.html#Value">Value</a>) []*<a href="index.html#Value">Value</a></pre>
				
				
				
				
			
				
				<h3 id="ChangeInterface.Pos">func (*ChangeInterface) <a href="http://localhost:6060/src/golang.org/x/tools/go/ssa/ssa.go?s=49647:49681#L1445">Pos</a>
					<a class="permalink" href="index.html#ChangeInterface.Pos">&#xb6;</a>
					
					
				</h3>
				<pre>func (v *<a href="index.html#ChangeInterface">ChangeInterface</a>) Pos() <a href="http://localhost:6060/pkg/go/token/">token</a>.<a href="http://localhost:6060/pkg/go/token/#Pos">Pos</a></pre>
				
				
				
				
			
				
				<h3 id="ChangeInterface.Referrers">func (*ChangeInterface) <a href="http://localhost:6060/src/golang.org/x/tools/go/ssa/ssa.go?s=49577:49622#L1444">Referrers</a>
					<a class="permalink" href="index.html#ChangeInterface.Referrers">&#xb6;</a>
					
					
				</h3>
				<pre>func (v *<a href="index.html#ChangeInterface">ChangeInterface</a>) Referrers() *[]<a href="index.html#Instruction">Instruction</a></pre>
				
				
				
				
			
				
				<h3 id="ChangeInterface.String">func (*ChangeInterface) <a href="http://localhost:6060/src/golang.org/x/tools/go/ssa/print.go?s=3872:3913#L154">String</a>
					<a class="permalink" href="index.html#ChangeInterface.String">&#xb6;</a>
					
					
				</h3>
				<pre>func (v *<a href="index.html#ChangeInterface">ChangeInterface</a>) String() <a href="http://localhost:6060/pkg/builtin/#string">string</a></pre>
				
				
				
				
			
				
				<h3 id="ChangeInterface.Type">func (*ChangeInterface) <a href="http://localhost:6060/src/golang.org/x/tools/go/ssa/ssa.go?s=49307:49343#L1440">Type</a>
					<a class="permalink" href="index.html#ChangeInterface.Type">&#xb6;</a>
					
					
				</h3>
				<pre>func (v *<a href="index.html#ChangeInterface">ChangeInterface</a>) Type() <a href="http://localhost:6060/pkg/go/types/">types</a>.<a href="http://localhost:6060/pkg/go/types/#Type">Type</a></pre>
				
				
				
				
			
		
			
			
			<h2 id="ChangeType">type <a href="http://localhost:6060/src/golang.org/x/tools/go/ssa/ssa.go?s=22140:22185#L592">ChangeType</a>
				<a class="permalink" href="index.html#ChangeType">&#xb6;</a>
				
				
			</h2>
			<p>
The ChangeType instruction applies to X a value-preserving type
change to Type().
</p>
<p>
Type changes are permitted:
</p>
<pre>- between a named type and its underlying type.
- between two named types of the same underlying type.
- between (possibly named) pointers to identical base types.
- from a bidirectional channel to a read- or write-channel,
  optionally adding/removing a name.
</pre>
<p>
This operation cannot fail dynamically.
</p>
<p>
Pos() returns the ast.CallExpr.Lparen, if the instruction arose
from an explicit conversion in the source.
</p>
<p>
Example printed form:
</p>
<pre>t1 = changetype *int &lt;- IntPtr (t0)
</pre>

			<pre>type ChangeType struct {
<span id="ChangeType.X"></span>    X <a href="index.html#Value">Value</a>
    <span class="comment">// contains filtered or unexported fields</span>
}
</pre>

			

			

			
			
			

			

			
				
				<h3 id="ChangeType.Name">func (*ChangeType) <a href="http://localhost:6060/src/golang.org/x/tools/go/ssa/ssa.go?s=49432:49464#L1442">Name</a>
					<a class="permalink" href="index.html#ChangeType.Name">&#xb6;</a>
					
					
				</h3>
				<pre>func (v *<a href="index.html#ChangeType">ChangeType</a>) Name() <a href="http://localhost:6060/pkg/builtin/#string">string</a></pre>
				
				
				
				
			
				
				<h3 id="ChangeType.Operands">func (*ChangeType) <a href="http://localhost:6060/src/golang.org/x/tools/go/ssa/ssa.go?s=53468:53522#L1550">Operands</a>
					<a class="permalink" href="index.html#ChangeType.Operands">&#xb6;</a>
					
					
				</h3>
				<pre>func (v *<a href="index.html#ChangeType">ChangeType</a>) Operands(rands []*<a href="index.html#Value">Value</a>) []*<a href="index.html#Value">Value</a></pre>
				
				
				
				
			
				
				<h3 id="ChangeType.Pos">func (*ChangeType) <a href="http://localhost:6060/src/golang.org/x/tools/go/ssa/ssa.go?s=49647:49681#L1445">Pos</a>
					<a class="permalink" href="index.html#ChangeType.Pos">&#xb6;</a>
					
					
				</h3>
				<pre>func (v *<a href="index.html#ChangeType">ChangeType</a>) Pos() <a href="http://localhost:6060/pkg/go/token/">token</a>.<a href="http://localhost:6060/pkg/go/token/#Pos">Pos</a></pre>
				
				
				
				
			
				
				<h3 id="ChangeType.Referrers">func (*ChangeType) <a href="http://localhost:6060/src/golang.org/x/tools/go/ssa/ssa.go?s=49577:49622#L1444">Referrers</a>
					<a class="permalink" href="index.html#ChangeType.Referrers">&#xb6;</a>
					
					
				</h3>
				<pre>func (v *<a href="index.html#ChangeType">ChangeType</a>) Referrers() *[]<a href="index.html#Instruction">Instruction</a></pre>
				
				
				
				
			
				
				<h3 id="ChangeType.String">func (*ChangeType) <a href="http://localhost:6060/src/golang.org/x/tools/go/ssa/print.go?s=3705:3741#L152">String</a>
					<a class="permalink" href="index.html#ChangeType.String">&#xb6;</a>
					
					
				</h3>
				<pre>func (v *<a href="index.html#ChangeType">ChangeType</a>) String() <a href="http://localhost:6060/pkg/builtin/#string">string</a></pre>
				
				
				
				
			
				
				<h3 id="ChangeType.Type">func (*ChangeType) <a href="http://localhost:6060/src/golang.org/x/tools/go/ssa/ssa.go?s=49307:49343#L1440">Type</a>
					<a class="permalink" href="index.html#ChangeType.Type">&#xb6;</a>
					
					
				</h3>
				<pre>func (v *<a href="index.html#ChangeType">ChangeType</a>) Type() <a href="http://localhost:6060/pkg/go/types/">types</a>.<a href="http://localhost:6060/pkg/go/types/#Type">Type</a></pre>
				
				
				
				
			
		
			
			
			<h2 id="Const">type <a href="http://localhost:6060/src/golang.org/x/tools/go/ssa/ssa.go?s=16480:16541#L407">Const</a>
				<a class="permalink" href="index.html#Const">&#xb6;</a>
				
				
			</h2>
			<p>
A Const represents the value of a constant expression.
</p>
<p>
The underlying type of a constant may be any boolean, numeric, or
string type.  In addition, a Const may represent the nil value of
any reference type---interface, map, channel, pointer, slice, or
function---but not &#34;untyped nil&#34;.
</p>
<p>
All source-level constant expressions are represented by a Const
of the same type and value.
</p>
<p>
Value holds the value of the constant, independent of its Type(),
using go/constant representation, or nil for a typed nil value.
</p>
<p>
Pos() returns token.NoPos.
</p>
<p>
Example printed form:
</p>
<pre>42:int
&#34;hello&#34;:untyped string
3+4i:MyComplex
</pre>

			<pre>type Const struct {
<span id="Const.Value"></span>    Value <a href="http://localhost:6060/pkg/go/constant/">constant</a>.<a href="http://localhost:6060/pkg/go/constant/#Value">Value</a>
    <span class="comment">// contains filtered or unexported fields</span>
}
</pre>

			

			

			
			
			

			
				
				<h3 id="NewConst">func <a href="http://localhost:6060/src/golang.org/x/tools/go/ssa/const.go?s=429:485#L10">NewConst</a>
					<a class="permalink" href="index.html#NewConst">&#xb6;</a>
					
					
				</h3>
				<pre>func NewConst(val <a href="http://localhost:6060/pkg/go/constant/">constant</a>.<a href="http://localhost:6060/pkg/go/constant/#Value">Value</a>, typ <a href="http://localhost:6060/pkg/go/types/">types</a>.<a href="http://localhost:6060/pkg/go/types/#Type">Type</a>) *<a href="index.html#Const">Const</a></pre>
				<p>
NewConst returns a new constant of the specified value and type.
val must be valid according to the specification of Const.Value.
</p>

				
				
			

			
				
				<h3 id="Const.Complex128">func (*Const) <a href="http://localhost:6060/src/golang.org/x/tools/go/ssa/const.go?s=4214:4253#L155">Complex128</a>
					<a class="permalink" href="index.html#Const.Complex128">&#xb6;</a>
					
					
				</h3>
				<pre>func (c *<a href="index.html#Const">Const</a>) Complex128() <a href="http://localhost:6060/pkg/builtin/#complex128">complex128</a></pre>
				<p>
Complex128 returns the complex value of this constant truncated to
fit a complex128.
</p>

				
				
				
			
				
				<h3 id="Const.Float64">func (*Const) <a href="http://localhost:6060/src/golang.org/x/tools/go/ssa/const.go?s=4033:4066#L147">Float64</a>
					<a class="permalink" href="index.html#Const.Float64">&#xb6;</a>
					
					
				</h3>
				<pre>func (c *<a href="index.html#Const">Const</a>) Float64() <a href="http://localhost:6060/pkg/builtin/#float64">float64</a></pre>
				<p>
Float64 returns the numeric value of this constant truncated to fit
a float64.
</p>

				
				
				
			
				
				<h3 id="Const.Int64">func (*Const) <a href="http://localhost:6060/src/golang.org/x/tools/go/ssa/const.go?s=3217:3246#L113">Int64</a>
					<a class="permalink" href="index.html#Const.Int64">&#xb6;</a>
					
					
				</h3>
				<pre>func (c *<a href="index.html#Const">Const</a>) Int64() <a href="http://localhost:6060/pkg/builtin/#int64">int64</a></pre>
				<p>
Int64 returns the numeric value of this constant truncated to fit
a signed 64-bit integer.
</p>

				
				
				
			
				
				<h3 id="Const.IsNil">func (*Const) <a href="http://localhost:6060/src/golang.org/x/tools/go/ssa/const.go?s=2979:3007#L104">IsNil</a>
					<a class="permalink" href="index.html#Const.IsNil">&#xb6;</a>
					
					
				</h3>
				<pre>func (c *<a href="index.html#Const">Const</a>) IsNil() <a href="http://localhost:6060/pkg/builtin/#bool">bool</a></pre>
				<p>
IsNil returns true if this constant represents a typed or untyped nil value.
</p>

				
				
				
			
				
				<h3 id="Const.Name">func (*Const) <a href="http://localhost:6060/src/golang.org/x/tools/go/ssa/const.go?s=2564:2593#L81">Name</a>
					<a class="permalink" href="index.html#Const.Name">&#xb6;</a>
					
					
				</h3>
				<pre>func (c *<a href="index.html#Const">Const</a>) Name() <a href="http://localhost:6060/pkg/builtin/#string">string</a></pre>
				
				
				
				
			
				
				<h3 id="Const.Operands">func (*Const) <a href="http://localhost:6060/src/golang.org/x/tools/go/ssa/ssa.go?s=56460:56509#L1682">Operands</a>
					<a class="permalink" href="index.html#Const.Operands">&#xb6;</a>
					
					
				</h3>
				<pre>func (v *<a href="index.html#Const">Const</a>) Operands(rands []*<a href="index.html#Value">Value</a>) []*<a href="index.html#Value">Value</a></pre>
				
				
				
				
			
				
				<h3 id="Const.Parent">func (*Const) <a href="http://localhost:6060/src/golang.org/x/tools/go/ssa/const.go?s=2791:2825#L97">Parent</a>
					<a class="permalink" href="index.html#Const.Parent">&#xb6;</a>
					
					
				</h3>
				<pre>func (c *<a href="index.html#Const">Const</a>) Parent() *<a href="index.html#Function">Function</a></pre>
				
				
				
				
			
				
				<h3 id="Const.Pos">func (*Const) <a href="http://localhost:6060/src/golang.org/x/tools/go/ssa/const.go?s=2842:2873#L99">Pos</a>
					<a class="permalink" href="index.html#Const.Pos">&#xb6;</a>
					
					
				</h3>
				<pre>func (c *<a href="index.html#Const">Const</a>) Pos() <a href="http://localhost:6060/pkg/go/token/">token</a>.<a href="http://localhost:6060/pkg/go/token/#Pos">Pos</a></pre>
				
				
				
				
			
				
				<h3 id="Const.Referrers">func (*Const) <a href="http://localhost:6060/src/golang.org/x/tools/go/ssa/const.go?s=2731:2773#L93">Referrers</a>
					<a class="permalink" href="index.html#Const.Referrers">&#xb6;</a>
					
					
				</h3>
				<pre>func (c *<a href="index.html#Const">Const</a>) Referrers() *[]<a href="index.html#Instruction">Instruction</a></pre>
				
				
				
				
			
				
				<h3 id="Const.RelString">func (*Const) <a href="http://localhost:6060/src/golang.org/x/tools/go/ssa/const.go?s=2149:2202#L63">RelString</a>
					<a class="permalink" href="index.html#Const.RelString">&#xb6;</a>
					
					
				</h3>
				<pre>func (c *<a href="index.html#Const">Const</a>) RelString(from *<a href="http://localhost:6060/pkg/go/types/">types</a>.<a href="http://localhost:6060/pkg/go/types/#Package">Package</a>) <a href="http://localhost:6060/pkg/builtin/#string">string</a></pre>
				
				
				
				
			
				
				<h3 id="Const.String">func (*Const) <a href="http://localhost:6060/src/golang.org/x/tools/go/ssa/const.go?s=2624:2655#L85">String</a>
					<a class="permalink" href="index.html#Const.String">&#xb6;</a>
					
					
				</h3>
				<pre>func (c *<a href="index.html#Const">Const</a>) String() <a href="http://localhost:6060/pkg/builtin/#string">string</a></pre>
				
				
				
				
			
				
				<h3 id="Const.Type">func (*Const) <a href="http://localhost:6060/src/golang.org/x/tools/go/ssa/const.go?s=2678:2711#L89">Type</a>
					<a class="permalink" href="index.html#Const.Type">&#xb6;</a>
					
					
				</h3>
				<pre>func (c *<a href="index.html#Const">Const</a>) Type() <a href="http://localhost:6060/pkg/go/types/">types</a>.<a href="http://localhost:6060/pkg/go/types/#Type">Type</a></pre>
				
				
				
				
			
				
				<h3 id="Const.Uint64">func (*Const) <a href="http://localhost:6060/src/golang.org/x/tools/go/ssa/const.go?s=3631:3662#L130">Uint64</a>
					<a class="permalink" href="index.html#Const.Uint64">&#xb6;</a>
					
					
				</h3>
				<pre>func (c *<a href="index.html#Const">Const</a>) Uint64() <a href="http://localhost:6060/pkg/builtin/#uint64">uint64</a></pre>
				<p>
Uint64 returns the numeric value of this constant truncated to fit
an unsigned 64-bit integer.
</p>

				
				
				
			
		
			
			
			<h2 id="Convert">type <a href="http://localhost:6060/src/golang.org/x/tools/go/ssa/ssa.go?s=23102:23144#L621">Convert</a>
				<a class="permalink" href="index.html#Convert">&#xb6;</a>
				
				
			</h2>
			<p>
The Convert instruction yields the conversion of value X to type
Type().  One or both of those types is basic (but possibly named).
</p>
<p>
A conversion may change the value and representation of its operand.
Conversions are permitted:
</p>
<pre>- between real numeric types.
- between complex numeric types.
- between string and []byte or []rune.
- between pointers and unsafe.Pointer.
- between unsafe.Pointer and uintptr.
- from (Unicode) integer to (UTF-8) string.
</pre>
<p>
A conversion may imply a type name change also.
</p>
<p>
This operation cannot fail dynamically.
</p>
<p>
Conversions of untyped string/number/bool constants to a specific
representation are eliminated during SSA construction.
</p>
<p>
Pos() returns the ast.CallExpr.Lparen, if the instruction arose
from an explicit conversion in the source.
</p>
<p>
Example printed form:
</p>
<pre>t1 = convert []byte &lt;- string (t0)
</pre>

			<pre>type Convert struct {
<span id="Convert.X"></span>    X <a href="index.html#Value">Value</a>
    <span class="comment">// contains filtered or unexported fields</span>
}
</pre>

			

			

			
			
			

			

			
				
				<h3 id="Convert.Name">func (*Convert) <a href="http://localhost:6060/src/golang.org/x/tools/go/ssa/ssa.go?s=49432:49464#L1442">Name</a>
					<a class="permalink" href="index.html#Convert.Name">&#xb6;</a>
					
					
				</h3>
				<pre>func (v *<a href="index.html#Convert">Convert</a>) Name() <a href="http://localhost:6060/pkg/builtin/#string">string</a></pre>
				
				
				
				
			
				
				<h3 id="Convert.Operands">func (*Convert) <a href="http://localhost:6060/src/golang.org/x/tools/go/ssa/ssa.go?s=53556:53607#L1554">Operands</a>
					<a class="permalink" href="index.html#Convert.Operands">&#xb6;</a>
					
					
				</h3>
				<pre>func (v *<a href="index.html#Convert">Convert</a>) Operands(rands []*<a href="index.html#Value">Value</a>) []*<a href="index.html#Value">Value</a></pre>
				
				
				
				
			
				
				<h3 id="Convert.Pos">func (*Convert) <a href="http://localhost:6060/src/golang.org/x/tools/go/ssa/ssa.go?s=49647:49681#L1445">Pos</a>
					<a class="permalink" href="index.html#Convert.Pos">&#xb6;</a>
					
					
				</h3>
				<pre>func (v *<a href="index.html#Convert">Convert</a>) Pos() <a href="http://localhost:6060/pkg/go/token/">token</a>.<a href="http://localhost:6060/pkg/go/token/#Pos">Pos</a></pre>
				
				
				
				
			
				
				<h3 id="Convert.Referrers">func (*Convert) <a href="http://localhost:6060/src/golang.org/x/tools/go/ssa/ssa.go?s=49577:49622#L1444">Referrers</a>
					<a class="permalink" href="index.html#Convert.Referrers">&#xb6;</a>
					
					
				</h3>
				<pre>func (v *<a href="index.html#Convert">Convert</a>) Referrers() *[]<a href="index.html#Instruction">Instruction</a></pre>
				
				
				
				
			
				
				<h3 id="Convert.String">func (*Convert) <a href="http://localhost:6060/src/golang.org/x/tools/go/ssa/print.go?s=3790:3823#L153">String</a>
					<a class="permalink" href="index.html#Convert.String">&#xb6;</a>
					
					
				</h3>
				<pre>func (v *<a href="index.html#Convert">Convert</a>) String() <a href="http://localhost:6060/pkg/builtin/#string">string</a></pre>
				
				
				
				
			
				
				<h3 id="Convert.Type">func (*Convert) <a href="http://localhost:6060/src/golang.org/x/tools/go/ssa/ssa.go?s=49307:49343#L1440">Type</a>
					<a class="permalink" href="index.html#Convert.Type">&#xb6;</a>
					
					
				</h3>
				<pre>func (v *<a href="index.html#Convert">Convert</a>) Type() <a href="http://localhost:6060/pkg/go/types/">types</a>.<a href="http://localhost:6060/pkg/go/types/#Type">Type</a></pre>
				
				
				
				
			
		
			
			
			<h2 id="DebugRef">type <a href="http://localhost:6060/src/golang.org/x/tools/go/ssa/ssa.go?s=40665:40965#L1223">DebugRef</a>
				<a class="permalink" href="index.html#DebugRef">&#xb6;</a>
				
				
			</h2>
			<p>
A DebugRef instruction maps a source-level expression Expr to the
SSA value X that represents the value (!IsAddr) or address (IsAddr)
of that expression.
</p>
<p>
DebugRef is a pseudo-instruction: it has no dynamic effect.
</p>
<p>
Pos() returns Expr.Pos(), the start position of the source-level
expression.  This is not the same as the &#34;designated&#34; token as
documented at Value.Pos(). e.g. CallExpr.Pos() does not return the
position of the (&#34;designated&#34;) Lparen token.
</p>
<p>
If Expr is an *ast.Ident denoting a var or func, Object() returns
the object; though this information can be obtained from the type
checker, including it here greatly facilitates debugging.
For non-Ident expressions, Object() returns nil.
</p>
<p>
DebugRefs are generated only for functions built with debugging
enabled; see Package.SetDebugMode() and the GlobalDebug builder
mode flag.
</p>
<p>
DebugRefs are not emitted for ast.Idents referring to constants or
predeclared identifiers, since they are trivial and numerous.
Nor are they emitted for ast.ParenExprs.
</p>
<p>
(By representing these as instructions, rather than out-of-band,
consistency is maintained during transformation passes by the
ordinary SSA renaming machinery.)
</p>
<p>
Example printed form:
</p>
<pre>; *ast.CallExpr @ 102:9 is t5
; var x float64 @ 109:72 is x
; address of *ast.CompositeLit @ 216:10 is t0
</pre>

			<pre>type DebugRef struct {
<span id="DebugRef.Expr"></span>    Expr <a href="http://localhost:6060/pkg/go/ast/">ast</a>.<a href="http://localhost:6060/pkg/go/ast/#Expr">Expr</a> <span class="comment">// the referring expression (never *ast.ParenExpr)</span>

<span id="DebugRef.IsAddr"></span>    IsAddr <a href="http://localhost:6060/pkg/builtin/#bool">bool</a>  <span class="comment">// Expr is addressable and X is the address it denotes</span>
<span id="DebugRef.X"></span>    X      <a href="index.html#Value">Value</a> <span class="comment">// the value or address of Expr</span>
    <span class="comment">// contains filtered or unexported fields</span>
}
</pre>

			

			

			
			
			

			

			
				
				<h3 id="DebugRef.Block">func (*DebugRef) <a href="http://localhost:6060/src/golang.org/x/tools/go/ssa/ssa.go?s=49851:49894#L1449">Block</a>
					<a class="permalink" href="index.html#DebugRef.Block">&#xb6;</a>
					
					
				</h3>
				<pre>func (v *<a href="index.html#DebugRef">DebugRef</a>) Block() *<a href="index.html#BasicBlock">BasicBlock</a></pre>
				
				
				
				
			
				
				<h3 id="DebugRef.Operands">func (*DebugRef) <a href="http://localhost:6060/src/golang.org/x/tools/go/ssa/ssa.go?s=53641:53693#L1558">Operands</a>
					<a class="permalink" href="index.html#DebugRef.Operands">&#xb6;</a>
					
					
				</h3>
				<pre>func (s *<a href="index.html#DebugRef">DebugRef</a>) Operands(rands []*<a href="index.html#Value">Value</a>) []*<a href="index.html#Value">Value</a></pre>
				
				
				
				
			
				
				<h3 id="DebugRef.Parent">func (*DebugRef) <a href="http://localhost:6060/src/golang.org/x/tools/go/ssa/ssa.go?s=49773:49815#L1448">Parent</a>
					<a class="permalink" href="index.html#DebugRef.Parent">&#xb6;</a>
					
					
				</h3>
				<pre>func (v *<a href="index.html#DebugRef">DebugRef</a>) Parent() *<a href="index.html#Function">Function</a></pre>
				
				
				
				
			
				
				<h3 id="DebugRef.Pos">func (*DebugRef) <a href="http://localhost:6060/src/golang.org/x/tools/go/ssa/ssa.go?s=52717:52751#L1514">Pos</a>
					<a class="permalink" href="index.html#DebugRef.Pos">&#xb6;</a>
					
					
				</h3>
				<pre>func (s *<a href="index.html#DebugRef">DebugRef</a>) Pos() <a href="http://localhost:6060/pkg/go/token/">token</a>.<a href="http://localhost:6060/pkg/go/token/#Pos">Pos</a></pre>
				
				
				
				
			
				
				<h3 id="DebugRef.Referrers">func (*DebugRef) <a href="http://localhost:6060/src/golang.org/x/tools/go/ssa/ssa.go?s=49994:50044#L1451">Referrers</a>
					<a class="permalink" href="index.html#DebugRef.Referrers">&#xb6;</a>
					
					
				</h3>
				<pre>func (v *<a href="index.html#DebugRef">DebugRef</a>) Referrers() *[]<a href="index.html#Instruction">Instruction</a></pre>
				
				
				
				
			
				
				<h3 id="DebugRef.String">func (*DebugRef) <a href="http://localhost:6060/src/golang.org/x/tools/go/ssa/print.go?s=8441:8475#L347">String</a>
					<a class="permalink" href="index.html#DebugRef.String">&#xb6;</a>
					
					
				</h3>
				<pre>func (s *<a href="index.html#DebugRef">DebugRef</a>) String() <a href="http://localhost:6060/pkg/builtin/#string">string</a></pre>
				
				
				
				
			
		
			
			
			<h2 id="Defer">type <a href="http://localhost:6060/src/golang.org/x/tools/go/ssa/ssa.go?s=38162:38231#L1136">Defer</a>
				<a class="permalink" href="index.html#Defer">&#xb6;</a>
				
				
			</h2>
			<p>
The Defer instruction pushes the specified call onto a stack of
functions to be called by a RunDefers instruction or by a panic.
</p>
<p>
See CallCommon for generic function call documentation.
</p>
<p>
Pos() returns the ast.DeferStmt.Defer.
</p>
<p>
Example printed form:
</p>
<pre>defer println(t0, t1)
defer t3()
defer invoke t5.Println(...t6)
</pre>

			<pre>type Defer struct {
<span id="Defer.Call"></span>    Call <a href="index.html#CallCommon">CallCommon</a>
    <span class="comment">// contains filtered or unexported fields</span>
}
</pre>

			

			

			
			
			

			

			
				
				<h3 id="Defer.Block">func (*Defer) <a href="http://localhost:6060/src/golang.org/x/tools/go/ssa/ssa.go?s=49851:49894#L1449">Block</a>
					<a class="permalink" href="index.html#Defer.Block">&#xb6;</a>
					
					
				</h3>
				<pre>func (v *<a href="index.html#Defer">Defer</a>) Block() *<a href="index.html#BasicBlock">BasicBlock</a></pre>
				
				
				
				
			
				
				<h3 id="Defer.Common">func (*Defer) <a href="http://localhost:6060/src/golang.org/x/tools/go/ssa/ssa.go?s=46411:46447#L1383">Common</a>
					<a class="permalink" href="index.html#Defer.Common">&#xb6;</a>
					
					
				</h3>
				<pre>func (s *<a href="index.html#Defer">Defer</a>) Common() *<a href="index.html#CallCommon">CallCommon</a></pre>
				
				
				
				
			
				
				<h3 id="Defer.Operands">func (*Defer) <a href="http://localhost:6060/src/golang.org/x/tools/go/ssa/ssa.go?s=53289:53338#L1542">Operands</a>
					<a class="permalink" href="index.html#Defer.Operands">&#xb6;</a>
					
					
				</h3>
				<pre>func (s *<a href="index.html#Defer">Defer</a>) Operands(rands []*<a href="index.html#Value">Value</a>) []*<a href="index.html#Value">Value</a></pre>
				
				
				
				
			
				
				<h3 id="Defer.Parent">func (*Defer) <a href="http://localhost:6060/src/golang.org/x/tools/go/ssa/ssa.go?s=49773:49815#L1448">Parent</a>
					<a class="permalink" href="index.html#Defer.Parent">&#xb6;</a>
					
					
				</h3>
				<pre>func (v *<a href="index.html#Defer">Defer</a>) Parent() *<a href="index.html#Function">Function</a></pre>
				
				
				
				
			
				
				<h3 id="Defer.Pos">func (*Defer) <a href="http://localhost:6060/src/golang.org/x/tools/go/ssa/ssa.go?s=52169:52200#L1504">Pos</a>
					<a class="permalink" href="index.html#Defer.Pos">&#xb6;</a>
					
					
				</h3>
				<pre>func (s *<a href="index.html#Defer">Defer</a>) Pos() <a href="http://localhost:6060/pkg/go/token/">token</a>.<a href="http://localhost:6060/pkg/go/token/#Pos">Pos</a></pre>
				
				
				
				
			
				
				<h3 id="Defer.Referrers">func (*Defer) <a href="http://localhost:6060/src/golang.org/x/tools/go/ssa/ssa.go?s=49994:50044#L1451">Referrers</a>
					<a class="permalink" href="index.html#Defer.Referrers">&#xb6;</a>
					
					
				</h3>
				<pre>func (v *<a href="index.html#Defer">Defer</a>) Referrers() *[]<a href="index.html#Instruction">Instruction</a></pre>
				
				
				
				
			
				
				<h3 id="Defer.String">func (*Defer) <a href="http://localhost:6060/src/golang.org/x/tools/go/ssa/print.go?s=7673:7704#L313">String</a>
					<a class="permalink" href="index.html#Defer.String">&#xb6;</a>
					
					
				</h3>
				<pre>func (s *<a href="index.html#Defer">Defer</a>) String() <a href="http://localhost:6060/pkg/builtin/#string">string</a></pre>
				
				
				
				
			
				
				<h3 id="Defer.Value">func (*Defer) <a href="http://localhost:6060/src/golang.org/x/tools/go/ssa/ssa.go?s=46567:46596#L1387">Value</a>
					<a class="permalink" href="index.html#Defer.Value">&#xb6;</a>
					
					
				</h3>
				<pre>func (s *<a href="index.html#Defer">Defer</a>) Value() *<a href="index.html#Call">Call</a></pre>
				
				
				
				
			
		
			
			
			<h2 id="Extract">type <a href="http://localhost:6060/src/golang.org/x/tools/go/ssa/ssa.go?s=34857:34914#L1003">Extract</a>
				<a class="permalink" href="index.html#Extract">&#xb6;</a>
				
				
			</h2>
			<p>
The Extract instruction yields component Index of Tuple.
</p>
<p>
This is used to access the results of instructions with multiple
return values, such as Call, TypeAssert, Next, UnOp(ARROW) and
IndexExpr(Map).
</p>
<p>
Example printed form:
</p>
<pre>t1 = extract t0 #1
</pre>

			<pre>type Extract struct {
<span id="Extract.Tuple"></span>    Tuple <a href="index.html#Value">Value</a>
<span id="Extract.Index"></span>    Index <a href="http://localhost:6060/pkg/builtin/#int">int</a>
    <span class="comment">// contains filtered or unexported fields</span>
}
</pre>

			

			

			
			
			

			

			
				
				<h3 id="Extract.Name">func (*Extract) <a href="http://localhost:6060/src/golang.org/x/tools/go/ssa/ssa.go?s=49432:49464#L1442">Name</a>
					<a class="permalink" href="index.html#Extract.Name">&#xb6;</a>
					
					
				</h3>
				<pre>func (v *<a href="index.html#Extract">Extract</a>) Name() <a href="http://localhost:6060/pkg/builtin/#string">string</a></pre>
				
				
				
				
			
				
				<h3 id="Extract.Operands">func (*Extract) <a href="http://localhost:6060/src/golang.org/x/tools/go/ssa/ssa.go?s=53727:53778#L1562">Operands</a>
					<a class="permalink" href="index.html#Extract.Operands">&#xb6;</a>
					
					
				</h3>
				<pre>func (v *<a href="index.html#Extract">Extract</a>) Operands(rands []*<a href="index.html#Value">Value</a>) []*<a href="index.html#Value">Value</a></pre>
				
				
				
				
			
				
				<h3 id="Extract.Pos">func (*Extract) <a href="http://localhost:6060/src/golang.org/x/tools/go/ssa/ssa.go?s=49647:49681#L1445">Pos</a>
					<a class="permalink" href="index.html#Extract.Pos">&#xb6;</a>
					
					
				</h3>
				<pre>func (v *<a href="index.html#Extract">Extract</a>) Pos() <a href="http://localhost:6060/pkg/go/token/">token</a>.<a href="http://localhost:6060/pkg/go/token/#Pos">Pos</a></pre>
				
				
				
				
			
				
				<h3 id="Extract.Referrers">func (*Extract) <a href="http://localhost:6060/src/golang.org/x/tools/go/ssa/ssa.go?s=49577:49622#L1444">Referrers</a>
					<a class="permalink" href="index.html#Extract.Referrers">&#xb6;</a>
					
					
				</h3>
				<pre>func (v *<a href="index.html#Extract">Extract</a>) Referrers() *[]<a href="index.html#Instruction">Instruction</a></pre>
				
				
				
				
			
				
				<h3 id="Extract.String">func (*Extract) <a href="http://localhost:6060/src/golang.org/x/tools/go/ssa/print.go?s=6508:6541#L260">String</a>
					<a class="permalink" href="index.html#Extract.String">&#xb6;</a>
					
					
				</h3>
				<pre>func (v *<a href="index.html#Extract">Extract</a>) String() <a href="http://localhost:6060/pkg/builtin/#string">string</a></pre>
				
				
				
				
			
				
				<h3 id="Extract.Type">func (*Extract) <a href="http://localhost:6060/src/golang.org/x/tools/go/ssa/ssa.go?s=49307:49343#L1440">Type</a>
					<a class="permalink" href="index.html#Extract.Type">&#xb6;</a>
					
					
				</h3>
				<pre>func (v *<a href="index.html#Extract">Extract</a>) Type() <a href="http://localhost:6060/pkg/go/types/">types</a>.<a href="http://localhost:6060/pkg/go/types/#Type">Type</a></pre>
				
				
				
				
			
		
			
			
			<h2 id="Field">type <a href="http://localhost:6060/src/golang.org/x/tools/go/ssa/ssa.go?s=28112:28225#L795">Field</a>
				<a class="permalink" href="index.html#Field">&#xb6;</a>
				
				
			</h2>
			<p>
The Field instruction yields the Field of struct X.
</p>
<p>
The field is identified by its index within the field list of the
struct type of X; by using numeric indices we avoid ambiguity of
package-local identifiers and permit compact representations.
</p>
<p>
Pos() returns the position of the ast.SelectorExpr.Sel for the
field, if explicit in the source.
</p>
<p>
Example printed form:
</p>
<pre>t1 = t0.name [#1]
</pre>

			<pre>type Field struct {
<span id="Field.X"></span>    X     <a href="index.html#Value">Value</a> <span class="comment">// struct</span>
<span id="Field.Field"></span>    Field <a href="http://localhost:6060/pkg/builtin/#int">int</a>   <span class="comment">// index into X.Type().(*types.Struct).Fields</span>
    <span class="comment">// contains filtered or unexported fields</span>
}
</pre>

			

			

			
			
			

			

			
				
				<h3 id="Field.Name">func (*Field) <a href="http://localhost:6060/src/golang.org/x/tools/go/ssa/ssa.go?s=49432:49464#L1442">Name</a>
					<a class="permalink" href="index.html#Field.Name">&#xb6;</a>
					
					
				</h3>
				<pre>func (v *<a href="index.html#Field">Field</a>) Name() <a href="http://localhost:6060/pkg/builtin/#string">string</a></pre>
				
				
				
				
			
				
				<h3 id="Field.Operands">func (*Field) <a href="http://localhost:6060/src/golang.org/x/tools/go/ssa/ssa.go?s=53816:53865#L1566">Operands</a>
					<a class="permalink" href="index.html#Field.Operands">&#xb6;</a>
					
					
				</h3>
				<pre>func (v *<a href="index.html#Field">Field</a>) Operands(rands []*<a href="index.html#Value">Value</a>) []*<a href="index.html#Value">Value</a></pre>
				
				
				
				
			
				
				<h3 id="Field.Pos">func (*Field) <a href="http://localhost:6060/src/golang.org/x/tools/go/ssa/ssa.go?s=49647:49681#L1445">Pos</a>
					<a class="permalink" href="index.html#Field.Pos">&#xb6;</a>
					
					
				</h3>
				<pre>func (v *<a href="index.html#Field">Field</a>) Pos() <a href="http://localhost:6060/pkg/go/token/">token</a>.<a href="http://localhost:6060/pkg/go/token/#Pos">Pos</a></pre>
				
				
				
				
			
				
				<h3 id="Field.Referrers">func (*Field) <a href="http://localhost:6060/src/golang.org/x/tools/go/ssa/ssa.go?s=49577:49622#L1444">Referrers</a>
					<a class="permalink" href="index.html#Field.Referrers">&#xb6;</a>
					
					
				</h3>
				<pre>func (v *<a href="index.html#Field">Field</a>) Referrers() *[]<a href="index.html#Instruction">Instruction</a></pre>
				
				
				
				
			
				
				<h3 id="Field.String">func (*Field) <a href="http://localhost:6060/src/golang.org/x/tools/go/ssa/print.go?s=5557:5588#L225">String</a>
					<a class="permalink" href="index.html#Field.String">&#xb6;</a>
					
					
				</h3>
				<pre>func (v *<a href="index.html#Field">Field</a>) String() <a href="http://localhost:6060/pkg/builtin/#string">string</a></pre>
				
				
				
				
			
				
				<h3 id="Field.Type">func (*Field) <a href="http://localhost:6060/src/golang.org/x/tools/go/ssa/ssa.go?s=49307:49343#L1440">Type</a>
					<a class="permalink" href="index.html#Field.Type">&#xb6;</a>
					
					
				</h3>
				<pre>func (v *<a href="index.html#Field">Field</a>) Type() <a href="http://localhost:6060/pkg/go/types/">types</a>.<a href="http://localhost:6060/pkg/go/types/#Type">Type</a></pre>
				
				
				
				
			
		
			
			
			<h2 id="FieldAddr">type <a href="http://localhost:6060/src/golang.org/x/tools/go/ssa/ssa.go?s=27519:27691#L777">FieldAddr</a>
				<a class="permalink" href="index.html#FieldAddr">&#xb6;</a>
				
				
			</h2>
			<p>
The FieldAddr instruction yields the address of Field of *struct X.
</p>
<p>
The field is identified by its index within the field list of the
struct type of X.
</p>
<p>
Dynamically, this instruction panics if X evaluates to a nil
pointer.
</p>
<p>
Type() returns a (possibly named) *types.Pointer.
</p>
<p>
Pos() returns the position of the ast.SelectorExpr.Sel for the
field, if explicit in the source.
</p>
<p>
Example printed form:
</p>
<pre>t1 = &amp;t0.name [#1]
</pre>

			<pre>type FieldAddr struct {
<span id="FieldAddr.X"></span>    X     <a href="index.html#Value">Value</a> <span class="comment">// *struct</span>
<span id="FieldAddr.Field"></span>    Field <a href="http://localhost:6060/pkg/builtin/#int">int</a>   <span class="comment">// field is X.Type().Underlying().(*types.Pointer).Elem().Underlying().(*types.Struct).Field(Field)</span>
    <span class="comment">// contains filtered or unexported fields</span>
}
</pre>

			

			

			
			
			

			

			
				
				<h3 id="FieldAddr.Name">func (*FieldAddr) <a href="http://localhost:6060/src/golang.org/x/tools/go/ssa/ssa.go?s=49432:49464#L1442">Name</a>
					<a class="permalink" href="index.html#FieldAddr.Name">&#xb6;</a>
					
					
				</h3>
				<pre>func (v *<a href="index.html#FieldAddr">FieldAddr</a>) Name() <a href="http://localhost:6060/pkg/builtin/#string">string</a></pre>
				
				
				
				
			
				
				<h3 id="FieldAddr.Operands">func (*FieldAddr) <a href="http://localhost:6060/src/golang.org/x/tools/go/ssa/ssa.go?s=53899:53952#L1570">Operands</a>
					<a class="permalink" href="index.html#FieldAddr.Operands">&#xb6;</a>
					
					
				</h3>
				<pre>func (v *<a href="index.html#FieldAddr">FieldAddr</a>) Operands(rands []*<a href="index.html#Value">Value</a>) []*<a href="index.html#Value">Value</a></pre>
				
				
				
				
			
				
				<h3 id="FieldAddr.Pos">func (*FieldAddr) <a href="http://localhost:6060/src/golang.org/x/tools/go/ssa/ssa.go?s=49647:49681#L1445">Pos</a>
					<a class="permalink" href="index.html#FieldAddr.Pos">&#xb6;</a>
					
					
				</h3>
				<pre>func (v *<a href="index.html#FieldAddr">FieldAddr</a>) Pos() <a href="http://localhost:6060/pkg/go/token/">token</a>.<a href="http://localhost:6060/pkg/go/token/#Pos">Pos</a></pre>
				
				
				
				
			
				
				<h3 id="FieldAddr.Referrers">func (*FieldAddr) <a href="http://localhost:6060/src/golang.org/x/tools/go/ssa/ssa.go?s=49577:49622#L1444">Referrers</a>
					<a class="permalink" href="index.html#FieldAddr.Referrers">&#xb6;</a>
					
					
				</h3>
				<pre>func (v *<a href="index.html#FieldAddr">FieldAddr</a>) Referrers() *[]<a href="index.html#Instruction">Instruction</a></pre>
				
				
				
				
			
				
				<h3 id="FieldAddr.String">func (*FieldAddr) <a href="http://localhost:6060/src/golang.org/x/tools/go/ssa/print.go?s=5262:5297#L215">String</a>
					<a class="permalink" href="index.html#FieldAddr.String">&#xb6;</a>
					
					
				</h3>
				<pre>func (v *<a href="index.html#FieldAddr">FieldAddr</a>) String() <a href="http://localhost:6060/pkg/builtin/#string">string</a></pre>
				
				
				
				
			
				
				<h3 id="FieldAddr.Type">func (*FieldAddr) <a href="http://localhost:6060/src/golang.org/x/tools/go/ssa/ssa.go?s=49307:49343#L1440">Type</a>
					<a class="permalink" href="index.html#FieldAddr.Type">&#xb6;</a>
					
					
				</h3>
				<pre>func (v *<a href="index.html#FieldAddr">FieldAddr</a>) Type() <a href="http://localhost:6060/pkg/go/types/">types</a>.<a href="http://localhost:6060/pkg/go/types/#Type">Type</a></pre>
				
				
				
				
			
		
			
			
			<h2 id="FreeVar">type <a href="http://localhost:6060/src/golang.org/x/tools/go/ssa/ssa.go?s=15316:15550#L365">FreeVar</a>
				<a class="permalink" href="index.html#FreeVar">&#xb6;</a>
				
				
			</h2>
			<p>
A FreeVar represents a free variable of the function to which it
belongs.
</p>
<p>
FreeVars are used to implement anonymous functions, whose free
variables are lexically captured in a closure formed by
MakeClosure.  The value of such a free var is an Alloc or another
FreeVar and is considered a potentially escaping heap address, with
pointer type.
</p>
<p>
FreeVars are also used to implement bound method closures.  Such a
free var represents the receiver value and may be of any type that
has concrete methods.
</p>
<p>
Pos() returns the position of the value that was captured, which
belongs to an enclosing function.
</p>

			<pre>type FreeVar struct {
    <span class="comment">// contains filtered or unexported fields</span>
}
</pre>

			

			

			
			
			

			

			
				
				<h3 id="FreeVar.Name">func (*FreeVar) <a href="http://localhost:6060/src/golang.org/x/tools/go/ssa/ssa.go?s=47108:47139#L1398">Name</a>
					<a class="permalink" href="index.html#FreeVar.Name">&#xb6;</a>
					
					
				</h3>
				<pre>func (v *<a href="index.html#FreeVar">FreeVar</a>) Name() <a href="http://localhost:6060/pkg/builtin/#string">string</a></pre>
				
				
				
				
			
				
				<h3 id="FreeVar.Operands">func (*FreeVar) <a href="http://localhost:6060/src/golang.org/x/tools/go/ssa/ssa.go?s=56389:56440#L1681">Operands</a>
					<a class="permalink" href="index.html#FreeVar.Operands">&#xb6;</a>
					
					
				</h3>
				<pre>func (v *<a href="index.html#FreeVar">FreeVar</a>) Operands(rands []*<a href="index.html#Value">Value</a>) []*<a href="index.html#Value">Value</a></pre>
				
				
				
				
			
				
				<h3 id="FreeVar.Parent">func (*FreeVar) <a href="http://localhost:6060/src/golang.org/x/tools/go/ssa/ssa.go?s=47302:47338#L1401">Parent</a>
					<a class="permalink" href="index.html#FreeVar.Parent">&#xb6;</a>
					
					
				</h3>
				<pre>func (v *<a href="index.html#FreeVar">FreeVar</a>) Parent() *<a href="index.html#Function">Function</a></pre>
				
				
				
				
			
				
				<h3 id="FreeVar.Pos">func (*FreeVar) <a href="http://localhost:6060/src/golang.org/x/tools/go/ssa/ssa.go?s=47240:47273#L1400">Pos</a>
					<a class="permalink" href="index.html#FreeVar.Pos">&#xb6;</a>
					
					
				</h3>
				<pre>func (v *<a href="index.html#FreeVar">FreeVar</a>) Pos() <a href="http://localhost:6060/pkg/go/token/">token</a>.<a href="http://localhost:6060/pkg/go/token/#Pos">Pos</a></pre>
				
				
				
				
			
				
				<h3 id="FreeVar.Referrers">func (*FreeVar) <a href="http://localhost:6060/src/golang.org/x/tools/go/ssa/ssa.go?s=47171:47215#L1399">Referrers</a>
					<a class="permalink" href="index.html#FreeVar.Referrers">&#xb6;</a>
					
					
				</h3>
				<pre>func (v *<a href="index.html#FreeVar">FreeVar</a>) Referrers() *[]<a href="index.html#Instruction">Instruction</a></pre>
				
				
				
				
			
				
				<h3 id="FreeVar.String">func (*FreeVar) <a href="http://localhost:6060/src/golang.org/x/tools/go/ssa/print.go?s=1598:1631#L54">String</a>
					<a class="permalink" href="index.html#FreeVar.String">&#xb6;</a>
					
					
				</h3>
				<pre>func (v *<a href="index.html#FreeVar">FreeVar</a>) String() <a href="http://localhost:6060/pkg/builtin/#string">string</a></pre>
				
				
				
				
			
				
				<h3 id="FreeVar.Type">func (*FreeVar) <a href="http://localhost:6060/src/golang.org/x/tools/go/ssa/ssa.go?s=47046:47081#L1397">Type</a>
					<a class="permalink" href="index.html#FreeVar.Type">&#xb6;</a>
					
					
				</h3>
				<pre>func (v *<a href="index.html#FreeVar">FreeVar</a>) Type() <a href="http://localhost:6060/pkg/go/types/">types</a>.<a href="http://localhost:6060/pkg/go/types/#Type">Type</a></pre>
				
				
				
				
			
		
			
			
			<h2 id="Function">type <a href="http://localhost:6060/src/golang.org/x/tools/go/ssa/ssa.go?s=11678:13266#L286">Function</a>
				<a class="permalink" href="index.html#Function">&#xb6;</a>
				
				
			</h2>
			<p>
Function represents the parameters, results, and code of a function
or method.
</p>
<p>
If Blocks is nil, this indicates an external function for which no
Go source code is available.  In this case, FreeVars and Locals
are nil too.  Clients performing whole-program analysis must
handle external functions specially.
</p>
<p>
Blocks contains the function&#39;s control-flow graph (CFG).
Blocks[0] is the function entry point; block order is not otherwise
semantically significant, though it may affect the readability of
the disassembly.
To iterate over the blocks in dominance order, use DomPreorder().
</p>
<p>
Recover is an optional second entry point to which control resumes
after a recovered panic.  The Recover block may contain only a return
statement, preceded by a load of the function&#39;s named return
parameters, if any.
</p>
<p>
A nested function (Parent()!=nil) that refers to one or more
lexically enclosing local variables (&#34;free variables&#34;) has FreeVars.
Such functions cannot be called directly but require a
value created by MakeClosure which, via its Bindings, supplies
values for these parameters.
</p>
<p>
If the function is a method (Signature.Recv() != nil) then the first
element of Params is the receiver parameter.
</p>
<p>
A Go package may declare many functions called &#34;init&#34;.
For each one, Object().Name() returns &#34;init&#34; but Name() returns
&#34;init#1&#34;, etc, in declaration order.
</p>
<p>
Pos() returns the declaring ast.FuncLit.Type.Func or the position
of the ast.FuncDecl.Name, if the function was explicit in the
source.  Synthetic wrappers, for which Synthetic != &#34;&#34;, may share
the same position as the function they wrap.
Syntax.Pos() always returns the position of the declaring &#34;func&#34; token.
</p>
<p>
Type() returns the function&#39;s Signature.
</p>

			<pre>type Function struct {
<span id="Function.Signature"></span>    Signature *<a href="http://localhost:6060/pkg/go/types/">types</a>.<a href="http://localhost:6060/pkg/go/types/#Signature">Signature</a>

<span id="Function.Synthetic"></span>    Synthetic <a href="http://localhost:6060/pkg/builtin/#string">string</a> <span class="comment">// provenance of synthetic function; &#34;&#34; for true source functions</span>

<span id="Function.Pkg"></span>    Pkg       *<a href="index.html#Package">Package</a>      <span class="comment">// enclosing package; nil for shared funcs (wrappers and error.Error)</span>
<span id="Function.Prog"></span>    Prog      *<a href="index.html#Program">Program</a>      <span class="comment">// enclosing program</span>
<span id="Function.Params"></span>    Params    []*<a href="index.html#Parameter">Parameter</a>  <span class="comment">// function parameters; for methods, includes receiver</span>
<span id="Function.FreeVars"></span>    FreeVars  []*<a href="index.html#FreeVar">FreeVar</a>    <span class="comment">// free variables whose values must be supplied by closure</span>
<span id="Function.Locals"></span>    Locals    []*<a href="index.html#Alloc">Alloc</a>      <span class="comment">// local variables of this function</span>
<span id="Function.Blocks"></span>    Blocks    []*<a href="index.html#BasicBlock">BasicBlock</a> <span class="comment">// basic blocks of the function; nil =&gt; external</span>
<span id="Function.Recover"></span>    Recover   *<a href="index.html#BasicBlock">BasicBlock</a>   <span class="comment">// optional; control transfers here after recovered panic</span>
<span id="Function.AnonFuncs"></span>    AnonFuncs []*<a href="index.html#Function">Function</a>   <span class="comment">// anonymous functions directly beneath this one</span>
    <span class="comment">// contains filtered or unexported fields</span>
}
</pre>

			

			

			
			
			

			
				
				<h3 id="EnclosingFunction">func <a href="http://localhost:6060/src/golang.org/x/tools/go/ssa/source.go?s=921:984#L21">EnclosingFunction</a>
					<a class="permalink" href="index.html#EnclosingFunction">&#xb6;</a>
					
					
				</h3>
				<pre>func EnclosingFunction(pkg *<a href="index.html#Package">Package</a>, path []<a href="http://localhost:6060/pkg/go/ast/">ast</a>.<a href="http://localhost:6060/pkg/go/ast/#Node">Node</a>) *<a href="index.html#Function">Function</a></pre>
				<p>
EnclosingFunction returns the function that contains the syntax
node denoted by path.
</p>
<p>
Syntax associated with package-level variable specifications is
enclosed by the package&#39;s init() function.
</p>
<p>
Returns nil if not found; reasons might include:
</p>
<pre>- the node is not enclosed by any function.
- the node is within an anonymous function (FuncLit) and
  its SSA function has not been created yet
  (pkg.Build() has not yet been called).
</pre>

				
				
			

			
				
				<h3 id="Function.DomPreorder">func (*Function) <a href="http://localhost:6060/src/golang.org/x/tools/go/ssa/dom.go?s=1718:1764#L44">DomPreorder</a>
					<a class="permalink" href="index.html#Function.DomPreorder">&#xb6;</a>
					
					
				</h3>
				<pre>func (f *<a href="index.html#Function">Function</a>) DomPreorder() []*<a href="index.html#BasicBlock">BasicBlock</a></pre>
				<p>
DomPreorder returns a new slice containing the blocks of f in
dominator tree preorder.
</p>

				
				
				
			
				
				<h3 id="Function.Name">func (*Function) <a href="http://localhost:6060/src/golang.org/x/tools/go/ssa/ssa.go?s=48117:48149#L1414">Name</a>
					<a class="permalink" href="index.html#Function.Name">&#xb6;</a>
					
					
				</h3>
				<pre>func (v *<a href="index.html#Function">Function</a>) Name() <a href="http://localhost:6060/pkg/builtin/#string">string</a></pre>
				
				
				
				
			
				
				<h3 id="Function.Object">func (*Function) <a href="http://localhost:6060/src/golang.org/x/tools/go/ssa/ssa.go?s=48361:48401#L1418">Object</a>
					<a class="permalink" href="index.html#Function.Object">&#xb6;</a>
					
					
				</h3>
				<pre>func (v *<a href="index.html#Function">Function</a>) Object() <a href="http://localhost:6060/pkg/go/types/">types</a>.<a href="http://localhost:6060/pkg/go/types/#Object">Object</a></pre>
				
				
				
				
			
				
				<h3 id="Function.Operands">func (*Function) <a href="http://localhost:6060/src/golang.org/x/tools/go/ssa/ssa.go?s=56531:56583#L1683">Operands</a>
					<a class="permalink" href="index.html#Function.Operands">&#xb6;</a>
					
					
				</h3>
				<pre>func (v *<a href="index.html#Function">Function</a>) Operands(rands []*<a href="index.html#Value">Value</a>) []*<a href="index.html#Value">Value</a></pre>
				
				
				
				
			
				
				<h3 id="Function.Package">func (*Function) <a href="http://localhost:6060/src/golang.org/x/tools/go/ssa/ssa.go?s=48491:48528#L1420">Package</a>
					<a class="permalink" href="index.html#Function.Package">&#xb6;</a>
					
					
				</h3>
				<pre>func (v *<a href="index.html#Function">Function</a>) Package() *<a href="index.html#Package">Package</a></pre>
				
				
				
				
			
				
				<h3 id="Function.Parent">func (*Function) <a href="http://localhost:6060/src/golang.org/x/tools/go/ssa/ssa.go?s=48549:48586#L1421">Parent</a>
					<a class="permalink" href="index.html#Function.Parent">&#xb6;</a>
					
					
				</h3>
				<pre>func (v *<a href="index.html#Function">Function</a>) Parent() *<a href="index.html#Function">Function</a></pre>
				
				
				
				
			
				
				<h3 id="Function.Pos">func (*Function) <a href="http://localhost:6060/src/golang.org/x/tools/go/ssa/ssa.go?s=48240:48274#L1416">Pos</a>
					<a class="permalink" href="index.html#Function.Pos">&#xb6;</a>
					
					
				</h3>
				<pre>func (v *<a href="index.html#Function">Function</a>) Pos() <a href="http://localhost:6060/pkg/go/token/">token</a>.<a href="http://localhost:6060/pkg/go/token/#Pos">Pos</a></pre>
				
				
				
				
			
				
				<h3 id="Function.Referrers">func (*Function) <a href="http://localhost:6060/src/golang.org/x/tools/go/ssa/ssa.go?s=48610:48655#L1422">Referrers</a>
					<a class="permalink" href="index.html#Function.Referrers">&#xb6;</a>
					
					
				</h3>
				<pre>func (v *<a href="index.html#Function">Function</a>) Referrers() *[]<a href="index.html#Instruction">Instruction</a></pre>
				
				
				
				
			
				
				<h3 id="Function.RelString">func (*Function) <a href="http://localhost:6060/src/golang.org/x/tools/go/ssa/func.go?s=12583:12639#L463">RelString</a>
					<a class="permalink" href="index.html#Function.RelString">&#xb6;</a>
					
					
				</h3>
				<pre>func (f *<a href="index.html#Function">Function</a>) RelString(from *<a href="http://localhost:6060/pkg/go/types/">types</a>.<a href="http://localhost:6060/pkg/go/types/#Package">Package</a>) <a href="http://localhost:6060/pkg/builtin/#string">string</a></pre>
				<p>
RelString returns the full name of this function, qualified by
package name, receiver type, etc.
</p>
<p>
The specific formatting rules are not guaranteed and may change.
</p>
<p>
Examples:
</p>
<pre>&#34;math.IsNaN&#34;                  // a package-level function
&#34;(*bytes.Buffer).Bytes&#34;       // a declared method or a wrapper
&#34;(*bytes.Buffer).Bytes$thunk&#34; // thunk (func wrapping method; receiver is param 0)
&#34;(*bytes.Buffer).Bytes$bound&#34; // bound (func wrapping method; receiver supplied by closure)
&#34;main.main$1&#34;                 // an anonymous function in main
&#34;main.init#1&#34;                 // a declared init function
&#34;main.init&#34;                   // the synthesized package initializer
</pre>
<p>
When these functions are referred to from within the same package
(i.e. from == f.Pkg.Object), they are rendered without the package path.
For example: &#34;IsNaN&#34;, &#34;(*Buffer).Bytes&#34;, etc.
</p>
<p>
All non-synthetic functions have distinct package-qualified names.
(But two methods may have the same name &#34;(T).f&#34; if one is a synthetic
wrapper promoting a non-exported method &#34;f&#34; from another package; in
that case, the strings are equal but the identifiers &#34;f&#34; are distinct.)
</p>

				
				
				
			
				
				<h3 id="Function.String">func (*Function) <a href="http://localhost:6060/src/golang.org/x/tools/go/ssa/ssa.go?s=48422:48456#L1419">String</a>
					<a class="permalink" href="index.html#Function.String">&#xb6;</a>
					
					
				</h3>
				<pre>func (v *<a href="index.html#Function">Function</a>) String() <a href="http://localhost:6060/pkg/builtin/#string">string</a></pre>
				
				
				
				
			
				
				<h3 id="Function.Syntax">func (*Function) <a href="http://localhost:6060/src/golang.org/x/tools/go/ssa/func.go?s=18927:18963#L681">Syntax</a>
					<a class="permalink" href="index.html#Function.Syntax">&#xb6;</a>
					
					
				</h3>
				<pre>func (f *<a href="index.html#Function">Function</a>) Syntax() <a href="http://localhost:6060/pkg/go/ast/">ast</a>.<a href="http://localhost:6060/pkg/go/ast/#Node">Node</a></pre>
				<p>
Syntax returns an ast.Node whose Pos/End methods provide the
lexical extent of the function if it was defined by Go source code
(f.Synthetic==&#34;&#34;), or nil otherwise.
</p>
<p>
If f was built with debug information (see Package.SetDebugRef),
the result is the *ast.FuncDecl or *ast.FuncLit that declared the
function.  Otherwise, it is an opaque Node providing only position
information; this avoids pinning the AST in memory.
</p>

				
				
				
			
				
				<h3 id="Function.Token">func (*Function) <a href="http://localhost:6060/src/golang.org/x/tools/go/ssa/ssa.go?s=48298:48336#L1417">Token</a>
					<a class="permalink" href="index.html#Function.Token">&#xb6;</a>
					
					
				</h3>
				<pre>func (v *<a href="index.html#Function">Function</a>) Token() <a href="http://localhost:6060/pkg/go/token/">token</a>.<a href="http://localhost:6060/pkg/go/token/#Token">Token</a></pre>
				
				
				
				
			
				
				<h3 id="Function.Type">func (*Function) <a href="http://localhost:6060/src/golang.org/x/tools/go/ssa/ssa.go?s=48176:48212#L1415">Type</a>
					<a class="permalink" href="index.html#Function.Type">&#xb6;</a>
					
					
				</h3>
				<pre>func (v *<a href="index.html#Function">Function</a>) Type() <a href="http://localhost:6060/pkg/go/types/">types</a>.<a href="http://localhost:6060/pkg/go/types/#Type">Type</a></pre>
				
				
				
				
			
				
				<h3 id="Function.ValueForExpr">func (*Function) <a href="http://localhost:6060/src/golang.org/x/tools/go/ssa/source.go?s=4908:4978#L147">ValueForExpr</a>
					<a class="permalink" href="index.html#Function.ValueForExpr">&#xb6;</a>
					
					
				</h3>
				<pre>func (f *<a href="index.html#Function">Function</a>) ValueForExpr(e <a href="http://localhost:6060/pkg/go/ast/">ast</a>.<a href="http://localhost:6060/pkg/go/ast/#Expr">Expr</a>) (value <a href="index.html#Value">Value</a>, isAddr <a href="http://localhost:6060/pkg/builtin/#bool">bool</a>)</pre>
				<p>
ValueForExpr returns the SSA Value that corresponds to non-constant
expression e.
</p>
<p>
It returns nil if no value was found, e.g.
</p>
<pre>- the expression is not lexically contained within f;
- f was not built with debug information; or
- e is a constant expression.  (For efficiency, no debug
  information is stored for constants. Use
  go/types.Info.Types[e].Value instead.)
- e is a reference to nil or a built-in function.
- the value was optimised away.
</pre>
<p>
If e is an addressable expression used in an lvalue context,
value is the address denoted by e, and isAddr is true.
</p>
<p>
The types of e (or &amp;e, if isAddr) and the result are equal
(modulo &#34;untyped&#34; bools resulting from comparisons).
</p>
<p>
(Tip: to find the ssa.Value given a source position, use
astutil.PathEnclosingInterval to locate the ast.Node, then
EnclosingFunction to locate the Function, then ValueForExpr to find
the ssa.Value.)
</p>

				
				
				
			
				
				<h3 id="Function.WriteTo">func (*Function) <a href="http://localhost:6060/src/golang.org/x/tools/go/ssa/func.go?s=14399:14453#L532">WriteTo</a>
					<a class="permalink" href="index.html#Function.WriteTo">&#xb6;</a>
					
					
				</h3>
				<pre>func (f *<a href="index.html#Function">Function</a>) WriteTo(w <a href="http://localhost:6060/pkg/io/">io</a>.<a href="http://localhost:6060/pkg/io/#Writer">Writer</a>) (<a href="http://localhost:6060/pkg/builtin/#int64">int64</a>, <a href="http://localhost:6060/pkg/builtin/#error">error</a>)</pre>
				
				
				
				
			
		
			
			
			<h2 id="Global">type <a href="http://localhost:6060/src/golang.org/x/tools/go/ssa/ssa.go?s=16705:16874#L418">Global</a>
				<a class="permalink" href="index.html#Global">&#xb6;</a>
				
				
			</h2>
			<p>
A Global is a named Value holding the address of a package-level
variable.
</p>
<p>
Pos() returns the position of the ast.ValueSpec.Names[*]
identifier.
</p>

			<pre>type Global struct {
<span id="Global.Pkg"></span>    Pkg *<a href="index.html#Package">Package</a>
    <span class="comment">// contains filtered or unexported fields</span>
}
</pre>

			

			

			
			
			

			

			
				
				<h3 id="Global.Name">func (*Global) <a href="http://localhost:6060/src/golang.org/x/tools/go/ssa/ssa.go?s=47440:47470#L1404">Name</a>
					<a class="permalink" href="index.html#Global.Name">&#xb6;</a>
					
					
				</h3>
				<pre>func (v *<a href="index.html#Global">Global</a>) Name() <a href="http://localhost:6060/pkg/builtin/#string">string</a></pre>
				
				
				
				
			
				
				<h3 id="Global.Object">func (*Global) <a href="http://localhost:6060/src/golang.org/x/tools/go/ssa/ssa.go?s=47801:47839#L1409">Object</a>
					<a class="permalink" href="index.html#Global.Object">&#xb6;</a>
					
					
				</h3>
				<pre>func (v *<a href="index.html#Global">Global</a>) Object() <a href="http://localhost:6060/pkg/go/types/">types</a>.<a href="http://localhost:6060/pkg/go/types/#Object">Object</a></pre>
				
				
				
				
			
				
				<h3 id="Global.Operands">func (*Global) <a href="http://localhost:6060/src/golang.org/x/tools/go/ssa/ssa.go?s=56602:56652#L1684">Operands</a>
					<a class="permalink" href="index.html#Global.Operands">&#xb6;</a>
					
					
				</h3>
				<pre>func (v *<a href="index.html#Global">Global</a>) Operands(rands []*<a href="index.html#Value">Value</a>) []*<a href="index.html#Value">Value</a></pre>
				
				
				
				
			
				
				<h3 id="Global.Package">func (*Global) <a href="http://localhost:6060/src/golang.org/x/tools/go/ssa/ssa.go?s=47959:47994#L1411">Package</a>
					<a class="permalink" href="index.html#Global.Package">&#xb6;</a>
					
					
				</h3>
				<pre>func (v *<a href="index.html#Global">Global</a>) Package() *<a href="index.html#Package">Package</a></pre>
				
				
				
				
			
				
				<h3 id="Global.Parent">func (*Global) <a href="http://localhost:6060/src/golang.org/x/tools/go/ssa/ssa.go?s=47513:47548#L1405">Parent</a>
					<a class="permalink" href="index.html#Global.Parent">&#xb6;</a>
					
					
				</h3>
				<pre>func (v *<a href="index.html#Global">Global</a>) Parent() *<a href="index.html#Function">Function</a></pre>
				
				
				
				
			
				
				<h3 id="Global.Pos">func (*Global) <a href="http://localhost:6060/src/golang.org/x/tools/go/ssa/ssa.go?s=47583:47615#L1406">Pos</a>
					<a class="permalink" href="index.html#Global.Pos">&#xb6;</a>
					
					
				</h3>
				<pre>func (v *<a href="index.html#Global">Global</a>) Pos() <a href="http://localhost:6060/pkg/go/token/">token</a>.<a href="http://localhost:6060/pkg/go/token/#Pos">Pos</a></pre>
				
				
				
				
			
				
				<h3 id="Global.Referrers">func (*Global) <a href="http://localhost:6060/src/golang.org/x/tools/go/ssa/ssa.go?s=47655:47698#L1407">Referrers</a>
					<a class="permalink" href="index.html#Global.Referrers">&#xb6;</a>
					
					
				</h3>
				<pre>func (v *<a href="index.html#Global">Global</a>) Referrers() *[]<a href="index.html#Instruction">Instruction</a></pre>
				
				
				
				
			
				
				<h3 id="Global.RelString">func (*Global) <a href="http://localhost:6060/src/golang.org/x/tools/go/ssa/ssa.go?s=48031:48085#L1412">RelString</a>
					<a class="permalink" href="index.html#Global.RelString">&#xb6;</a>
					
					
				</h3>
				<pre>func (v *<a href="index.html#Global">Global</a>) RelString(from *<a href="http://localhost:6060/pkg/go/types/">types</a>.<a href="http://localhost:6060/pkg/go/types/#Package">Package</a>) <a href="http://localhost:6060/pkg/builtin/#string">string</a></pre>
				
				
				
				
			
				
				<h3 id="Global.String">func (*Global) <a href="http://localhost:6060/src/golang.org/x/tools/go/ssa/ssa.go?s=47876:47908#L1410">String</a>
					<a class="permalink" href="index.html#Global.String">&#xb6;</a>
					
					
				</h3>
				<pre>func (v *<a href="index.html#Global">Global</a>) String() <a href="http://localhost:6060/pkg/builtin/#string">string</a></pre>
				
				
				
				
			
				
				<h3 id="Global.Token">func (*Global) <a href="http://localhost:6060/src/golang.org/x/tools/go/ssa/ssa.go?s=47725:47761#L1408">Token</a>
					<a class="permalink" href="index.html#Global.Token">&#xb6;</a>
					
					
				</h3>
				<pre>func (v *<a href="index.html#Global">Global</a>) Token() <a href="http://localhost:6060/pkg/go/token/">token</a>.<a href="http://localhost:6060/pkg/go/token/#Token">Token</a></pre>
				
				
				
				
			
				
				<h3 id="Global.Type">func (*Global) <a href="http://localhost:6060/src/golang.org/x/tools/go/ssa/ssa.go?s=47368:47402#L1403">Type</a>
					<a class="permalink" href="index.html#Global.Type">&#xb6;</a>
					
					
				</h3>
				<pre>func (v *<a href="index.html#Global">Global</a>) Type() <a href="http://localhost:6060/pkg/go/types/">types</a>.<a href="http://localhost:6060/pkg/go/types/#Type">Type</a></pre>
				
				
				
				
			
		
			
			
			<h2 id="Go">type <a href="http://localhost:6060/src/golang.org/x/tools/go/ssa/ssa.go?s=37745:37811#L1118">Go</a>
				<a class="permalink" href="index.html#Go">&#xb6;</a>
				
				
			</h2>
			<p>
The Go instruction creates a new goroutine and calls the specified
function within it.
</p>
<p>
See CallCommon for generic function call documentation.
</p>
<p>
Pos() returns the ast.GoStmt.Go.
</p>
<p>
Example printed form:
</p>
<pre>go println(t0, t1)
go t3()
go invoke t5.Println(...t6)
</pre>

			<pre>type Go struct {
<span id="Go.Call"></span>    Call <a href="index.html#CallCommon">CallCommon</a>
    <span class="comment">// contains filtered or unexported fields</span>
}
</pre>

			

			

			
			
			

			

			
				
				<h3 id="Go.Block">func (*Go) <a href="http://localhost:6060/src/golang.org/x/tools/go/ssa/ssa.go?s=49851:49894#L1449">Block</a>
					<a class="permalink" href="index.html#Go.Block">&#xb6;</a>
					
					
				</h3>
				<pre>func (v *<a href="index.html#Go">Go</a>) Block() *<a href="index.html#BasicBlock">BasicBlock</a></pre>
				
				
				
				
			
				
				<h3 id="Go.Common">func (*Go) <a href="http://localhost:6060/src/golang.org/x/tools/go/ssa/ssa.go?s=46467:46500#L1384">Common</a>
					<a class="permalink" href="index.html#Go.Common">&#xb6;</a>
					
					
				</h3>
				<pre>func (s *<a href="index.html#Go">Go</a>) Common() *<a href="index.html#CallCommon">CallCommon</a></pre>
				
				
				
				
			
				
				<h3 id="Go.Operands">func (*Go) <a href="http://localhost:6060/src/golang.org/x/tools/go/ssa/ssa.go?s=53121:53167#L1534">Operands</a>
					<a class="permalink" href="index.html#Go.Operands">&#xb6;</a>
					
					
				</h3>
				<pre>func (s *<a href="index.html#Go">Go</a>) Operands(rands []*<a href="index.html#Value">Value</a>) []*<a href="index.html#Value">Value</a></pre>
				
				
				
				
			
				
				<h3 id="Go.Parent">func (*Go) <a href="http://localhost:6060/src/golang.org/x/tools/go/ssa/ssa.go?s=49773:49815#L1448">Parent</a>
					<a class="permalink" href="index.html#Go.Parent">&#xb6;</a>
					
					
				</h3>
				<pre>func (v *<a href="index.html#Go">Go</a>) Parent() *<a href="index.html#Function">Function</a></pre>
				
				
				
				
			
				
				<h3 id="Go.Pos">func (*Go) <a href="http://localhost:6060/src/golang.org/x/tools/go/ssa/ssa.go?s=52222:52250#L1505">Pos</a>
					<a class="permalink" href="index.html#Go.Pos">&#xb6;</a>
					
					
				</h3>
				<pre>func (s *<a href="index.html#Go">Go</a>) Pos() <a href="http://localhost:6060/pkg/go/token/">token</a>.<a href="http://localhost:6060/pkg/go/token/#Pos">Pos</a></pre>
				
				
				
				
			
				
				<h3 id="Go.Referrers">func (*Go) <a href="http://localhost:6060/src/golang.org/x/tools/go/ssa/ssa.go?s=49994:50044#L1451">Referrers</a>
					<a class="permalink" href="index.html#Go.Referrers">&#xb6;</a>
					
					
				</h3>
				<pre>func (v *<a href="index.html#Go">Go</a>) Referrers() *[]<a href="index.html#Instruction">Instruction</a></pre>
				
				
				
				
			
				
				<h3 id="Go.String">func (*Go) <a href="http://localhost:6060/src/golang.org/x/tools/go/ssa/print.go?s=7120:7148#L283">String</a>
					<a class="permalink" href="index.html#Go.String">&#xb6;</a>
					
					
				</h3>
				<pre>func (s *<a href="index.html#Go">Go</a>) String() <a href="http://localhost:6060/pkg/builtin/#string">string</a></pre>
				
				
				
				
			
				
				<h3 id="Go.Value">func (*Go) <a href="http://localhost:6060/src/golang.org/x/tools/go/ssa/ssa.go?s=46612:46638#L1388">Value</a>
					<a class="permalink" href="index.html#Go.Value">&#xb6;</a>
					
					
				</h3>
				<pre>func (s *<a href="index.html#Go">Go</a>) Value() *<a href="index.html#Call">Call</a></pre>
				
				
				
				
			
		
			
			
			<h2 id="If">type <a href="http://localhost:6060/src/golang.org/x/tools/go/ssa/ssa.go?s=35613:35658#L1037">If</a>
				<a class="permalink" href="index.html#If">&#xb6;</a>
				
				
			</h2>
			<p>
The If instruction transfers control to one of the two successors
of its owning block, depending on the boolean Cond: the first if
true, the second if false.
</p>
<p>
An If instruction must be the last instruction of its containing
BasicBlock.
</p>
<p>
Pos() returns NoPos.
</p>
<p>
Example printed form:
</p>
<pre>if t0 goto done else body
</pre>

			<pre>type If struct {
<span id="If.Cond"></span>    Cond <a href="index.html#Value">Value</a>
    <span class="comment">// contains filtered or unexported fields</span>
}
</pre>

			

			

			
			
			

			

			
				
				<h3 id="If.Block">func (*If) <a href="http://localhost:6060/src/golang.org/x/tools/go/ssa/ssa.go?s=49851:49894#L1449">Block</a>
					<a class="permalink" href="index.html#If.Block">&#xb6;</a>
					
					
				</h3>
				<pre>func (v *<a href="index.html#If">If</a>) Block() *<a href="index.html#BasicBlock">BasicBlock</a></pre>
				
				
				
				
			
				
				<h3 id="If.Operands">func (*If) <a href="http://localhost:6060/src/golang.org/x/tools/go/ssa/ssa.go?s=53986:54032#L1574">Operands</a>
					<a class="permalink" href="index.html#If.Operands">&#xb6;</a>
					
					
				</h3>
				<pre>func (s *<a href="index.html#If">If</a>) Operands(rands []*<a href="index.html#Value">Value</a>) []*<a href="index.html#Value">Value</a></pre>
				
				
				
				
			
				
				<h3 id="If.Parent">func (*If) <a href="http://localhost:6060/src/golang.org/x/tools/go/ssa/ssa.go?s=49773:49815#L1448">Parent</a>
					<a class="permalink" href="index.html#If.Parent">&#xb6;</a>
					
					
				</h3>
				<pre>func (v *<a href="index.html#If">If</a>) Parent() *<a href="index.html#Function">Function</a></pre>
				
				
				
				
			
				
				<h3 id="If.Pos">func (*If) <a href="http://localhost:6060/src/golang.org/x/tools/go/ssa/ssa.go?s=52540:52568#L1511">Pos</a>
					<a class="permalink" href="index.html#If.Pos">&#xb6;</a>
					
					
				</h3>
				<pre>func (s *<a href="index.html#If">If</a>) Pos() <a href="http://localhost:6060/pkg/go/token/">token</a>.<a href="http://localhost:6060/pkg/go/token/#Pos">Pos</a></pre>
				
				
				
				
			
				
				<h3 id="If.Referrers">func (*If) <a href="http://localhost:6060/src/golang.org/x/tools/go/ssa/ssa.go?s=49994:50044#L1451">Referrers</a>
					<a class="permalink" href="index.html#If.Referrers">&#xb6;</a>
					
					
				</h3>
				<pre>func (v *<a href="index.html#If">If</a>) Referrers() *[]<a href="index.html#Instruction">Instruction</a></pre>
				
				
				
				
			
				
				<h3 id="If.String">func (*If) <a href="http://localhost:6060/src/golang.org/x/tools/go/ssa/print.go?s=6823:6851#L273">String</a>
					<a class="permalink" href="index.html#If.String">&#xb6;</a>
					
					
				</h3>
				<pre>func (s *<a href="index.html#If">If</a>) String() <a href="http://localhost:6060/pkg/builtin/#string">string</a></pre>
				
				
				
				
			
		
			
			
			<h2 id="Index">type <a href="http://localhost:6060/src/golang.org/x/tools/go/ssa/ssa.go?s=29049:29132#L832">Index</a>
				<a class="permalink" href="index.html#Index">&#xb6;</a>
				
				
			</h2>
			<p>
The Index instruction yields element Index of array X.
</p>
<p>
Pos() returns the ast.IndexExpr.Lbrack for the index operation, if
explicit in the source.
</p>
<p>
Example printed form:
</p>
<pre>t2 = t0[t1]
</pre>

			<pre>type Index struct {
<span id="Index.X"></span>    X     <a href="index.html#Value">Value</a> <span class="comment">// array</span>
<span id="Index.Index"></span>    Index <a href="index.html#Value">Value</a> <span class="comment">// integer index</span>
    <span class="comment">// contains filtered or unexported fields</span>
}
</pre>

			

			

			
			
			

			

			
				
				<h3 id="Index.Name">func (*Index) <a href="http://localhost:6060/src/golang.org/x/tools/go/ssa/ssa.go?s=49432:49464#L1442">Name</a>
					<a class="permalink" href="index.html#Index.Name">&#xb6;</a>
					
					
				</h3>
				<pre>func (v *<a href="index.html#Index">Index</a>) Name() <a href="http://localhost:6060/pkg/builtin/#string">string</a></pre>
				
				
				
				
			
				
				<h3 id="Index.Operands">func (*Index) <a href="http://localhost:6060/src/golang.org/x/tools/go/ssa/ssa.go?s=54069:54118#L1578">Operands</a>
					<a class="permalink" href="index.html#Index.Operands">&#xb6;</a>
					
					
				</h3>
				<pre>func (v *<a href="index.html#Index">Index</a>) Operands(rands []*<a href="index.html#Value">Value</a>) []*<a href="index.html#Value">Value</a></pre>
				
				
				
				
			
				
				<h3 id="Index.Pos">func (*Index) <a href="http://localhost:6060/src/golang.org/x/tools/go/ssa/ssa.go?s=49647:49681#L1445">Pos</a>
					<a class="permalink" href="index.html#Index.Pos">&#xb6;</a>
					
					
				</h3>
				<pre>func (v *<a href="index.html#Index">Index</a>) Pos() <a href="http://localhost:6060/pkg/go/token/">token</a>.<a href="http://localhost:6060/pkg/go/token/#Pos">Pos</a></pre>
				
				
				
				
			
				
				<h3 id="Index.Referrers">func (*Index) <a href="http://localhost:6060/src/golang.org/x/tools/go/ssa/ssa.go?s=49577:49622#L1444">Referrers</a>
					<a class="permalink" href="index.html#Index.Referrers">&#xb6;</a>
					
					
				</h3>
				<pre>func (v *<a href="index.html#Index">Index</a>) Referrers() *[]<a href="index.html#Instruction">Instruction</a></pre>
				
				
				
				
			
				
				<h3 id="Index.String">func (*Index) <a href="http://localhost:6060/src/golang.org/x/tools/go/ssa/print.go?s=5950:5981#L239">String</a>
					<a class="permalink" href="index.html#Index.String">&#xb6;</a>
					
					
				</h3>
				<pre>func (v *<a href="index.html#Index">Index</a>) String() <a href="http://localhost:6060/pkg/builtin/#string">string</a></pre>
				
				
				
				
			
				
				<h3 id="Index.Type">func (*Index) <a href="http://localhost:6060/src/golang.org/x/tools/go/ssa/ssa.go?s=49307:49343#L1440">Type</a>
					<a class="permalink" href="index.html#Index.Type">&#xb6;</a>
					
					
				</h3>
				<pre>func (v *<a href="index.html#Index">Index</a>) Type() <a href="http://localhost:6060/pkg/go/types/">types</a>.<a href="http://localhost:6060/pkg/go/types/#Type">Type</a></pre>
				
				
				
				
			
		
			
			
			<h2 id="IndexAddr">type <a href="http://localhost:6060/src/golang.org/x/tools/go/ssa/ssa.go?s=28744:28842#L818">IndexAddr</a>
				<a class="permalink" href="index.html#IndexAddr">&#xb6;</a>
				
				
			</h2>
			<p>
The IndexAddr instruction yields the address of the element at
index Index of collection X.  Index is an integer expression.
</p>
<p>
The elements of maps and strings are not addressable; use Lookup or
MapUpdate instead.
</p>
<p>
Dynamically, this instruction panics if X evaluates to a nil *array
pointer.
</p>
<p>
Type() returns a (possibly named) *types.Pointer.
</p>
<p>
Pos() returns the ast.IndexExpr.Lbrack for the index operation, if
explicit in the source.
</p>
<p>
Example printed form:
</p>
<pre>t2 = &amp;t0[t1]
</pre>

			<pre>type IndexAddr struct {
<span id="IndexAddr.X"></span>    X     <a href="index.html#Value">Value</a> <span class="comment">// slice or *array,</span>
<span id="IndexAddr.Index"></span>    Index <a href="index.html#Value">Value</a> <span class="comment">// numeric index</span>
    <span class="comment">// contains filtered or unexported fields</span>
}
</pre>

			

			

			
			
			

			

			
				
				<h3 id="IndexAddr.Name">func (*IndexAddr) <a href="http://localhost:6060/src/golang.org/x/tools/go/ssa/ssa.go?s=49432:49464#L1442">Name</a>
					<a class="permalink" href="index.html#IndexAddr.Name">&#xb6;</a>
					
					
				</h3>
				<pre>func (v *<a href="index.html#IndexAddr">IndexAddr</a>) Name() <a href="http://localhost:6060/pkg/builtin/#string">string</a></pre>
				
				
				
				
			
				
				<h3 id="IndexAddr.Operands">func (*IndexAddr) <a href="http://localhost:6060/src/golang.org/x/tools/go/ssa/ssa.go?s=54162:54215#L1582">Operands</a>
					<a class="permalink" href="index.html#IndexAddr.Operands">&#xb6;</a>
					
					
				</h3>
				<pre>func (v *<a href="index.html#IndexAddr">IndexAddr</a>) Operands(rands []*<a href="index.html#Value">Value</a>) []*<a href="index.html#Value">Value</a></pre>
				
				
				
				
			
				
				<h3 id="IndexAddr.Pos">func (*IndexAddr) <a href="http://localhost:6060/src/golang.org/x/tools/go/ssa/ssa.go?s=49647:49681#L1445">Pos</a>
					<a class="permalink" href="index.html#IndexAddr.Pos">&#xb6;</a>
					
					
				</h3>
				<pre>func (v *<a href="index.html#IndexAddr">IndexAddr</a>) Pos() <a href="http://localhost:6060/pkg/go/token/">token</a>.<a href="http://localhost:6060/pkg/go/token/#Pos">Pos</a></pre>
				
				
				
				
			
				
				<h3 id="IndexAddr.Referrers">func (*IndexAddr) <a href="http://localhost:6060/src/golang.org/x/tools/go/ssa/ssa.go?s=49577:49622#L1444">Referrers</a>
					<a class="permalink" href="index.html#IndexAddr.Referrers">&#xb6;</a>
					
					
				</h3>
				<pre>func (v *<a href="index.html#IndexAddr">IndexAddr</a>) Referrers() *[]<a href="index.html#Instruction">Instruction</a></pre>
				
				
				
				
			
				
				<h3 id="IndexAddr.String">func (*IndexAddr) <a href="http://localhost:6060/src/golang.org/x/tools/go/ssa/print.go?s=5840:5875#L235">String</a>
					<a class="permalink" href="index.html#IndexAddr.String">&#xb6;</a>
					
					
				</h3>
				<pre>func (v *<a href="index.html#IndexAddr">IndexAddr</a>) String() <a href="http://localhost:6060/pkg/builtin/#string">string</a></pre>
				
				
				
				
			
				
				<h3 id="IndexAddr.Type">func (*IndexAddr) <a href="http://localhost:6060/src/golang.org/x/tools/go/ssa/ssa.go?s=49307:49343#L1440">Type</a>
					<a class="permalink" href="index.html#IndexAddr.Type">&#xb6;</a>
					
					
				</h3>
				<pre>func (v *<a href="index.html#IndexAddr">IndexAddr</a>) Type() <a href="http://localhost:6060/pkg/go/types/">types</a>.<a href="http://localhost:6060/pkg/go/types/#Type">Type</a></pre>
				
				
				
				
			
		
			
			
			<h2 id="Instruction">type <a href="http://localhost:6060/src/golang.org/x/tools/go/ssa/ssa.go?s=6714:9119#L158">Instruction</a>
				<a class="permalink" href="index.html#Instruction">&#xb6;</a>
				
				
			</h2>
			<p>
An Instruction is an SSA instruction that computes a new Value or
has some effect.
</p>
<p>
An Instruction that defines a value (e.g. BinOp) also implements
the Value interface; an Instruction that only has an effect (e.g. Store)
does not.
</p>

			<pre>type Instruction interface {
    <span class="comment">// String returns the disassembled form of this value.</span>
    <span class="comment">//</span>
    <span class="comment">// Examples of Instructions that are Values:</span>
    <span class="comment">//       &#34;x + y&#34;     (BinOp)</span>
    <span class="comment">//       &#34;len([])&#34;   (Call)</span>
    <span class="comment">// Note that the name of the Value is not printed.</span>
    <span class="comment">//</span>
    <span class="comment">// Examples of Instructions that are not Values:</span>
    <span class="comment">//       &#34;return x&#34;  (Return)</span>
    <span class="comment">//       &#34;*y = x&#34;    (Store)</span>
    <span class="comment">//</span>
    <span class="comment">// (The separation Value.Name() from Value.String() is useful</span>
    <span class="comment">// for some analyses which distinguish the operation from the</span>
    <span class="comment">// value it defines, e.g., &#39;y = local int&#39; is both an allocation</span>
    <span class="comment">// of memory &#39;local int&#39; and a definition of a pointer y.)</span>
    String() <a href="http://localhost:6060/pkg/builtin/#string">string</a>

    <span class="comment">// Parent returns the function to which this instruction</span>
    <span class="comment">// belongs.</span>
    Parent() *<a href="index.html#Function">Function</a>

    <span class="comment">// Block returns the basic block to which this instruction</span>
    <span class="comment">// belongs.</span>
    Block() *<a href="index.html#BasicBlock">BasicBlock</a>

    <span class="comment">// Operands returns the operands of this instruction: the</span>
    <span class="comment">// set of Values it references.</span>
    <span class="comment">//</span>
    <span class="comment">// Specifically, it appends their addresses to rands, a</span>
    <span class="comment">// user-provided slice, and returns the resulting slice,</span>
    <span class="comment">// permitting avoidance of memory allocation.</span>
    <span class="comment">//</span>
    <span class="comment">// The operands are appended in undefined order, but the order</span>
    <span class="comment">// is consistent for a given Instruction; the addresses are</span>
    <span class="comment">// always non-nil but may point to a nil Value.  Clients may</span>
    <span class="comment">// store through the pointers, e.g. to effect a value</span>
    <span class="comment">// renaming.</span>
    <span class="comment">//</span>
    <span class="comment">// Value.Referrers is a subset of the inverse of this</span>
    <span class="comment">// relation.  (Referrers are not tracked for all types of</span>
    <span class="comment">// Values.)</span>
    Operands(rands []*<a href="index.html#Value">Value</a>) []*<a href="index.html#Value">Value</a>

    <span class="comment">// Pos returns the location of the AST token most closely</span>
    <span class="comment">// associated with the operation that gave rise to this</span>
    <span class="comment">// instruction, or token.NoPos if it was not explicit in the</span>
    <span class="comment">// source.</span>
    <span class="comment">//</span>
    <span class="comment">// For each ast.Node type, a particular token is designated as</span>
    <span class="comment">// the closest location for the expression, e.g. the Go token</span>
    <span class="comment">// for an *ast.GoStmt.  This permits a compact but approximate</span>
    <span class="comment">// mapping from Instructions to source positions for use in</span>
    <span class="comment">// diagnostic messages, for example.</span>
    <span class="comment">//</span>
    <span class="comment">// (Do not use this position to determine which Instruction</span>
    <span class="comment">// corresponds to an ast.Expr; see the notes for Value.Pos.</span>
    <span class="comment">// This position may be used to determine which non-Value</span>
    <span class="comment">// Instruction corresponds to some ast.Stmts, but not all: If</span>
    <span class="comment">// and Jump instructions have no Pos(), for example.)</span>
    Pos() <a href="http://localhost:6060/pkg/go/token/">token</a>.<a href="http://localhost:6060/pkg/go/token/#Pos">Pos</a>
    <span class="comment">// contains filtered or unexported methods</span>
}</pre>

			

			

			
			
			

			

			
		
			
			
			<h2 id="Jump">type <a href="http://localhost:6060/src/golang.org/x/tools/go/ssa/ssa.go?s=35235:35270#L1021">Jump</a>
				<a class="permalink" href="index.html#Jump">&#xb6;</a>
				
				
			</h2>
			<p>
The Jump instruction transfers control to the sole successor of its
owning block.
</p>
<p>
A Jump must be the last instruction of its containing BasicBlock.
</p>
<p>
Pos() returns NoPos.
</p>
<p>
Example printed form:
</p>
<pre>jump done
</pre>

			<pre>type Jump struct {
    <span class="comment">// contains filtered or unexported fields</span>
}
</pre>

			

			

			
			
			

			

			
				
				<h3 id="Jump.Block">func (*Jump) <a href="http://localhost:6060/src/golang.org/x/tools/go/ssa/ssa.go?s=49851:49894#L1449">Block</a>
					<a class="permalink" href="index.html#Jump.Block">&#xb6;</a>
					
					
				</h3>
				<pre>func (v *<a href="index.html#Jump">Jump</a>) Block() *<a href="index.html#BasicBlock">BasicBlock</a></pre>
				
				
				
				
			
				
				<h3 id="Jump.Operands">func (*Jump) <a href="http://localhost:6060/src/golang.org/x/tools/go/ssa/ssa.go?s=54259:54305#L1586">Operands</a>
					<a class="permalink" href="index.html#Jump.Operands">&#xb6;</a>
					
					
				</h3>
				<pre>func (*<a href="index.html#Jump">Jump</a>) Operands(rands []*<a href="index.html#Value">Value</a>) []*<a href="index.html#Value">Value</a></pre>
				
				
				
				
			
				
				<h3 id="Jump.Parent">func (*Jump) <a href="http://localhost:6060/src/golang.org/x/tools/go/ssa/ssa.go?s=49773:49815#L1448">Parent</a>
					<a class="permalink" href="index.html#Jump.Parent">&#xb6;</a>
					
					
				</h3>
				<pre>func (v *<a href="index.html#Jump">Jump</a>) Parent() *<a href="index.html#Function">Function</a></pre>
				
				
				
				
			
				
				<h3 id="Jump.Pos">func (*Jump) <a href="http://localhost:6060/src/golang.org/x/tools/go/ssa/ssa.go?s=52599:52629#L1512">Pos</a>
					<a class="permalink" href="index.html#Jump.Pos">&#xb6;</a>
					
					
				</h3>
				<pre>func (s *<a href="index.html#Jump">Jump</a>) Pos() <a href="http://localhost:6060/pkg/go/token/">token</a>.<a href="http://localhost:6060/pkg/go/token/#Pos">Pos</a></pre>
				
				
				
				
			
				
				<h3 id="Jump.Referrers">func (*Jump) <a href="http://localhost:6060/src/golang.org/x/tools/go/ssa/ssa.go?s=49994:50044#L1451">Referrers</a>
					<a class="permalink" href="index.html#Jump.Referrers">&#xb6;</a>
					
					
				</h3>
				<pre>func (v *<a href="index.html#Jump">Jump</a>) Referrers() *[]<a href="index.html#Instruction">Instruction</a></pre>
				
				
				
				
			
				
				<h3 id="Jump.String">func (*Jump) <a href="http://localhost:6060/src/golang.org/x/tools/go/ssa/print.go?s=6615:6645#L264">String</a>
					<a class="permalink" href="index.html#Jump.String">&#xb6;</a>
					
					
				</h3>
				<pre>func (s *<a href="index.html#Jump">Jump</a>) String() <a href="http://localhost:6060/pkg/builtin/#string">string</a></pre>
				
				
				
				
			
		
			
			
			<h2 id="Lookup">type <a href="http://localhost:6060/src/golang.org/x/tools/go/ssa/ssa.go?s=29649:29799#L852">Lookup</a>
				<a class="permalink" href="index.html#Lookup">&#xb6;</a>
				
				
			</h2>
			<p>
The Lookup instruction yields element Index of collection X, a map
or string.  Index is an integer expression if X is a string or the
appropriate key type if X is a map.
</p>
<p>
If CommaOk, the result is a 2-tuple of the value above and a
boolean indicating the result of a map membership test for the key.
The components of the tuple are accessed using Extract.
</p>
<p>
Pos() returns the ast.IndexExpr.Lbrack, if explicit in the source.
</p>
<p>
Example printed form:
</p>
<pre>t2 = t0[t1]
t5 = t3[t4],ok
</pre>

			<pre>type Lookup struct {
<span id="Lookup.X"></span>    X       <a href="index.html#Value">Value</a> <span class="comment">// string or map</span>
<span id="Lookup.Index"></span>    Index   <a href="index.html#Value">Value</a> <span class="comment">// numeric or key-typed index</span>
<span id="Lookup.CommaOk"></span>    CommaOk <a href="http://localhost:6060/pkg/builtin/#bool">bool</a>  <span class="comment">// return a value,ok pair</span>
    <span class="comment">// contains filtered or unexported fields</span>
}
</pre>

			

			

			
			
			

			

			
				
				<h3 id="Lookup.Name">func (*Lookup) <a href="http://localhost:6060/src/golang.org/x/tools/go/ssa/ssa.go?s=49432:49464#L1442">Name</a>
					<a class="permalink" href="index.html#Lookup.Name">&#xb6;</a>
					
					
				</h3>
				<pre>func (v *<a href="index.html#Lookup">Lookup</a>) Name() <a href="http://localhost:6060/pkg/builtin/#string">string</a></pre>
				
				
				
				
			
				
				<h3 id="Lookup.Operands">func (*Lookup) <a href="http://localhost:6060/src/golang.org/x/tools/go/ssa/ssa.go?s=54325:54375#L1590">Operands</a>
					<a class="permalink" href="index.html#Lookup.Operands">&#xb6;</a>
					
					
				</h3>
				<pre>func (v *<a href="index.html#Lookup">Lookup</a>) Operands(rands []*<a href="index.html#Value">Value</a>) []*<a href="index.html#Value">Value</a></pre>
				
				
				
				
			
				
				<h3 id="Lookup.Pos">func (*Lookup) <a href="http://localhost:6060/src/golang.org/x/tools/go/ssa/ssa.go?s=49647:49681#L1445">Pos</a>
					<a class="permalink" href="index.html#Lookup.Pos">&#xb6;</a>
					
					
				</h3>
				<pre>func (v *<a href="index.html#Lookup">Lookup</a>) Pos() <a href="http://localhost:6060/pkg/go/token/">token</a>.<a href="http://localhost:6060/pkg/go/token/#Pos">Pos</a></pre>
				
				
				
				
			
				
				<h3 id="Lookup.Referrers">func (*Lookup) <a href="http://localhost:6060/src/golang.org/x/tools/go/ssa/ssa.go?s=49577:49622#L1444">Referrers</a>
					<a class="permalink" href="index.html#Lookup.Referrers">&#xb6;</a>
					
					
				</h3>
				<pre>func (v *<a href="index.html#Lookup">Lookup</a>) Referrers() *[]<a href="index.html#Instruction">Instruction</a></pre>
				
				
				
				
			
				
				<h3 id="Lookup.String">func (*Lookup) <a href="http://localhost:6060/src/golang.org/x/tools/go/ssa/print.go?s=6055:6087#L243">String</a>
					<a class="permalink" href="index.html#Lookup.String">&#xb6;</a>
					
					
				</h3>
				<pre>func (v *<a href="index.html#Lookup">Lookup</a>) String() <a href="http://localhost:6060/pkg/builtin/#string">string</a></pre>
				
				
				
				
			
				
				<h3 id="Lookup.Type">func (*Lookup) <a href="http://localhost:6060/src/golang.org/x/tools/go/ssa/ssa.go?s=49307:49343#L1440">Type</a>
					<a class="permalink" href="index.html#Lookup.Type">&#xb6;</a>
					
					
				</h3>
				<pre>func (v *<a href="index.html#Lookup">Lookup</a>) Type() <a href="http://localhost:6060/pkg/go/types/">types</a>.<a href="http://localhost:6060/pkg/go/types/#Type">Type</a></pre>
				
				
				
				
			
		
			
			
			<h2 id="MakeChan">type <a href="http://localhost:6060/src/golang.org/x/tools/go/ssa/ssa.go?s=25653:25744#L711">MakeChan</a>
				<a class="permalink" href="index.html#MakeChan">&#xb6;</a>
				
				
			</h2>
			<p>
The MakeChan instruction creates a new channel object and yields a
value of kind chan.
</p>
<p>
Type() returns a (possibly named) *types.Chan.
</p>
<p>
Pos() returns the ast.CallExpr.Lparen for the make(chan) that
created it.
</p>
<p>
Example printed form:
</p>
<pre>t0 = make chan int 0
t0 = make IntChan 0
</pre>

			<pre>type MakeChan struct {
<span id="MakeChan.Size"></span>    Size <a href="index.html#Value">Value</a> <span class="comment">// int; size of buffer; zero =&gt; synchronous.</span>
    <span class="comment">// contains filtered or unexported fields</span>
}
</pre>

			

			

			
			
			

			

			
				
				<h3 id="MakeChan.Name">func (*MakeChan) <a href="http://localhost:6060/src/golang.org/x/tools/go/ssa/ssa.go?s=49432:49464#L1442">Name</a>
					<a class="permalink" href="index.html#MakeChan.Name">&#xb6;</a>
					
					
				</h3>
				<pre>func (v *<a href="index.html#MakeChan">MakeChan</a>) Name() <a href="http://localhost:6060/pkg/builtin/#string">string</a></pre>
				
				
				
				
			
				
				<h3 id="MakeChan.Operands">func (*MakeChan) <a href="http://localhost:6060/src/golang.org/x/tools/go/ssa/ssa.go?s=54419:54471#L1594">Operands</a>
					<a class="permalink" href="index.html#MakeChan.Operands">&#xb6;</a>
					
					
				</h3>
				<pre>func (v *<a href="index.html#MakeChan">MakeChan</a>) Operands(rands []*<a href="index.html#Value">Value</a>) []*<a href="index.html#Value">Value</a></pre>
				
				
				
				
			
				
				<h3 id="MakeChan.Pos">func (*MakeChan) <a href="http://localhost:6060/src/golang.org/x/tools/go/ssa/ssa.go?s=49647:49681#L1445">Pos</a>
					<a class="permalink" href="index.html#MakeChan.Pos">&#xb6;</a>
					
					
				</h3>
				<pre>func (v *<a href="index.html#MakeChan">MakeChan</a>) Pos() <a href="http://localhost:6060/pkg/go/token/">token</a>.<a href="http://localhost:6060/pkg/go/token/#Pos">Pos</a></pre>
				
				
				
				
			
				
				<h3 id="MakeChan.Referrers">func (*MakeChan) <a href="http://localhost:6060/src/golang.org/x/tools/go/ssa/ssa.go?s=49577:49622#L1444">Referrers</a>
					<a class="permalink" href="index.html#MakeChan.Referrers">&#xb6;</a>
					
					
				</h3>
				<pre>func (v *<a href="index.html#MakeChan">MakeChan</a>) Referrers() *[]<a href="index.html#Instruction">Instruction</a></pre>
				
				
				
				
			
				
				<h3 id="MakeChan.String">func (*MakeChan) <a href="http://localhost:6060/src/golang.org/x/tools/go/ssa/print.go?s=5117:5151#L210">String</a>
					<a class="permalink" href="index.html#MakeChan.String">&#xb6;</a>
					
					
				</h3>
				<pre>func (v *<a href="index.html#MakeChan">MakeChan</a>) String() <a href="http://localhost:6060/pkg/builtin/#string">string</a></pre>
				
				
				
				
			
				
				<h3 id="MakeChan.Type">func (*MakeChan) <a href="http://localhost:6060/src/golang.org/x/tools/go/ssa/ssa.go?s=49307:49343#L1440">Type</a>
					<a class="permalink" href="index.html#MakeChan.Type">&#xb6;</a>
					
					
				</h3>
				<pre>func (v *<a href="index.html#MakeChan">MakeChan</a>) Type() <a href="http://localhost:6060/pkg/go/types/">types</a>.<a href="http://localhost:6060/pkg/go/types/#Type">Type</a></pre>
				
				
				
				
			
		
			
			
			<h2 id="MakeClosure">type <a href="http://localhost:6060/src/golang.org/x/tools/go/ssa/ssa.go?s=24726:24869#L676">MakeClosure</a>
				<a class="permalink" href="index.html#MakeClosure">&#xb6;</a>
				
				
			</h2>
			<p>
The MakeClosure instruction yields a closure value whose code is
Fn and whose free variables&#39; values are supplied by Bindings.
</p>
<p>
Type() returns a (possibly named) *types.Signature.
</p>
<p>
Pos() returns the ast.FuncLit.Type.Func for a function literal
closure or the ast.SelectorExpr.Sel for a bound method closure.
</p>
<p>
Example printed form:
</p>
<pre>t0 = make closure anon@1.2 [x y z]
t1 = make closure bound$(main.I).add [i]
</pre>

			<pre>type MakeClosure struct {
<span id="MakeClosure.Fn"></span>    Fn       <a href="index.html#Value">Value</a>   <span class="comment">// always a *Function</span>
<span id="MakeClosure.Bindings"></span>    Bindings []<a href="index.html#Value">Value</a> <span class="comment">// values for each free variable in Fn.FreeVars</span>
    <span class="comment">// contains filtered or unexported fields</span>
}
</pre>

			

			

			
			
			

			

			
				
				<h3 id="MakeClosure.Name">func (*MakeClosure) <a href="http://localhost:6060/src/golang.org/x/tools/go/ssa/ssa.go?s=49432:49464#L1442">Name</a>
					<a class="permalink" href="index.html#MakeClosure.Name">&#xb6;</a>
					
					
				</h3>
				<pre>func (v *<a href="index.html#MakeClosure">MakeClosure</a>) Name() <a href="http://localhost:6060/pkg/builtin/#string">string</a></pre>
				
				
				
				
			
				
				<h3 id="MakeClosure.Operands">func (*MakeClosure) <a href="http://localhost:6060/src/golang.org/x/tools/go/ssa/ssa.go?s=54508:54563#L1598">Operands</a>
					<a class="permalink" href="index.html#MakeClosure.Operands">&#xb6;</a>
					
					
				</h3>
				<pre>func (v *<a href="index.html#MakeClosure">MakeClosure</a>) Operands(rands []*<a href="index.html#Value">Value</a>) []*<a href="index.html#Value">Value</a></pre>
				
				
				
				
			
				
				<h3 id="MakeClosure.Pos">func (*MakeClosure) <a href="http://localhost:6060/src/golang.org/x/tools/go/ssa/ssa.go?s=49647:49681#L1445">Pos</a>
					<a class="permalink" href="index.html#MakeClosure.Pos">&#xb6;</a>
					
					
				</h3>
				<pre>func (v *<a href="index.html#MakeClosure">MakeClosure</a>) Pos() <a href="http://localhost:6060/pkg/go/token/">token</a>.<a href="http://localhost:6060/pkg/go/token/#Pos">Pos</a></pre>
				
				
				
				
			
				
				<h3 id="MakeClosure.Referrers">func (*MakeClosure) <a href="http://localhost:6060/src/golang.org/x/tools/go/ssa/ssa.go?s=49577:49622#L1444">Referrers</a>
					<a class="permalink" href="index.html#MakeClosure.Referrers">&#xb6;</a>
					
					
				</h3>
				<pre>func (v *<a href="index.html#MakeClosure">MakeClosure</a>) Referrers() *[]<a href="index.html#Instruction">Instruction</a></pre>
				
				
				
				
			
				
				<h3 id="MakeClosure.String">func (*MakeClosure) <a href="http://localhost:6060/src/golang.org/x/tools/go/ssa/print.go?s=4043:4080#L157">String</a>
					<a class="permalink" href="index.html#MakeClosure.String">&#xb6;</a>
					
					
				</h3>
				<pre>func (v *<a href="index.html#MakeClosure">MakeClosure</a>) String() <a href="http://localhost:6060/pkg/builtin/#string">string</a></pre>
				
				
				
				
			
				
				<h3 id="MakeClosure.Type">func (*MakeClosure) <a href="http://localhost:6060/src/golang.org/x/tools/go/ssa/ssa.go?s=49307:49343#L1440">Type</a>
					<a class="permalink" href="index.html#MakeClosure.Type">&#xb6;</a>
					
					
				</h3>
				<pre>func (v *<a href="index.html#MakeClosure">MakeClosure</a>) Type() <a href="http://localhost:6060/pkg/go/types/">types</a>.<a href="http://localhost:6060/pkg/go/types/#Type">Type</a></pre>
				
				
				
				
			
		
			
			
			<h2 id="MakeInterface">type <a href="http://localhost:6060/src/golang.org/x/tools/go/ssa/ssa.go?s=24234:24282#L659">MakeInterface</a>
				<a class="permalink" href="index.html#MakeInterface">&#xb6;</a>
				
				
			</h2>
			<p>
MakeInterface constructs an instance of an interface type from a
value of a concrete type.
</p>
<p>
Use Program.MethodSets.MethodSet(X.Type()) to find the method-set
of X, and Program.MethodValue(m) to find the implementation of a method.
</p>
<p>
To construct the zero value of an interface type T, use:
</p>
<pre>NewConst(constant.MakeNil(), T, pos)
</pre>
<p>
Pos() returns the ast.CallExpr.Lparen, if the instruction arose
from an explicit conversion in the source.
</p>
<p>
Example printed form:
</p>
<pre>t1 = make interface{} &lt;- int (42:int)
t2 = make Stringer &lt;- t0
</pre>

			<pre>type MakeInterface struct {
<span id="MakeInterface.X"></span>    X <a href="index.html#Value">Value</a>
    <span class="comment">// contains filtered or unexported fields</span>
}
</pre>

			

			

			
			
			

			

			
				
				<h3 id="MakeInterface.Name">func (*MakeInterface) <a href="http://localhost:6060/src/golang.org/x/tools/go/ssa/ssa.go?s=49432:49464#L1442">Name</a>
					<a class="permalink" href="index.html#MakeInterface.Name">&#xb6;</a>
					
					
				</h3>
				<pre>func (v *<a href="index.html#MakeInterface">MakeInterface</a>) Name() <a href="http://localhost:6060/pkg/builtin/#string">string</a></pre>
				
				
				
				
			
				
				<h3 id="MakeInterface.Operands">func (*MakeInterface) <a href="http://localhost:6060/src/golang.org/x/tools/go/ssa/ssa.go?s=54685:54742#L1606">Operands</a>
					<a class="permalink" href="index.html#MakeInterface.Operands">&#xb6;</a>
					
					
				</h3>
				<pre>func (v *<a href="index.html#MakeInterface">MakeInterface</a>) Operands(rands []*<a href="index.html#Value">Value</a>) []*<a href="index.html#Value">Value</a></pre>
				
				
				
				
			
				
				<h3 id="MakeInterface.Pos">func (*MakeInterface) <a href="http://localhost:6060/src/golang.org/x/tools/go/ssa/ssa.go?s=49647:49681#L1445">Pos</a>
					<a class="permalink" href="index.html#MakeInterface.Pos">&#xb6;</a>
					
					
				</h3>
				<pre>func (v *<a href="index.html#MakeInterface">MakeInterface</a>) Pos() <a href="http://localhost:6060/pkg/go/token/">token</a>.<a href="http://localhost:6060/pkg/go/token/#Pos">Pos</a></pre>
				
				
				
				
			
				
				<h3 id="MakeInterface.Referrers">func (*MakeInterface) <a href="http://localhost:6060/src/golang.org/x/tools/go/ssa/ssa.go?s=49577:49622#L1444">Referrers</a>
					<a class="permalink" href="index.html#MakeInterface.Referrers">&#xb6;</a>
					
					
				</h3>
				<pre>func (v *<a href="index.html#MakeInterface">MakeInterface</a>) Referrers() *[]<a href="index.html#Instruction">Instruction</a></pre>
				
				
				
				
			
				
				<h3 id="MakeInterface.String">func (*MakeInterface) <a href="http://localhost:6060/src/golang.org/x/tools/go/ssa/print.go?s=3963:4002#L155">String</a>
					<a class="permalink" href="index.html#MakeInterface.String">&#xb6;</a>
					
					
				</h3>
				<pre>func (v *<a href="index.html#MakeInterface">MakeInterface</a>) String() <a href="http://localhost:6060/pkg/builtin/#string">string</a></pre>
				
				
				
				
			
				
				<h3 id="MakeInterface.Type">func (*MakeInterface) <a href="http://localhost:6060/src/golang.org/x/tools/go/ssa/ssa.go?s=49307:49343#L1440">Type</a>
					<a class="permalink" href="index.html#MakeInterface.Type">&#xb6;</a>
					
					
				</h3>
				<pre>func (v *<a href="index.html#MakeInterface">MakeInterface</a>) Type() <a href="http://localhost:6060/pkg/go/types/">types</a>.<a href="http://localhost:6060/pkg/go/types/#Type">Type</a></pre>
				
				
				
				
			
		
			
			
			<h2 id="MakeMap">type <a href="http://localhost:6060/src/golang.org/x/tools/go/ssa/ssa.go?s=25249:25342#L694">MakeMap</a>
				<a class="permalink" href="index.html#MakeMap">&#xb6;</a>
				
				
			</h2>
			<p>
The MakeMap instruction creates a new hash-table-based map object
and yields a value of kind map.
</p>
<p>
Type() returns a (possibly named) *types.Map.
</p>
<p>
Pos() returns the ast.CallExpr.Lparen, if created by make(map), or
the ast.CompositeLit.Lbrack if created by a literal.
</p>
<p>
Example printed form:
</p>
<pre>t1 = make map[string]int t0
t1 = make StringIntMap t0
</pre>

			<pre>type MakeMap struct {
<span id="MakeMap.Reserve"></span>    Reserve <a href="index.html#Value">Value</a> <span class="comment">// initial space reservation; nil =&gt; default</span>
    <span class="comment">// contains filtered or unexported fields</span>
}
</pre>

			

			

			
			
			

			

			
				
				<h3 id="MakeMap.Name">func (*MakeMap) <a href="http://localhost:6060/src/golang.org/x/tools/go/ssa/ssa.go?s=49432:49464#L1442">Name</a>
					<a class="permalink" href="index.html#MakeMap.Name">&#xb6;</a>
					
					
				</h3>
				<pre>func (v *<a href="index.html#MakeMap">MakeMap</a>) Name() <a href="http://localhost:6060/pkg/builtin/#string">string</a></pre>
				
				
				
				
			
				
				<h3 id="MakeMap.Operands">func (*MakeMap) <a href="http://localhost:6060/src/golang.org/x/tools/go/ssa/ssa.go?s=54776:54827#L1610">Operands</a>
					<a class="permalink" href="index.html#MakeMap.Operands">&#xb6;</a>
					
					
				</h3>
				<pre>func (v *<a href="index.html#MakeMap">MakeMap</a>) Operands(rands []*<a href="index.html#Value">Value</a>) []*<a href="index.html#Value">Value</a></pre>
				
				
				
				
			
				
				<h3 id="MakeMap.Pos">func (*MakeMap) <a href="http://localhost:6060/src/golang.org/x/tools/go/ssa/ssa.go?s=49647:49681#L1445">Pos</a>
					<a class="permalink" href="index.html#MakeMap.Pos">&#xb6;</a>
					
					
				</h3>
				<pre>func (v *<a href="index.html#MakeMap">MakeMap</a>) Pos() <a href="http://localhost:6060/pkg/go/token/">token</a>.<a href="http://localhost:6060/pkg/go/token/#Pos">Pos</a></pre>
				
				
				
				
			
				
				<h3 id="MakeMap.Referrers">func (*MakeMap) <a href="http://localhost:6060/src/golang.org/x/tools/go/ssa/ssa.go?s=49577:49622#L1444">Referrers</a>
					<a class="permalink" href="index.html#MakeMap.Referrers">&#xb6;</a>
					
					
				</h3>
				<pre>func (v *<a href="index.html#MakeMap">MakeMap</a>) Referrers() *[]<a href="index.html#Instruction">Instruction</a></pre>
				
				
				
				
			
				
				<h3 id="MakeMap.String">func (*MakeMap) <a href="http://localhost:6060/src/golang.org/x/tools/go/ssa/print.go?s=4921:4954#L201">String</a>
					<a class="permalink" href="index.html#MakeMap.String">&#xb6;</a>
					
					
				</h3>
				<pre>func (v *<a href="index.html#MakeMap">MakeMap</a>) String() <a href="http://localhost:6060/pkg/builtin/#string">string</a></pre>
				
				
				
				
			
				
				<h3 id="MakeMap.Type">func (*MakeMap) <a href="http://localhost:6060/src/golang.org/x/tools/go/ssa/ssa.go?s=49307:49343#L1440">Type</a>
					<a class="permalink" href="index.html#MakeMap.Type">&#xb6;</a>
					
					
				</h3>
				<pre>func (v *<a href="index.html#MakeMap">MakeMap</a>) Type() <a href="http://localhost:6060/pkg/go/types/">types</a>.<a href="http://localhost:6060/pkg/go/types/#Type">Type</a></pre>
				
				
				
				
			
		
			
			
			<h2 id="MakeSlice">type <a href="http://localhost:6060/src/golang.org/x/tools/go/ssa/ssa.go?s=26275:26332#L733">MakeSlice</a>
				<a class="permalink" href="index.html#MakeSlice">&#xb6;</a>
				
				
			</h2>
			<p>
The MakeSlice instruction yields a slice of length Len backed by a
newly allocated array of length Cap.
</p>
<p>
Both Len and Cap must be non-nil Values of integer type.
</p>
<p>
(Alloc(types.Array) followed by Slice will not suffice because
Alloc can only create arrays of constant length.)
</p>
<p>
Type() returns a (possibly named) *types.Slice.
</p>
<p>
Pos() returns the ast.CallExpr.Lparen for the make([]T) that
created it.
</p>
<p>
Example printed form:
</p>
<pre>t1 = make []string 1:int t0
t1 = make StringSlice 1:int t0
</pre>

			<pre>type MakeSlice struct {
<span id="MakeSlice.Len"></span>    Len <a href="index.html#Value">Value</a>
<span id="MakeSlice.Cap"></span>    Cap <a href="index.html#Value">Value</a>
    <span class="comment">// contains filtered or unexported fields</span>
}
</pre>

			

			

			
			
			

			

			
				
				<h3 id="MakeSlice.Name">func (*MakeSlice) <a href="http://localhost:6060/src/golang.org/x/tools/go/ssa/ssa.go?s=49432:49464#L1442">Name</a>
					<a class="permalink" href="index.html#MakeSlice.Name">&#xb6;</a>
					
					
				</h3>
				<pre>func (v *<a href="index.html#MakeSlice">MakeSlice</a>) Name() <a href="http://localhost:6060/pkg/builtin/#string">string</a></pre>
				
				
				
				
			
				
				<h3 id="MakeSlice.Operands">func (*MakeSlice) <a href="http://localhost:6060/src/golang.org/x/tools/go/ssa/ssa.go?s=54867:54920#L1614">Operands</a>
					<a class="permalink" href="index.html#MakeSlice.Operands">&#xb6;</a>
					
					
				</h3>
				<pre>func (v *<a href="index.html#MakeSlice">MakeSlice</a>) Operands(rands []*<a href="index.html#Value">Value</a>) []*<a href="index.html#Value">Value</a></pre>
				
				
				
				
			
				
				<h3 id="MakeSlice.Pos">func (*MakeSlice) <a href="http://localhost:6060/src/golang.org/x/tools/go/ssa/ssa.go?s=49647:49681#L1445">Pos</a>
					<a class="permalink" href="index.html#MakeSlice.Pos">&#xb6;</a>
					
					
				</h3>
				<pre>func (v *<a href="index.html#MakeSlice">MakeSlice</a>) Pos() <a href="http://localhost:6060/pkg/go/token/">token</a>.<a href="http://localhost:6060/pkg/go/token/#Pos">Pos</a></pre>
				
				
				
				
			
				
				<h3 id="MakeSlice.Referrers">func (*MakeSlice) <a href="http://localhost:6060/src/golang.org/x/tools/go/ssa/ssa.go?s=49577:49622#L1444">Referrers</a>
					<a class="permalink" href="index.html#MakeSlice.Referrers">&#xb6;</a>
					
					
				</h3>
				<pre>func (v *<a href="index.html#MakeSlice">MakeSlice</a>) Referrers() *[]<a href="index.html#Instruction">Instruction</a></pre>
				
				
				
				
			
				
				<h3 id="MakeSlice.String">func (*MakeSlice) <a href="http://localhost:6060/src/golang.org/x/tools/go/ssa/print.go?s=4361:4396#L173">String</a>
					<a class="permalink" href="index.html#MakeSlice.String">&#xb6;</a>
					
					
				</h3>
				<pre>func (v *<a href="index.html#MakeSlice">MakeSlice</a>) String() <a href="http://localhost:6060/pkg/builtin/#string">string</a></pre>
				
				
				
				
			
				
				<h3 id="MakeSlice.Type">func (*MakeSlice) <a href="http://localhost:6060/src/golang.org/x/tools/go/ssa/ssa.go?s=49307:49343#L1440">Type</a>
					<a class="permalink" href="index.html#MakeSlice.Type">&#xb6;</a>
					
					
				</h3>
				<pre>func (v *<a href="index.html#MakeSlice">MakeSlice</a>) Type() <a href="http://localhost:6060/pkg/go/types/">types</a>.<a href="http://localhost:6060/pkg/go/types/#Type">Type</a></pre>
				
				
				
				
			
		
			
			
			<h2 id="MapUpdate">type <a href="http://localhost:6060/src/golang.org/x/tools/go/ssa/ssa.go?s=39162:39258#L1182">MapUpdate</a>
				<a class="permalink" href="index.html#MapUpdate">&#xb6;</a>
				
				
			</h2>
			<p>
The MapUpdate instruction updates the association of Map[Key] to
Value.
</p>
<p>
Pos() returns the ast.KeyValueExpr.Colon or ast.IndexExpr.Lbrack,
if explicit in the source.
</p>
<p>
Example printed form:
</p>
<pre>t0[t1] = t2
</pre>

			<pre>type MapUpdate struct {
<span id="MapUpdate.Map"></span>    Map   <a href="index.html#Value">Value</a>
<span id="MapUpdate.Key"></span>    Key   <a href="index.html#Value">Value</a>
<span id="MapUpdate.Value"></span>    Value <a href="index.html#Value">Value</a>
    <span class="comment">// contains filtered or unexported fields</span>
}
</pre>

			

			

			
			
			

			

			
				
				<h3 id="MapUpdate.Block">func (*MapUpdate) <a href="http://localhost:6060/src/golang.org/x/tools/go/ssa/ssa.go?s=49851:49894#L1449">Block</a>
					<a class="permalink" href="index.html#MapUpdate.Block">&#xb6;</a>
					
					
				</h3>
				<pre>func (v *<a href="index.html#MapUpdate">MapUpdate</a>) Block() *<a href="index.html#BasicBlock">BasicBlock</a></pre>
				
				
				
				
			
				
				<h3 id="MapUpdate.Operands">func (*MapUpdate) <a href="http://localhost:6060/src/golang.org/x/tools/go/ssa/ssa.go?s=54964:55017#L1618">Operands</a>
					<a class="permalink" href="index.html#MapUpdate.Operands">&#xb6;</a>
					
					
				</h3>
				<pre>func (v *<a href="index.html#MapUpdate">MapUpdate</a>) Operands(rands []*<a href="index.html#Value">Value</a>) []*<a href="index.html#Value">Value</a></pre>
				
				
				
				
			
				
				<h3 id="MapUpdate.Parent">func (*MapUpdate) <a href="http://localhost:6060/src/golang.org/x/tools/go/ssa/ssa.go?s=49773:49815#L1448">Parent</a>
					<a class="permalink" href="index.html#MapUpdate.Parent">&#xb6;</a>
					
					
				</h3>
				<pre>func (v *<a href="index.html#MapUpdate">MapUpdate</a>) Parent() *<a href="index.html#Function">Function</a></pre>
				
				
				
				
			
				
				<h3 id="MapUpdate.Pos">func (*MapUpdate) <a href="http://localhost:6060/src/golang.org/x/tools/go/ssa/ssa.go?s=52275:52310#L1506">Pos</a>
					<a class="permalink" href="index.html#MapUpdate.Pos">&#xb6;</a>
					
					
				</h3>
				<pre>func (s *<a href="index.html#MapUpdate">MapUpdate</a>) Pos() <a href="http://localhost:6060/pkg/go/token/">token</a>.<a href="http://localhost:6060/pkg/go/token/#Pos">Pos</a></pre>
				
				
				
				
			
				
				<h3 id="MapUpdate.Referrers">func (*MapUpdate) <a href="http://localhost:6060/src/golang.org/x/tools/go/ssa/ssa.go?s=49994:50044#L1451">Referrers</a>
					<a class="permalink" href="index.html#MapUpdate.Referrers">&#xb6;</a>
					
					
				</h3>
				<pre>func (v *<a href="index.html#MapUpdate">MapUpdate</a>) Referrers() *[]<a href="index.html#Instruction">Instruction</a></pre>
				
				
				
				
			
				
				<h3 id="MapUpdate.String">func (*MapUpdate) <a href="http://localhost:6060/src/golang.org/x/tools/go/ssa/print.go?s=8306:8341#L343">String</a>
					<a class="permalink" href="index.html#MapUpdate.String">&#xb6;</a>
					
					
				</h3>
				<pre>func (s *<a href="index.html#MapUpdate">MapUpdate</a>) String() <a href="http://localhost:6060/pkg/builtin/#string">string</a></pre>
				
				
				
				
			
		
			
			
			<h2 id="Member">type <a href="http://localhost:6060/src/golang.org/x/tools/go/ssa/ssa.go?s=2800:3415#L56">Member</a>
				<a class="permalink" href="index.html#Member">&#xb6;</a>
				
				
			</h2>
			<p>
A Member is a member of a Go package, implemented by *NamedConst,
*Global, *Function, or *Type; they are created by package-level
const, var, func and type declarations respectively.
</p>

			<pre>type Member interface {
    Name() <a href="http://localhost:6060/pkg/builtin/#string">string</a>                    <span class="comment">// declared name of the package member</span>
    String() <a href="http://localhost:6060/pkg/builtin/#string">string</a>                  <span class="comment">// package-qualified name of the package member</span>
    RelString(*<a href="http://localhost:6060/pkg/go/types/">types</a>.<a href="http://localhost:6060/pkg/go/types/#Package">Package</a>) <a href="http://localhost:6060/pkg/builtin/#string">string</a> <span class="comment">// like String, but relative refs are unqualified</span>
    Object() <a href="http://localhost:6060/pkg/go/types/">types</a>.<a href="http://localhost:6060/pkg/go/types/#Object">Object</a>            <span class="comment">// typechecker&#39;s object for this member, if any</span>
    Pos() <a href="http://localhost:6060/pkg/go/token/">token</a>.<a href="http://localhost:6060/pkg/go/token/#Pos">Pos</a>                  <span class="comment">// position of member&#39;s declaration, if known</span>
    Type() <a href="http://localhost:6060/pkg/go/types/">types</a>.<a href="http://localhost:6060/pkg/go/types/#Type">Type</a>                <span class="comment">// type of the package member</span>
    Token() <a href="http://localhost:6060/pkg/go/token/">token</a>.<a href="http://localhost:6060/pkg/go/token/#Token">Token</a>              <span class="comment">// token.{VAR,FUNC,CONST,TYPE}</span>
    Package() *<a href="index.html#Package">Package</a>               <span class="comment">// the containing package</span>
}</pre>

			

			

			
			
			

			

			
		
			
			
			<h2 id="NamedConst">type <a href="http://localhost:6060/src/golang.org/x/tools/go/ssa/ssa.go?s=3881:3960#L82">NamedConst</a>
				<a class="permalink" href="index.html#NamedConst">&#xb6;</a>
				
				
			</h2>
			<p>
A NamedConst is a Member of a Package representing a package-level
named constant.
</p>
<p>
Pos() returns the position of the declaring ast.ValueSpec.Names[*]
identifier.
</p>
<p>
NB: a NamedConst is not a Value; it contains a constant Value, which
it augments with the name and position of its &#39;const&#39; declaration.
</p>

			<pre>type NamedConst struct {
<span id="NamedConst.Value"></span>    Value *<a href="index.html#Const">Const</a>
    <span class="comment">// contains filtered or unexported fields</span>
}
</pre>

			

			

			
			
			

			

			
				
				<h3 id="NamedConst.Name">func (*NamedConst) <a href="http://localhost:6060/src/golang.org/x/tools/go/ssa/ssa.go?s=50684:50718#L1462">Name</a>
					<a class="permalink" href="index.html#NamedConst.Name">&#xb6;</a>
					
					
				</h3>
				<pre>func (c *<a href="index.html#NamedConst">NamedConst</a>) Name() <a href="http://localhost:6060/pkg/builtin/#string">string</a></pre>
				
				
				
				
			
				
				<h3 id="NamedConst.Object">func (*NamedConst) <a href="http://localhost:6060/src/golang.org/x/tools/go/ssa/ssa.go?s=51110:51152#L1467">Object</a>
					<a class="permalink" href="index.html#NamedConst.Object">&#xb6;</a>
					
					
				</h3>
				<pre>func (c *<a href="index.html#NamedConst">NamedConst</a>) Object() <a href="http://localhost:6060/pkg/go/types/">types</a>.<a href="http://localhost:6060/pkg/go/types/#Object">Object</a></pre>
				
				
				
				
			
				
				<h3 id="NamedConst.Package">func (*NamedConst) <a href="http://localhost:6060/src/golang.org/x/tools/go/ssa/ssa.go?s=51189:51228#L1468">Package</a>
					<a class="permalink" href="index.html#NamedConst.Package">&#xb6;</a>
					
					
				</h3>
				<pre>func (c *<a href="index.html#NamedConst">NamedConst</a>) Package() *<a href="index.html#Package">Package</a></pre>
				
				
				
				
			
				
				<h3 id="NamedConst.Pos">func (*NamedConst) <a href="http://localhost:6060/src/golang.org/x/tools/go/ssa/ssa.go?s=50770:50806#L1463">Pos</a>
					<a class="permalink" href="index.html#NamedConst.Pos">&#xb6;</a>
					
					
				</h3>
				<pre>func (c *<a href="index.html#NamedConst">NamedConst</a>) Pos() <a href="http://localhost:6060/pkg/go/token/">token</a>.<a href="http://localhost:6060/pkg/go/token/#Pos">Pos</a></pre>
				
				
				
				
			
				
				<h3 id="NamedConst.RelString">func (*NamedConst) <a href="http://localhost:6060/src/golang.org/x/tools/go/ssa/ssa.go?s=51265:51323#L1469">RelString</a>
					<a class="permalink" href="index.html#NamedConst.RelString">&#xb6;</a>
					
					
				</h3>
				<pre>func (c *<a href="index.html#NamedConst">NamedConst</a>) RelString(from *<a href="http://localhost:6060/pkg/go/types/">types</a>.<a href="http://localhost:6060/pkg/go/types/#Package">Package</a>) <a href="http://localhost:6060/pkg/builtin/#string">string</a></pre>
				
				
				
				
			
				
				<h3 id="NamedConst.String">func (*NamedConst) <a href="http://localhost:6060/src/golang.org/x/tools/go/ssa/ssa.go?s=50855:50891#L1464">String</a>
					<a class="permalink" href="index.html#NamedConst.String">&#xb6;</a>
					
					
				</h3>
				<pre>func (c *<a href="index.html#NamedConst">NamedConst</a>) String() <a href="http://localhost:6060/pkg/builtin/#string">string</a></pre>
				
				
				
				
			
				
				<h3 id="NamedConst.Token">func (*NamedConst) <a href="http://localhost:6060/src/golang.org/x/tools/go/ssa/ssa.go?s=51028:51068#L1466">Token</a>
					<a class="permalink" href="index.html#NamedConst.Token">&#xb6;</a>
					
					
				</h3>
				<pre>func (c *<a href="index.html#NamedConst">NamedConst</a>) Token() <a href="http://localhost:6060/pkg/go/token/">token</a>.<a href="http://localhost:6060/pkg/go/token/#Token">Token</a></pre>
				
				
				
				
			
				
				<h3 id="NamedConst.Type">func (*NamedConst) <a href="http://localhost:6060/src/golang.org/x/tools/go/ssa/ssa.go?s=50942:50980#L1465">Type</a>
					<a class="permalink" href="index.html#NamedConst.Type">&#xb6;</a>
					
					
				</h3>
				<pre>func (c *<a href="index.html#NamedConst">NamedConst</a>) Type() <a href="http://localhost:6060/pkg/go/types/">types</a>.<a href="http://localhost:6060/pkg/go/types/#Type">Type</a></pre>
				
				
				
				
			
		
			
			
			<h2 id="Next">type <a href="http://localhost:6060/src/golang.org/x/tools/go/ssa/ssa.go?s=32837:32949#L946">Next</a>
				<a class="permalink" href="index.html#Next">&#xb6;</a>
				
				
			</h2>
			<p>
The Next instruction reads and advances the (map or string)
iterator Iter and returns a 3-tuple value (ok, k, v).  If the
iterator is not exhausted, ok is true and k and v are the next
elements of the domain and range, respectively.  Otherwise ok is
false and k and v are undefined.
</p>
<p>
Components of the tuple are accessed using Extract.
</p>
<p>
The IsString field distinguishes iterators over strings from those
over maps, as the Type() alone is insufficient: consider
map[int]rune.
</p>
<p>
Type() returns a *types.Tuple for the triple (ok, k, v).
The types of k and/or v may be types.Invalid.
</p>
<p>
Example printed form:
</p>
<pre>t1 = next t0
</pre>

			<pre>type Next struct {
<span id="Next.Iter"></span>    Iter     <a href="index.html#Value">Value</a>
<span id="Next.IsString"></span>    IsString <a href="http://localhost:6060/pkg/builtin/#bool">bool</a> <span class="comment">// true =&gt; string iterator; false =&gt; map iterator.</span>
    <span class="comment">// contains filtered or unexported fields</span>
}
</pre>

			

			

			
			
			

			

			
				
				<h3 id="Next.Name">func (*Next) <a href="http://localhost:6060/src/golang.org/x/tools/go/ssa/ssa.go?s=49432:49464#L1442">Name</a>
					<a class="permalink" href="index.html#Next.Name">&#xb6;</a>
					
					
				</h3>
				<pre>func (v *<a href="index.html#Next">Next</a>) Name() <a href="http://localhost:6060/pkg/builtin/#string">string</a></pre>
				
				
				
				
			
				
				<h3 id="Next.Operands">func (*Next) <a href="http://localhost:6060/src/golang.org/x/tools/go/ssa/ssa.go?s=55071:55119#L1622">Operands</a>
					<a class="permalink" href="index.html#Next.Operands">&#xb6;</a>
					
					
				</h3>
				<pre>func (v *<a href="index.html#Next">Next</a>) Operands(rands []*<a href="index.html#Value">Value</a>) []*<a href="index.html#Value">Value</a></pre>
				
				
				
				
			
				
				<h3 id="Next.Pos">func (*Next) <a href="http://localhost:6060/src/golang.org/x/tools/go/ssa/ssa.go?s=49647:49681#L1445">Pos</a>
					<a class="permalink" href="index.html#Next.Pos">&#xb6;</a>
					
					
				</h3>
				<pre>func (v *<a href="index.html#Next">Next</a>) Pos() <a href="http://localhost:6060/pkg/go/token/">token</a>.<a href="http://localhost:6060/pkg/go/token/#Pos">Pos</a></pre>
				
				
				
				
			
				
				<h3 id="Next.Referrers">func (*Next) <a href="http://localhost:6060/src/golang.org/x/tools/go/ssa/ssa.go?s=49577:49622#L1444">Referrers</a>
					<a class="permalink" href="index.html#Next.Referrers">&#xb6;</a>
					
					
				</h3>
				<pre>func (v *<a href="index.html#Next">Next</a>) Referrers() *[]<a href="index.html#Instruction">Instruction</a></pre>
				
				
				
				
			
				
				<h3 id="Next.String">func (*Next) <a href="http://localhost:6060/src/golang.org/x/tools/go/ssa/print.go?s=6255:6285#L251">String</a>
					<a class="permalink" href="index.html#Next.String">&#xb6;</a>
					
					
				</h3>
				<pre>func (v *<a href="index.html#Next">Next</a>) String() <a href="http://localhost:6060/pkg/builtin/#string">string</a></pre>
				
				
				
				
			
				
				<h3 id="Next.Type">func (*Next) <a href="http://localhost:6060/src/golang.org/x/tools/go/ssa/ssa.go?s=49307:49343#L1440">Type</a>
					<a class="permalink" href="index.html#Next.Type">&#xb6;</a>
					
					
				</h3>
				<pre>func (v *<a href="index.html#Next">Next</a>) Type() <a href="http://localhost:6060/pkg/go/types/">types</a>.<a href="http://localhost:6060/pkg/go/types/#Type">Type</a></pre>
				
				
				
				
			
		
			
			
			<h2 id="Node">type <a href="http://localhost:6060/src/golang.org/x/tools/go/ssa/ssa.go?s=9618:9857#L235">Node</a>
				<a class="permalink" href="index.html#Node">&#xb6;</a>
				
				
			</h2>
			<p>
A Node is a node in the SSA value graph.  Every concrete type that
implements Node is also either a Value, an Instruction, or both.
</p>
<p>
Node contains the methods common to Value and Instruction, plus the
Operands and Referrers methods generalized to return nil for
non-Instructions and non-Values, respectively.
</p>
<p>
Node is provided to simplify SSA graph algorithms.  Clients should
use the more specific and informative Value or Instruction
interfaces where appropriate.
</p>

			<pre>type Node interface {
    <span class="comment">// Common methods:</span>
    String() <a href="http://localhost:6060/pkg/builtin/#string">string</a>
    Pos() <a href="http://localhost:6060/pkg/go/token/">token</a>.<a href="http://localhost:6060/pkg/go/token/#Pos">Pos</a>
    Parent() *<a href="index.html#Function">Function</a>

    <span class="comment">// Partial methods:</span>
    Operands(rands []*<a href="index.html#Value">Value</a>) []*<a href="index.html#Value">Value</a> <span class="comment">// nil for non-Instructions</span>
    Referrers() *[]<a href="index.html#Instruction">Instruction</a>        <span class="comment">// nil for non-Values</span>
}</pre>

			

			

			
			
			

			

			
		
			
			
			<h2 id="Package">type <a href="http://localhost:6060/src/golang.org/x/tools/go/ssa/ssa.go?s=1832:2603#L36">Package</a>
				<a class="permalink" href="index.html#Package">&#xb6;</a>
				
				
			</h2>
			<p>
A Package is a single analyzed Go package containing Members for
all package-level functions, variables, constants and types it
declares.  These may be accessed directly via Members, or via the
type-specific accessor methods Func, Type, Var and Const.
</p>
<p>
Members also contains entries for &#34;init&#34; (the synthetic package
initializer) and &#34;init#%d&#34;, the nth declared init function,
and unspecified other things too.
</p>

			<pre>type Package struct {
<span id="Package.Prog"></span>    Prog    *<a href="index.html#Program">Program</a>          <span class="comment">// the owning program</span>
<span id="Package.Pkg"></span>    Pkg     *<a href="http://localhost:6060/pkg/go/types/">types</a>.<a href="http://localhost:6060/pkg/go/types/#Package">Package</a>    <span class="comment">// the corresponding go/types.Package</span>
<span id="Package.Members"></span>    Members map[<a href="http://localhost:6060/pkg/builtin/#string">string</a>]<a href="index.html#Member">Member</a> <span class="comment">// all package members keyed by name (incl. init and init#%d)</span>
    <span class="comment">// contains filtered or unexported fields</span>
}
</pre>

			

			

			
			
			

			

			
				
				<h3 id="Package.Build">func (*Package) <a href="http://localhost:6060/src/golang.org/x/tools/go/ssa/builder.go?s=60419:60444#L2250">Build</a>
					<a class="permalink" href="index.html#Package.Build">&#xb6;</a>
					
					
				</h3>
				<pre>func (p *<a href="index.html#Package">Package</a>) Build()</pre>
				<p>
Build builds SSA code for all functions and vars in package p.
</p>
<p>
Precondition: CreatePackage must have been called for all of p&#39;s
direct imports (and hence its direct imports must have been
error-free).
</p>
<p>
Build is idempotent and thread-safe.
</p>

				
				
				
			
				
				<h3 id="Package.Const">func (*Package) <a href="http://localhost:6060/src/golang.org/x/tools/go/ssa/ssa.go?s=51827:51879#L1490">Const</a>
					<a class="permalink" href="index.html#Package.Const">&#xb6;</a>
					
					
				</h3>
				<pre>func (p *<a href="index.html#Package">Package</a>) Const(name <a href="http://localhost:6060/pkg/builtin/#string">string</a>) (c *<a href="index.html#NamedConst">NamedConst</a>)</pre>
				<p>
Const returns the package-level constant of the specified name,
or nil if not found.
</p>

				
				
				
			
				
				<h3 id="Package.Func">func (*Package) <a href="http://localhost:6060/src/golang.org/x/tools/go/ssa/ssa.go?s=51448:51497#L1474">Func</a>
					<a class="permalink" href="index.html#Package.Func">&#xb6;</a>
					
					
				</h3>
				<pre>func (p *<a href="index.html#Package">Package</a>) Func(name <a href="http://localhost:6060/pkg/builtin/#string">string</a>) (f *<a href="index.html#Function">Function</a>)</pre>
				<p>
Func returns the package-level function of the specified name,
or nil if not found.
</p>

				
				
				
			
				
				<h3 id="Package.SetDebugMode">func (*Package) <a href="http://localhost:6060/src/golang.org/x/tools/go/ssa/func.go?s=9274:9318#L367">SetDebugMode</a>
					<a class="permalink" href="index.html#Package.SetDebugMode">&#xb6;</a>
					
					
				</h3>
				<pre>func (pkg *<a href="index.html#Package">Package</a>) SetDebugMode(debug <a href="http://localhost:6060/pkg/builtin/#bool">bool</a>)</pre>
				<p>
SetDebugMode sets the debug mode for package pkg.  If true, all its
functions will include full debug info.  This greatly increases the
size of the instruction stream, and causes Functions to depend upon
the ASTs, potentially keeping them live in memory for longer.
</p>

				
				
				
			
				
				<h3 id="Package.String">func (*Package) <a href="http://localhost:6060/src/golang.org/x/tools/go/ssa/print.go?s=8825:8858#L362">String</a>
					<a class="permalink" href="index.html#Package.String">&#xb6;</a>
					
					
				</h3>
				<pre>func (p *<a href="index.html#Package">Package</a>) String() <a href="http://localhost:6060/pkg/builtin/#string">string</a></pre>
				
				
				
				
			
				
				<h3 id="Package.Type">func (*Package) <a href="http://localhost:6060/src/golang.org/x/tools/go/ssa/ssa.go?s=52020:52065#L1498">Type</a>
					<a class="permalink" href="index.html#Package.Type">&#xb6;</a>
					
					
				</h3>
				<pre>func (p *<a href="index.html#Package">Package</a>) Type(name <a href="http://localhost:6060/pkg/builtin/#string">string</a>) (t *<a href="index.html#Type">Type</a>)</pre>
				<p>
Type returns the package-level type of the specified name,
or nil if not found.
</p>

				
				
				
			
				
				<h3 id="Package.Var">func (*Package) <a href="http://localhost:6060/src/golang.org/x/tools/go/ssa/ssa.go?s=51639:51685#L1482">Var</a>
					<a class="permalink" href="index.html#Package.Var">&#xb6;</a>
					
					
				</h3>
				<pre>func (p *<a href="index.html#Package">Package</a>) Var(name <a href="http://localhost:6060/pkg/builtin/#string">string</a>) (g *<a href="index.html#Global">Global</a>)</pre>
				<p>
Var returns the package-level variable of the specified name,
or nil if not found.
</p>

				
				
				
			
				
				<h3 id="Package.WriteTo">func (*Package) <a href="http://localhost:6060/src/golang.org/x/tools/go/ssa/print.go?s=8968:9021#L368">WriteTo</a>
					<a class="permalink" href="index.html#Package.WriteTo">&#xb6;</a>
					
					
				</h3>
				<pre>func (p *<a href="index.html#Package">Package</a>) WriteTo(w <a href="http://localhost:6060/pkg/io/">io</a>.<a href="http://localhost:6060/pkg/io/#Writer">Writer</a>) (<a href="http://localhost:6060/pkg/builtin/#int64">int64</a>, <a href="http://localhost:6060/pkg/builtin/#error">error</a>)</pre>
				
				
				
				
			
		
			
			
			<h2 id="Panic">type <a href="http://localhost:6060/src/golang.org/x/tools/go/ssa/ssa.go?s=37371:37451#L1100">Panic</a>
				<a class="permalink" href="index.html#Panic">&#xb6;</a>
				
				
			</h2>
			<p>
The Panic instruction initiates a panic with value X.
</p>
<p>
A Panic instruction must be the last instruction of its containing
BasicBlock, which must have no successors.
</p>
<p>
NB: &#39;go panic(x)&#39; and &#39;defer panic(x)&#39; do not use this instruction;
they are treated as calls to a built-in function.
</p>
<p>
Pos() returns the ast.CallExpr.Lparen if this panic was explicit
in the source.
</p>
<p>
Example printed form:
</p>
<pre>panic t0
</pre>

			<pre>type Panic struct {
<span id="Panic.X"></span>    X <a href="index.html#Value">Value</a> <span class="comment">// an interface{}</span>
    <span class="comment">// contains filtered or unexported fields</span>
}
</pre>

			

			

			
			
			

			

			
				
				<h3 id="Panic.Block">func (*Panic) <a href="http://localhost:6060/src/golang.org/x/tools/go/ssa/ssa.go?s=49851:49894#L1449">Block</a>
					<a class="permalink" href="index.html#Panic.Block">&#xb6;</a>
					
					
				</h3>
				<pre>func (v *<a href="index.html#Panic">Panic</a>) Block() *<a href="index.html#BasicBlock">BasicBlock</a></pre>
				
				
				
				
			
				
				<h3 id="Panic.Operands">func (*Panic) <a href="http://localhost:6060/src/golang.org/x/tools/go/ssa/ssa.go?s=55156:55205#L1626">Operands</a>
					<a class="permalink" href="index.html#Panic.Operands">&#xb6;</a>
					
					
				</h3>
				<pre>func (s *<a href="index.html#Panic">Panic</a>) Operands(rands []*<a href="index.html#Value">Value</a>) []*<a href="index.html#Value">Value</a></pre>
				
				
				
				
			
				
				<h3 id="Panic.Parent">func (*Panic) <a href="http://localhost:6060/src/golang.org/x/tools/go/ssa/ssa.go?s=49773:49815#L1448">Parent</a>
					<a class="permalink" href="index.html#Panic.Parent">&#xb6;</a>
					
					
				</h3>
				<pre>func (v *<a href="index.html#Panic">Panic</a>) Parent() *<a href="index.html#Function">Function</a></pre>
				
				
				
				
			
				
				<h3 id="Panic.Pos">func (*Panic) <a href="http://localhost:6060/src/golang.org/x/tools/go/ssa/ssa.go?s=52328:52359#L1507">Pos</a>
					<a class="permalink" href="index.html#Panic.Pos">&#xb6;</a>
					
					
				</h3>
				<pre>func (s *<a href="index.html#Panic">Panic</a>) Pos() <a href="http://localhost:6060/pkg/go/token/">token</a>.<a href="http://localhost:6060/pkg/go/token/#Pos">Pos</a></pre>
				
				
				
				
			
				
				<h3 id="Panic.Referrers">func (*Panic) <a href="http://localhost:6060/src/golang.org/x/tools/go/ssa/ssa.go?s=49994:50044#L1451">Referrers</a>
					<a class="permalink" href="index.html#Panic.Referrers">&#xb6;</a>
					
					
				</h3>
				<pre>func (v *<a href="index.html#Panic">Panic</a>) Referrers() *[]<a href="index.html#Instruction">Instruction</a></pre>
				
				
				
				
			
				
				<h3 id="Panic.String">func (*Panic) <a href="http://localhost:6060/src/golang.org/x/tools/go/ssa/print.go?s=7191:7222#L287">String</a>
					<a class="permalink" href="index.html#Panic.String">&#xb6;</a>
					
					
				</h3>
				<pre>func (s *<a href="index.html#Panic">Panic</a>) String() <a href="http://localhost:6060/pkg/builtin/#string">string</a></pre>
				
				
				
				
			
		
			
			
			<h2 id="Parameter">type <a href="http://localhost:6060/src/golang.org/x/tools/go/ssa/ssa.go?s=15615:15814#L378">Parameter</a>
				<a class="permalink" href="index.html#Parameter">&#xb6;</a>
				
				
			</h2>
			<p>
A Parameter represents an input parameter of a function.
</p>

			<pre>type Parameter struct {
    <span class="comment">// contains filtered or unexported fields</span>
}
</pre>

			

			

			
			
			

			

			
				
				<h3 id="Parameter.Name">func (*Parameter) <a href="http://localhost:6060/src/golang.org/x/tools/go/ssa/ssa.go?s=48784:48817#L1430">Name</a>
					<a class="permalink" href="index.html#Parameter.Name">&#xb6;</a>
					
					
				</h3>
				<pre>func (v *<a href="index.html#Parameter">Parameter</a>) Name() <a href="http://localhost:6060/pkg/builtin/#string">string</a></pre>
				
				
				
				
			
				
				<h3 id="Parameter.Object">func (*Parameter) <a href="http://localhost:6060/src/golang.org/x/tools/go/ssa/ssa.go?s=48849:48890#L1431">Object</a>
					<a class="permalink" href="index.html#Parameter.Object">&#xb6;</a>
					
					
				</h3>
				<pre>func (v *<a href="index.html#Parameter">Parameter</a>) Object() <a href="http://localhost:6060/pkg/go/types/">types</a>.<a href="http://localhost:6060/pkg/go/types/#Object">Object</a></pre>
				
				
				
				
			
				
				<h3 id="Parameter.Operands">func (*Parameter) <a href="http://localhost:6060/src/golang.org/x/tools/go/ssa/ssa.go?s=56673:56726#L1685">Operands</a>
					<a class="permalink" href="index.html#Parameter.Operands">&#xb6;</a>
					
					
				</h3>
				<pre>func (v *<a href="index.html#Parameter">Parameter</a>) Operands(rands []*<a href="index.html#Value">Value</a>) []*<a href="index.html#Value">Value</a></pre>
				
				
				
				
			
				
				<h3 id="Parameter.Parent">func (*Parameter) <a href="http://localhost:6060/src/golang.org/x/tools/go/ssa/ssa.go?s=49051:49089#L1434">Parent</a>
					<a class="permalink" href="index.html#Parameter.Parent">&#xb6;</a>
					
					
				</h3>
				<pre>func (v *<a href="index.html#Parameter">Parameter</a>) Parent() *<a href="index.html#Function">Function</a></pre>
				
				
				
				
			
				
				<h3 id="Parameter.Pos">func (*Parameter) <a href="http://localhost:6060/src/golang.org/x/tools/go/ssa/ssa.go?s=48987:49022#L1433">Pos</a>
					<a class="permalink" href="index.html#Parameter.Pos">&#xb6;</a>
					
					
				</h3>
				<pre>func (v *<a href="index.html#Parameter">Parameter</a>) Pos() <a href="http://localhost:6060/pkg/go/token/">token</a>.<a href="http://localhost:6060/pkg/go/token/#Pos">Pos</a></pre>
				
				
				
				
			
				
				<h3 id="Parameter.Referrers">func (*Parameter) <a href="http://localhost:6060/src/golang.org/x/tools/go/ssa/ssa.go?s=48916:48962#L1432">Referrers</a>
					<a class="permalink" href="index.html#Parameter.Referrers">&#xb6;</a>
					
					
				</h3>
				<pre>func (v *<a href="index.html#Parameter">Parameter</a>) Referrers() *[]<a href="index.html#Instruction">Instruction</a></pre>
				
				
				
				
			
				
				<h3 id="Parameter.String">func (*Parameter) <a href="http://localhost:6060/src/golang.org/x/tools/go/ssa/print.go?s=1455:1490#L49">String</a>
					<a class="permalink" href="index.html#Parameter.String">&#xb6;</a>
					
					
				</h3>
				<pre>func (v *<a href="index.html#Parameter">Parameter</a>) String() <a href="http://localhost:6060/pkg/builtin/#string">string</a></pre>
				
				
				
				
			
				
				<h3 id="Parameter.Type">func (*Parameter) <a href="http://localhost:6060/src/golang.org/x/tools/go/ssa/ssa.go?s=48720:48757#L1429">Type</a>
					<a class="permalink" href="index.html#Parameter.Type">&#xb6;</a>
					
					
				</h3>
				<pre>func (v *<a href="index.html#Parameter">Parameter</a>) Type() <a href="http://localhost:6060/pkg/go/types/">types</a>.<a href="http://localhost:6060/pkg/go/types/#Type">Type</a></pre>
				
				
				
				
			
		
			
			
			<h2 id="Phi">type <a href="http://localhost:6060/src/golang.org/x/tools/go/ssa/ssa.go?s=19524:19657#L502">Phi</a>
				<a class="permalink" href="index.html#Phi">&#xb6;</a>
				
				
			</h2>
			<p>
The Phi instruction represents an SSA φ-node, which combines values
that differ across incoming control-flow edges and yields a new
value.  Within a block, all φ-nodes must appear before all non-φ
nodes.
</p>
<p>
Pos() returns the position of the &amp;&amp; or || for short-circuit
control-flow joins, or that of the *Alloc for φ-nodes inserted
during SSA renaming.
</p>
<p>
Example printed form:
</p>
<pre>t2 = phi [0: t0, 1: t1]
</pre>

			<pre>type Phi struct {
<span id="Phi.Comment"></span>    Comment <a href="http://localhost:6060/pkg/builtin/#string">string</a>  <span class="comment">// a hint as to its purpose</span>
<span id="Phi.Edges"></span>    Edges   []<a href="index.html#Value">Value</a> <span class="comment">// Edges[i] is value for Block().Preds[i]</span>
    <span class="comment">// contains filtered or unexported fields</span>
}
</pre>

			

			

			
			
			

			

			
				
				<h3 id="Phi.Name">func (*Phi) <a href="http://localhost:6060/src/golang.org/x/tools/go/ssa/ssa.go?s=49432:49464#L1442">Name</a>
					<a class="permalink" href="index.html#Phi.Name">&#xb6;</a>
					
					
				</h3>
				<pre>func (v *<a href="index.html#Phi">Phi</a>) Name() <a href="http://localhost:6060/pkg/builtin/#string">string</a></pre>
				
				
				
				
			
				
				<h3 id="Phi.Operands">func (*Phi) <a href="http://localhost:6060/src/golang.org/x/tools/go/ssa/ssa.go?s=55239:55286#L1630">Operands</a>
					<a class="permalink" href="index.html#Phi.Operands">&#xb6;</a>
					
					
				</h3>
				<pre>func (v *<a href="index.html#Phi">Phi</a>) Operands(rands []*<a href="index.html#Value">Value</a>) []*<a href="index.html#Value">Value</a></pre>
				
				
				
				
			
				
				<h3 id="Phi.Pos">func (*Phi) <a href="http://localhost:6060/src/golang.org/x/tools/go/ssa/ssa.go?s=49647:49681#L1445">Pos</a>
					<a class="permalink" href="index.html#Phi.Pos">&#xb6;</a>
					
					
				</h3>
				<pre>func (v *<a href="index.html#Phi">Phi</a>) Pos() <a href="http://localhost:6060/pkg/go/token/">token</a>.<a href="http://localhost:6060/pkg/go/token/#Pos">Pos</a></pre>
				
				
				
				
			
				
				<h3 id="Phi.Referrers">func (*Phi) <a href="http://localhost:6060/src/golang.org/x/tools/go/ssa/ssa.go?s=49577:49622#L1444">Referrers</a>
					<a class="permalink" href="index.html#Phi.Referrers">&#xb6;</a>
					
					
				</h3>
				<pre>func (v *<a href="index.html#Phi">Phi</a>) Referrers() *[]<a href="index.html#Instruction">Instruction</a></pre>
				
				
				
				
			
				
				<h3 id="Phi.String">func (*Phi) <a href="http://localhost:6060/src/golang.org/x/tools/go/ssa/print.go?s=2033:2062#L74">String</a>
					<a class="permalink" href="index.html#Phi.String">&#xb6;</a>
					
					
				</h3>
				<pre>func (v *<a href="index.html#Phi">Phi</a>) String() <a href="http://localhost:6060/pkg/builtin/#string">string</a></pre>
				
				
				
				
			
				
				<h3 id="Phi.Type">func (*Phi) <a href="http://localhost:6060/src/golang.org/x/tools/go/ssa/ssa.go?s=49307:49343#L1440">Type</a>
					<a class="permalink" href="index.html#Phi.Type">&#xb6;</a>
					
					
				</h3>
				<pre>func (v *<a href="index.html#Phi">Phi</a>) Type() <a href="http://localhost:6060/pkg/go/types/">types</a>.<a href="http://localhost:6060/pkg/go/types/#Type">Type</a></pre>
				
				
				
				
			
		
			
			
			<h2 id="Program">type <a href="http://localhost:6060/src/golang.org/x/tools/go/ssa/ssa.go?s=490:1393#L12">Program</a>
				<a class="permalink" href="index.html#Program">&#xb6;</a>
				
				
			</h2>
			<p>
A Program is a partial or complete Go program converted to SSA form.
</p>

			<pre>type Program struct {
<span id="Program.Fset"></span>    Fset *<a href="http://localhost:6060/pkg/go/token/">token</a>.<a href="http://localhost:6060/pkg/go/token/#FileSet">FileSet</a> <span class="comment">// position information for the files of this Program</span>

<span id="Program.MethodSets"></span>    MethodSets <a href="../types/typeutil/index.html">typeutil</a>.<a href="../types/typeutil/index.html#MethodSetCache">MethodSetCache</a> <span class="comment">// cache of type-checker&#39;s method-sets</span>
    <span class="comment">// contains filtered or unexported fields</span>
}
</pre>

			

			

			
			
			

			
				
				<h3 id="NewProgram">func <a href="http://localhost:6060/src/golang.org/x/tools/go/ssa/create.go?s=493:556#L15">NewProgram</a>
					<a class="permalink" href="index.html#NewProgram">&#xb6;</a>
					
					
				</h3>
				<pre>func NewProgram(fset *<a href="http://localhost:6060/pkg/go/token/">token</a>.<a href="http://localhost:6060/pkg/go/token/#FileSet">FileSet</a>, mode <a href="index.html#BuilderMode">BuilderMode</a>) *<a href="index.html#Program">Program</a></pre>
				<p>
NewProgram returns a new SSA Program.
</p>
<p>
mode controls diagnostics and checking during SSA construction.
</p>

				
				
			

			
				
				<h3 id="Program.AllPackages">func (*Program) <a href="http://localhost:6060/src/golang.org/x/tools/go/ssa/create.go?s=5830:5875#L236">AllPackages</a>
					<a class="permalink" href="index.html#Program.AllPackages">&#xb6;</a>
					
					
				</h3>
				<pre>func (prog *<a href="index.html#Program">Program</a>) AllPackages() []*<a href="index.html#Package">Package</a></pre>
				<p>
AllPackages returns a new slice containing all packages in the
program prog in unspecified order.
</p>

				
				
				
			
				
				<h3 id="Program.Build">func (*Program) <a href="http://localhost:6060/src/golang.org/x/tools/go/ssa/builder.go?s=59913:59941#L2226">Build</a>
					<a class="permalink" href="index.html#Program.Build">&#xb6;</a>
					
					
				</h3>
				<pre>func (prog *<a href="index.html#Program">Program</a>) Build()</pre>
				<p>
Build calls Package.Build for each package in prog.
Building occurs in parallel unless the BuildSerially mode flag was set.
</p>
<p>
Build is intended for whole-program analysis; a typical compiler
need only build a single package.
</p>
<p>
Build is idempotent and thread-safe.
</p>

				
				
				
			
				
				<h3 id="Program.ConstValue">func (*Program) <a href="http://localhost:6060/src/golang.org/x/tools/go/ssa/source.go?s=6461:6517#L199">ConstValue</a>
					<a class="permalink" href="index.html#Program.ConstValue">&#xb6;</a>
					
					
				</h3>
				<pre>func (prog *<a href="index.html#Program">Program</a>) ConstValue(obj *<a href="http://localhost:6060/pkg/go/types/">types</a>.<a href="http://localhost:6060/pkg/go/types/#Const">Const</a>) *<a href="index.html#Const">Const</a></pre>
				<p>
ConstValue returns the SSA Value denoted by the source-level named
constant obj.
</p>

				
				
				
			
				
				<h3 id="Program.CreatePackage">func (*Program) <a href="http://localhost:6060/src/golang.org/x/tools/go/ssa/create.go?s=3914:4031#L155">CreatePackage</a>
					<a class="permalink" href="index.html#Program.CreatePackage">&#xb6;</a>
					
					
				</h3>
				<pre>func (prog *<a href="index.html#Program">Program</a>) CreatePackage(pkg *<a href="http://localhost:6060/pkg/go/types/">types</a>.<a href="http://localhost:6060/pkg/go/types/#Package">Package</a>, files []*<a href="http://localhost:6060/pkg/go/ast/">ast</a>.<a href="http://localhost:6060/pkg/go/ast/#File">File</a>, info *<a href="http://localhost:6060/pkg/go/types/">types</a>.<a href="http://localhost:6060/pkg/go/types/#Info">Info</a>, importable <a href="http://localhost:6060/pkg/builtin/#bool">bool</a>) *<a href="index.html#Package">Package</a></pre>
				<p>
CreatePackage constructs and returns an SSA Package from the
specified type-checked, error-free file ASTs, and populates its
Members mapping.
</p>
<p>
importable determines whether this package should be returned by a
subsequent call to ImportedPackage(pkg.Path()).
</p>
<p>
The real work of building SSA form for each function is not done
until a subsequent call to Package.Build().
</p>

				
				
				
			
				
				<h3 id="Program.CreateTestMainPackage">func (*Program) <a href="http://localhost:6060/src/golang.org/x/tools/go/ssa/testmain.go?s=4056:4121#L108">CreateTestMainPackage</a>
					<a class="permalink" href="index.html#Program.CreateTestMainPackage">&#xb6;</a>
					
					
				</h3>
				<pre>func (prog *<a href="index.html#Program">Program</a>) CreateTestMainPackage(pkg *<a href="index.html#Package">Package</a>) *<a href="index.html#Package">Package</a></pre>
				<p>
CreateTestMainPackage creates and returns a synthetic &#34;testmain&#34;
package for the specified package if it defines tests, benchmarks or
executable examples, or nil otherwise.  The new package is named
&#34;main&#34; and provides a function named &#34;main&#34; that runs the tests,
similar to the one that would be created by the &#39;go test&#39; tool.
</p>
<p>
Subsequent calls to prog.AllPackages include the new package.
The package pkg must belong to the program prog.
</p>
<p>
Deprecated: Use golang.org/x/tools/go/packages to access synthetic
testmain packages.
</p>

				
				
				
			
				
				<h3 id="Program.FuncValue">func (*Program) <a href="http://localhost:6060/src/golang.org/x/tools/go/ssa/source.go?s=6247:6304#L191">FuncValue</a>
					<a class="permalink" href="index.html#Program.FuncValue">&#xb6;</a>
					
					
				</h3>
				<pre>func (prog *<a href="index.html#Program">Program</a>) FuncValue(obj *<a href="http://localhost:6060/pkg/go/types/">types</a>.<a href="http://localhost:6060/pkg/go/types/#Func">Func</a>) *<a href="index.html#Function">Function</a></pre>
				<p>
FuncValue returns the concrete Function denoted by the source-level
named function obj, or nil if obj denotes an interface method.
</p>
<p>
TODO(adonovan): check the invariant that obj.Type() matches the
result&#39;s Signature, both in the params/results and in the receiver.
</p>

				
				
				
			
				
				<h3 id="Program.ImportedPackage">func (*Program) <a href="http://localhost:6060/src/golang.org/x/tools/go/ssa/create.go?s=6729:6787#L258">ImportedPackage</a>
					<a class="permalink" href="index.html#Program.ImportedPackage">&#xb6;</a>
					
					
				</h3>
				<pre>func (prog *<a href="index.html#Program">Program</a>) ImportedPackage(path <a href="http://localhost:6060/pkg/builtin/#string">string</a>) *<a href="index.html#Package">Package</a></pre>
				<p>
ImportedPackage returns the importable Package whose PkgPath
is path, or nil if no such Package has been created.
</p>
<p>
A parameter to CreatePackage determines whether a package should be
considered importable. For example, no import declaration can resolve
to the ad-hoc main package created by &#39;go build foo.go&#39;.
</p>
<p>
TODO(adonovan): rethink this function and the &#34;importable&#34; concept;
most packages are importable. This function assumes that all
types.Package.Path values are unique within the ssa.Program, which is
false---yet this function remains very convenient.
Clients should use (*Program).Package instead where possible.
SSA doesn&#39;t really need a string-keyed map of packages.
</p>

				
				
				
			
				
				<h3 id="Program.LookupMethod">func (*Program) <a href="http://localhost:6060/src/golang.org/x/tools/go/ssa/methods.go?s=1176:1266#L36">LookupMethod</a>
					<a class="permalink" href="index.html#Program.LookupMethod">&#xb6;</a>
					
					
				</h3>
				<pre>func (prog *<a href="index.html#Program">Program</a>) LookupMethod(T <a href="http://localhost:6060/pkg/go/types/">types</a>.<a href="http://localhost:6060/pkg/go/types/#Type">Type</a>, pkg *<a href="http://localhost:6060/pkg/go/types/">types</a>.<a href="http://localhost:6060/pkg/go/types/#Package">Package</a>, name <a href="http://localhost:6060/pkg/builtin/#string">string</a>) *<a href="index.html#Function">Function</a></pre>
				<p>
LookupMethod returns the implementation of the method of type T
identified by (pkg, name).  It returns nil if the method exists but
is abstract, and panics if T has no such method.
</p>

				
				
				
			
				
				<h3 id="Program.MethodValue">func (*Program) <a href="http://localhost:6060/src/golang.org/x/tools/go/ssa/methods.go?s=547:611#L14">MethodValue</a>
					<a class="permalink" href="index.html#Program.MethodValue">&#xb6;</a>
					
					
				</h3>
				<pre>func (prog *<a href="index.html#Program">Program</a>) MethodValue(sel *<a href="http://localhost:6060/pkg/go/types/">types</a>.<a href="http://localhost:6060/pkg/go/types/#Selection">Selection</a>) *<a href="index.html#Function">Function</a></pre>
				<p>
MethodValue returns the Function implementing method sel, building
wrapper methods on demand.  It returns nil if sel denotes an
abstract (interface) method.
</p>
<p>
Precondition: sel.Kind() == MethodVal.
</p>
<p>
Thread-safe.
</p>
<p>
EXCLUSIVE_LOCKS_ACQUIRED(prog.methodsMu)
</p>

				
				
				
			
				
				<h3 id="Program.NewFunction">func (*Program) <a href="http://localhost:6060/src/golang.org/x/tools/go/ssa/func.go?s=18167:18263#L663">NewFunction</a>
					<a class="permalink" href="index.html#Program.NewFunction">&#xb6;</a>
					
					
				</h3>
				<pre>func (prog *<a href="index.html#Program">Program</a>) NewFunction(name <a href="http://localhost:6060/pkg/builtin/#string">string</a>, sig *<a href="http://localhost:6060/pkg/go/types/">types</a>.<a href="http://localhost:6060/pkg/go/types/#Signature">Signature</a>, provenance <a href="http://localhost:6060/pkg/builtin/#string">string</a>) *<a href="index.html#Function">Function</a></pre>
				<p>
NewFunction returns a new synthetic Function instance belonging to
prog, with its name and signature fields set as specified.
</p>
<p>
The caller is responsible for initializing the remaining fields of
the function object, e.g. Pkg, Params, Blocks.
</p>
<p>
It is practically impossible for clients to construct well-formed
SSA functions/packages/programs directly, so we assume this is the
job of the Builder alone.  NewFunction exists to provide clients a
little flexibility.  For example, analysis tools may wish to
construct fake Functions for the root of the callgraph, a fake
&#34;reflect&#34; package, etc.
</p>
<p>
TODO(adonovan): think harder about the API here.
</p>

				
				
				
			
				
				<h3 id="Program.Package">func (*Program) <a href="http://localhost:6060/src/golang.org/x/tools/go/ssa/source.go?s=5464:5521#L169">Package</a>
					<a class="permalink" href="index.html#Program.Package">&#xb6;</a>
					
					
				</h3>
				<pre>func (prog *<a href="index.html#Program">Program</a>) Package(obj *<a href="http://localhost:6060/pkg/go/types/">types</a>.<a href="http://localhost:6060/pkg/go/types/#Package">Package</a>) *<a href="index.html#Package">Package</a></pre>
				<p>
Package returns the SSA Package corresponding to the specified
type-checker package object.
It returns nil if no such SSA package has been created.
</p>

				
				
				
			
				
				<h3 id="Program.RuntimeTypes">func (*Program) <a href="http://localhost:6060/src/golang.org/x/tools/go/ssa/methods.go?s=2818:2866#L94">RuntimeTypes</a>
					<a class="permalink" href="index.html#Program.RuntimeTypes">&#xb6;</a>
					
					
				</h3>
				<pre>func (prog *<a href="index.html#Program">Program</a>) RuntimeTypes() []<a href="http://localhost:6060/pkg/go/types/">types</a>.<a href="http://localhost:6060/pkg/go/types/#Type">Type</a></pre>
				<p>
RuntimeTypes returns a new unordered slice containing all
concrete types in the program for which a complete (non-empty)
method set is required at run-time.
</p>
<p>
Thread-safe.
</p>
<p>
EXCLUSIVE_LOCKS_ACQUIRED(prog.methodsMu)
</p>

				
				
				
			
				
				<h3 id="Program.VarValue">func (*Program) <a href="http://localhost:6060/src/golang.org/x/tools/go/ssa/source.go?s=8524:8626#L248">VarValue</a>
					<a class="permalink" href="index.html#Program.VarValue">&#xb6;</a>
					
					
				</h3>
				<pre>func (prog *<a href="index.html#Program">Program</a>) VarValue(obj *<a href="http://localhost:6060/pkg/go/types/">types</a>.<a href="http://localhost:6060/pkg/go/types/#Var">Var</a>, pkg *<a href="index.html#Package">Package</a>, ref []<a href="http://localhost:6060/pkg/go/ast/">ast</a>.<a href="http://localhost:6060/pkg/go/ast/#Node">Node</a>) (value <a href="index.html#Value">Value</a>, isAddr <a href="http://localhost:6060/pkg/builtin/#bool">bool</a>)</pre>
				<p>
VarValue returns the SSA Value that corresponds to a specific
identifier denoting the source-level named variable obj.
</p>
<p>
VarValue returns nil if a local variable was not found, perhaps
because its package was not built, the debug information was not
requested during SSA construction, or the value was optimized away.
</p>
<p>
ref is the path to an ast.Ident (e.g. from PathEnclosingInterval),
and that ident must resolve to obj.
</p>
<p>
pkg is the package enclosing the reference.  (A reference to a var
always occurs within a function, so we need to know where to find it.)
</p>
<p>
If the identifier is a field selector and its base expression is
non-addressable, then VarValue returns the value of that field.
For example:
</p>
<pre>func f() struct {x int}
f().x  // VarValue(x) returns a *Field instruction of type int
</pre>
<p>
All other identifiers denote addressable locations (variables).
For them, VarValue may return either the variable&#39;s address or its
value, even when the expression is evaluated only for its value; the
situation is reported by isAddr, the second component of the result.
</p>
<p>
If !isAddr, the returned value is the one associated with the
specific identifier.  For example,
</p>
<pre>var x int    // VarValue(x) returns Const 0 here
x = 1        // VarValue(x) returns Const 1 here
</pre>
<p>
It is not specified whether the value or the address is returned in
any particular case, as it may depend upon optimizations performed
during SSA code generation, such as registerization, constant
folding, avoidance of materialization of subexpressions, etc.
</p>

				
				
				
			
		
			
			
			<h2 id="Range">type <a href="http://localhost:6060/src/golang.org/x/tools/go/ssa/ssa.go?s=32112:32169#L923">Range</a>
				<a class="permalink" href="index.html#Range">&#xb6;</a>
				
				
			</h2>
			<p>
The Range instruction yields an iterator over the domain and range
of X, which must be a string or map.
</p>
<p>
Elements are accessed via Next.
</p>
<p>
Type() returns an opaque and degenerate &#34;rangeIter&#34; type.
</p>
<p>
Pos() returns the ast.RangeStmt.For.
</p>
<p>
Example printed form:
</p>
<pre>t0 = range &#34;hello&#34;:string
</pre>

			<pre>type Range struct {
<span id="Range.X"></span>    X <a href="index.html#Value">Value</a> <span class="comment">// string or map</span>
    <span class="comment">// contains filtered or unexported fields</span>
}
</pre>

			

			

			
			
			

			

			
				
				<h3 id="Range.Name">func (*Range) <a href="http://localhost:6060/src/golang.org/x/tools/go/ssa/ssa.go?s=49432:49464#L1442">Name</a>
					<a class="permalink" href="index.html#Range.Name">&#xb6;</a>
					
					
				</h3>
				<pre>func (v *<a href="index.html#Range">Range</a>) Name() <a href="http://localhost:6060/pkg/builtin/#string">string</a></pre>
				
				
				
				
			
				
				<h3 id="Range.Operands">func (*Range) <a href="http://localhost:6060/src/golang.org/x/tools/go/ssa/ssa.go?s=55372:55421#L1637">Operands</a>
					<a class="permalink" href="index.html#Range.Operands">&#xb6;</a>
					
					
				</h3>
				<pre>func (v *<a href="index.html#Range">Range</a>) Operands(rands []*<a href="index.html#Value">Value</a>) []*<a href="index.html#Value">Value</a></pre>
				
				
				
				
			
				
				<h3 id="Range.Pos">func (*Range) <a href="http://localhost:6060/src/golang.org/x/tools/go/ssa/ssa.go?s=49647:49681#L1445">Pos</a>
					<a class="permalink" href="index.html#Range.Pos">&#xb6;</a>
					
					
				</h3>
				<pre>func (v *<a href="index.html#Range">Range</a>) Pos() <a href="http://localhost:6060/pkg/go/token/">token</a>.<a href="http://localhost:6060/pkg/go/token/#Pos">Pos</a></pre>
				
				
				
				
			
				
				<h3 id="Range.Referrers">func (*Range) <a href="http://localhost:6060/src/golang.org/x/tools/go/ssa/ssa.go?s=49577:49622#L1444">Referrers</a>
					<a class="permalink" href="index.html#Range.Referrers">&#xb6;</a>
					
					
				</h3>
				<pre>func (v *<a href="index.html#Range">Range</a>) Referrers() *[]<a href="index.html#Instruction">Instruction</a></pre>
				
				
				
				
			
				
				<h3 id="Range.String">func (*Range) <a href="http://localhost:6060/src/golang.org/x/tools/go/ssa/print.go?s=6183:6214#L247">String</a>
					<a class="permalink" href="index.html#Range.String">&#xb6;</a>
					
					
				</h3>
				<pre>func (v *<a href="index.html#Range">Range</a>) String() <a href="http://localhost:6060/pkg/builtin/#string">string</a></pre>
				
				
				
				
			
				
				<h3 id="Range.Type">func (*Range) <a href="http://localhost:6060/src/golang.org/x/tools/go/ssa/ssa.go?s=49307:49343#L1440">Type</a>
					<a class="permalink" href="index.html#Range.Type">&#xb6;</a>
					
					
				</h3>
				<pre>func (v *<a href="index.html#Range">Range</a>) Type() <a href="http://localhost:6060/pkg/go/types/">types</a>.<a href="http://localhost:6060/pkg/go/types/#Type">Type</a></pre>
				
				
				
				
			
		
			
			
			<h2 id="Return">type <a href="http://localhost:6060/src/golang.org/x/tools/go/ssa/ssa.go?s=36433:36506#L1064">Return</a>
				<a class="permalink" href="index.html#Return">&#xb6;</a>
				
				
			</h2>
			<p>
The Return instruction returns values and control back to the calling
function.
</p>
<p>
len(Results) is always equal to the number of results in the
function&#39;s signature.
</p>
<p>
If len(Results) &gt; 1, Return returns a tuple value with the specified
components which the caller must access using Extract instructions.
</p>
<p>
There is no instruction to return a ready-made tuple like those
returned by a &#34;value,ok&#34;-mode TypeAssert, Lookup or UnOp(ARROW) or
a tail-call to a function with multiple result parameters.
</p>
<p>
Return must be the last instruction of its containing BasicBlock.
Such a block has no successors.
</p>
<p>
Pos() returns the ast.ReturnStmt.Return, if explicit in the source.
</p>
<p>
Example printed form:
</p>
<pre>return
return nil:I, 2:int
</pre>

			<pre>type Return struct {
<span id="Return.Results"></span>    Results []<a href="index.html#Value">Value</a>
    <span class="comment">// contains filtered or unexported fields</span>
}
</pre>

			

			

			
			
			

			

			
				
				<h3 id="Return.Block">func (*Return) <a href="http://localhost:6060/src/golang.org/x/tools/go/ssa/ssa.go?s=49851:49894#L1449">Block</a>
					<a class="permalink" href="index.html#Return.Block">&#xb6;</a>
					
					
				</h3>
				<pre>func (v *<a href="index.html#Return">Return</a>) Block() *<a href="index.html#BasicBlock">BasicBlock</a></pre>
				
				
				
				
			
				
				<h3 id="Return.Operands">func (*Return) <a href="http://localhost:6060/src/golang.org/x/tools/go/ssa/ssa.go?s=55455:55505#L1641">Operands</a>
					<a class="permalink" href="index.html#Return.Operands">&#xb6;</a>
					
					
				</h3>
				<pre>func (s *<a href="index.html#Return">Return</a>) Operands(rands []*<a href="index.html#Value">Value</a>) []*<a href="index.html#Value">Value</a></pre>
				
				
				
				
			
				
				<h3 id="Return.Parent">func (*Return) <a href="http://localhost:6060/src/golang.org/x/tools/go/ssa/ssa.go?s=49773:49815#L1448">Parent</a>
					<a class="permalink" href="index.html#Return.Parent">&#xb6;</a>
					
					
				</h3>
				<pre>func (v *<a href="index.html#Return">Return</a>) Parent() *<a href="index.html#Function">Function</a></pre>
				
				
				
				
			
				
				<h3 id="Return.Pos">func (*Return) <a href="http://localhost:6060/src/golang.org/x/tools/go/ssa/ssa.go?s=52381:52413#L1508">Pos</a>
					<a class="permalink" href="index.html#Return.Pos">&#xb6;</a>
					
					
				</h3>
				<pre>func (s *<a href="index.html#Return">Return</a>) Pos() <a href="http://localhost:6060/pkg/go/token/">token</a>.<a href="http://localhost:6060/pkg/go/token/#Pos">Pos</a></pre>
				
				
				
				
			
				
				<h3 id="Return.Referrers">func (*Return) <a href="http://localhost:6060/src/golang.org/x/tools/go/ssa/ssa.go?s=49994:50044#L1451">Referrers</a>
					<a class="permalink" href="index.html#Return.Referrers">&#xb6;</a>
					
					
				</h3>
				<pre>func (v *<a href="index.html#Return">Return</a>) Referrers() *[]<a href="index.html#Instruction">Instruction</a></pre>
				
				
				
				
			
				
				<h3 id="Return.String">func (*Return) <a href="http://localhost:6060/src/golang.org/x/tools/go/ssa/print.go?s=7263:7295#L291">String</a>
					<a class="permalink" href="index.html#Return.String">&#xb6;</a>
					
					
				</h3>
				<pre>func (s *<a href="index.html#Return">Return</a>) String() <a href="http://localhost:6060/pkg/builtin/#string">string</a></pre>
				
				
				
				
			
		
			
			
			<h2 id="RunDefers">type <a href="http://localhost:6060/src/golang.org/x/tools/go/ssa/ssa.go?s=36893:36933#L1082">RunDefers</a>
				<a class="permalink" href="index.html#RunDefers">&#xb6;</a>
				
				
			</h2>
			<p>
The RunDefers instruction pops and invokes the entire stack of
procedure calls pushed by Defer instructions in this function.
</p>
<p>
It is legal to encounter multiple &#39;rundefers&#39; instructions in a
single control-flow path through a function; this is useful in
the combined init() function, for example.
</p>
<p>
Pos() returns NoPos.
</p>
<p>
Example printed form:
</p>
<pre>rundefers
</pre>

			<pre>type RunDefers struct {
    <span class="comment">// contains filtered or unexported fields</span>
}
</pre>

			

			

			
			
			

			

			
				
				<h3 id="RunDefers.Block">func (*RunDefers) <a href="http://localhost:6060/src/golang.org/x/tools/go/ssa/ssa.go?s=49851:49894#L1449">Block</a>
					<a class="permalink" href="index.html#RunDefers.Block">&#xb6;</a>
					
					
				</h3>
				<pre>func (v *<a href="index.html#RunDefers">RunDefers</a>) Block() *<a href="index.html#BasicBlock">BasicBlock</a></pre>
				
				
				
				
			
				
				<h3 id="RunDefers.Operands">func (*RunDefers) <a href="http://localhost:6060/src/golang.org/x/tools/go/ssa/ssa.go?s=55595:55646#L1648">Operands</a>
					<a class="permalink" href="index.html#RunDefers.Operands">&#xb6;</a>
					
					
				</h3>
				<pre>func (*<a href="index.html#RunDefers">RunDefers</a>) Operands(rands []*<a href="index.html#Value">Value</a>) []*<a href="index.html#Value">Value</a></pre>
				
				
				
				
			
				
				<h3 id="RunDefers.Parent">func (*RunDefers) <a href="http://localhost:6060/src/golang.org/x/tools/go/ssa/ssa.go?s=49773:49815#L1448">Parent</a>
					<a class="permalink" href="index.html#RunDefers.Parent">&#xb6;</a>
					
					
				</h3>
				<pre>func (v *<a href="index.html#RunDefers">RunDefers</a>) Parent() *<a href="index.html#Function">Function</a></pre>
				
				
				
				
			
				
				<h3 id="RunDefers.Pos">func (*RunDefers) <a href="http://localhost:6060/src/golang.org/x/tools/go/ssa/ssa.go?s=52658:52693#L1513">Pos</a>
					<a class="permalink" href="index.html#RunDefers.Pos">&#xb6;</a>
					
					
				</h3>
				<pre>func (s *<a href="index.html#RunDefers">RunDefers</a>) Pos() <a href="http://localhost:6060/pkg/go/token/">token</a>.<a href="http://localhost:6060/pkg/go/token/#Pos">Pos</a></pre>
				
				
				
				
			
				
				<h3 id="RunDefers.Referrers">func (*RunDefers) <a href="http://localhost:6060/src/golang.org/x/tools/go/ssa/ssa.go?s=49994:50044#L1451">Referrers</a>
					<a class="permalink" href="index.html#RunDefers.Referrers">&#xb6;</a>
					
					
				</h3>
				<pre>func (v *<a href="index.html#RunDefers">RunDefers</a>) Referrers() *[]<a href="index.html#Instruction">Instruction</a></pre>
				
				
				
				
			
				
				<h3 id="RunDefers.String">func (*RunDefers) <a href="http://localhost:6060/src/golang.org/x/tools/go/ssa/print.go?s=7504:7537#L305">String</a>
					<a class="permalink" href="index.html#RunDefers.String">&#xb6;</a>
					
					
				</h3>
				<pre>func (*<a href="index.html#RunDefers">RunDefers</a>) String() <a href="http://localhost:6060/pkg/builtin/#string">string</a></pre>
				
				
				
				
			
		
			
			
			<h2 id="Select">type <a href="http://localhost:6060/src/golang.org/x/tools/go/ssa/ssa.go?s=31722:31794#L905">Select</a>
				<a class="permalink" href="index.html#Select">&#xb6;</a>
				
				
			</h2>
			<p>
The Select instruction tests whether (or blocks until) one
of the specified sent or received states is entered.
</p>
<p>
Let n be the number of States for which Dir==RECV and T_i (0&lt;=i&lt;n)
be the element type of each such state&#39;s Chan.
Select returns an n+2-tuple
</p>
<pre>(index int, recvOk bool, r_0 T_0, ... r_n-1 T_n-1)
</pre>
<p>
The tuple&#39;s components, described below, must be accessed via the
Extract instruction.
</p>
<p>
If Blocking, select waits until exactly one state holds, i.e. a
channel becomes ready for the designated operation of sending or
receiving; select chooses one among the ready states
pseudorandomly, performs the send or receive operation, and sets
&#39;index&#39; to the index of the chosen channel.
</p>
<p>
If !Blocking, select doesn&#39;t block if no states hold; instead it
returns immediately with index equal to -1.
</p>
<p>
If the chosen channel was used for a receive, the r_i component is
set to the received value, where i is the index of that state among
all n receive states; otherwise r_i has the zero value of type T_i.
Note that the receive index i is not the same as the state
index index.
</p>
<p>
The second component of the triple, recvOk, is a boolean whose value
is true iff the selected operation was a receive and the receive
successfully yielded a value.
</p>
<p>
Pos() returns the ast.SelectStmt.Select.
</p>
<p>
Example printed form:
</p>
<pre>t3 = select nonblocking [&lt;-t0, t1&lt;-t2]
t4 = select blocking []
</pre>

			<pre>type Select struct {
<span id="Select.States"></span>    States   []*<a href="index.html#SelectState">SelectState</a>
<span id="Select.Blocking"></span>    Blocking <a href="http://localhost:6060/pkg/builtin/#bool">bool</a>
    <span class="comment">// contains filtered or unexported fields</span>
}
</pre>

			

			

			
			
			

			

			
				
				<h3 id="Select.Name">func (*Select) <a href="http://localhost:6060/src/golang.org/x/tools/go/ssa/ssa.go?s=49432:49464#L1442">Name</a>
					<a class="permalink" href="index.html#Select.Name">&#xb6;</a>
					
					
				</h3>
				<pre>func (v *<a href="index.html#Select">Select</a>) Name() <a href="http://localhost:6060/pkg/builtin/#string">string</a></pre>
				
				
				
				
			
				
				<h3 id="Select.Operands">func (*Select) <a href="http://localhost:6060/src/golang.org/x/tools/go/ssa/ssa.go?s=55666:55716#L1652">Operands</a>
					<a class="permalink" href="index.html#Select.Operands">&#xb6;</a>
					
					
				</h3>
				<pre>func (v *<a href="index.html#Select">Select</a>) Operands(rands []*<a href="index.html#Value">Value</a>) []*<a href="index.html#Value">Value</a></pre>
				
				
				
				
			
				
				<h3 id="Select.Pos">func (*Select) <a href="http://localhost:6060/src/golang.org/x/tools/go/ssa/ssa.go?s=49647:49681#L1445">Pos</a>
					<a class="permalink" href="index.html#Select.Pos">&#xb6;</a>
					
					
				</h3>
				<pre>func (v *<a href="index.html#Select">Select</a>) Pos() <a href="http://localhost:6060/pkg/go/token/">token</a>.<a href="http://localhost:6060/pkg/go/token/#Pos">Pos</a></pre>
				
				
				
				
			
				
				<h3 id="Select.Referrers">func (*Select) <a href="http://localhost:6060/src/golang.org/x/tools/go/ssa/ssa.go?s=49577:49622#L1444">Referrers</a>
					<a class="permalink" href="index.html#Select.Referrers">&#xb6;</a>
					
					
				</h3>
				<pre>func (v *<a href="index.html#Select">Select</a>) Referrers() *[]<a href="index.html#Instruction">Instruction</a></pre>
				
				
				
				
			
				
				<h3 id="Select.String">func (*Select) <a href="http://localhost:6060/src/golang.org/x/tools/go/ssa/print.go?s=7750:7782#L317">String</a>
					<a class="permalink" href="index.html#Select.String">&#xb6;</a>
					
					
				</h3>
				<pre>func (s *<a href="index.html#Select">Select</a>) String() <a href="http://localhost:6060/pkg/builtin/#string">string</a></pre>
				
				
				
				
			
				
				<h3 id="Select.Type">func (*Select) <a href="http://localhost:6060/src/golang.org/x/tools/go/ssa/ssa.go?s=49307:49343#L1440">Type</a>
					<a class="permalink" href="index.html#Select.Type">&#xb6;</a>
					
					
				</h3>
				<pre>func (v *<a href="index.html#Select">Select</a>) Type() <a href="http://localhost:6060/pkg/go/types/">types</a>.<a href="http://localhost:6060/pkg/go/types/#Type">Type</a></pre>
				
				
				
				
			
		
			
			
			<h2 id="SelectState">type <a href="http://localhost:6060/src/golang.org/x/tools/go/ssa/ssa.go?s=29912:30253#L862">SelectState</a>
				<a class="permalink" href="index.html#SelectState">&#xb6;</a>
				
				
			</h2>
			<p>
SelectState is a helper for Select.
It represents one goal state and its corresponding communication.
</p>

			<pre>type SelectState struct {
<span id="SelectState.Dir"></span>    Dir       <a href="http://localhost:6060/pkg/go/types/">types</a>.<a href="http://localhost:6060/pkg/go/types/#ChanDir">ChanDir</a> <span class="comment">// direction of case (SendOnly or RecvOnly)</span>
<span id="SelectState.Chan"></span>    Chan      <a href="index.html#Value">Value</a>         <span class="comment">// channel to use (for send or receive)</span>
<span id="SelectState.Send"></span>    Send      <a href="index.html#Value">Value</a>         <span class="comment">// value to send (for send)</span>
<span id="SelectState.Pos"></span>    Pos       <a href="http://localhost:6060/pkg/go/token/">token</a>.<a href="http://localhost:6060/pkg/go/token/#Pos">Pos</a>     <span class="comment">// position of token.ARROW</span>
<span id="SelectState.DebugNode"></span>    DebugNode <a href="http://localhost:6060/pkg/go/ast/">ast</a>.<a href="http://localhost:6060/pkg/go/ast/#Node">Node</a>      <span class="comment">// ast.SendStmt or ast.UnaryExpr(&lt;-) [debug mode]</span>
}
</pre>

			

			

			
			
			

			

			
		
			
			
			<h2 id="Send">type <a href="http://localhost:6060/src/golang.org/x/tools/go/ssa/ssa.go?s=38402:38471#L1149">Send</a>
				<a class="permalink" href="index.html#Send">&#xb6;</a>
				
				
			</h2>
			<p>
The Send instruction sends X on channel Chan.
</p>
<p>
Pos() returns the ast.SendStmt.Arrow, if explicit in the source.
</p>
<p>
Example printed form:
</p>
<pre>send t0 &lt;- t1
</pre>

			<pre>type Send struct {
<span id="Send.Chan"></span>    Chan, X <a href="index.html#Value">Value</a>
    <span class="comment">// contains filtered or unexported fields</span>
}
</pre>

			

			

			
			
			

			

			
				
				<h3 id="Send.Block">func (*Send) <a href="http://localhost:6060/src/golang.org/x/tools/go/ssa/ssa.go?s=49851:49894#L1449">Block</a>
					<a class="permalink" href="index.html#Send.Block">&#xb6;</a>
					
					
				</h3>
				<pre>func (v *<a href="index.html#Send">Send</a>) Block() *<a href="index.html#BasicBlock">BasicBlock</a></pre>
				
				
				
				
			
				
				<h3 id="Send.Operands">func (*Send) <a href="http://localhost:6060/src/golang.org/x/tools/go/ssa/ssa.go?s=55828:55876#L1659">Operands</a>
					<a class="permalink" href="index.html#Send.Operands">&#xb6;</a>
					
					
				</h3>
				<pre>func (s *<a href="index.html#Send">Send</a>) Operands(rands []*<a href="index.html#Value">Value</a>) []*<a href="index.html#Value">Value</a></pre>
				
				
				
				
			
				
				<h3 id="Send.Parent">func (*Send) <a href="http://localhost:6060/src/golang.org/x/tools/go/ssa/ssa.go?s=49773:49815#L1448">Parent</a>
					<a class="permalink" href="index.html#Send.Parent">&#xb6;</a>
					
					
				</h3>
				<pre>func (v *<a href="index.html#Send">Send</a>) Parent() *<a href="index.html#Function">Function</a></pre>
				
				
				
				
			
				
				<h3 id="Send.Pos">func (*Send) <a href="http://localhost:6060/src/golang.org/x/tools/go/ssa/ssa.go?s=52434:52464#L1509">Pos</a>
					<a class="permalink" href="index.html#Send.Pos">&#xb6;</a>
					
					
				</h3>
				<pre>func (s *<a href="index.html#Send">Send</a>) Pos() <a href="http://localhost:6060/pkg/go/token/">token</a>.<a href="http://localhost:6060/pkg/go/token/#Pos">Pos</a></pre>
				
				
				
				
			
				
				<h3 id="Send.Referrers">func (*Send) <a href="http://localhost:6060/src/golang.org/x/tools/go/ssa/ssa.go?s=49994:50044#L1451">Referrers</a>
					<a class="permalink" href="index.html#Send.Referrers">&#xb6;</a>
					
					
				</h3>
				<pre>func (v *<a href="index.html#Send">Send</a>) Referrers() *[]<a href="index.html#Instruction">Instruction</a></pre>
				
				
				
				
			
				
				<h3 id="Send.String">func (*Send) <a href="http://localhost:6060/src/golang.org/x/tools/go/ssa/print.go?s=7563:7593#L309">String</a>
					<a class="permalink" href="index.html#Send.String">&#xb6;</a>
					
					
				</h3>
				<pre>func (s *<a href="index.html#Send">Send</a>) String() <a href="http://localhost:6060/pkg/builtin/#string">string</a></pre>
				
				
				
				
			
		
			
			
			<h2 id="Slice">type <a href="http://localhost:6060/src/golang.org/x/tools/go/ssa/ssa.go?s=26936:27058#L755">Slice</a>
				<a class="permalink" href="index.html#Slice">&#xb6;</a>
				
				
			</h2>
			<p>
The Slice instruction yields a slice of an existing string, slice
or *array X between optional integer bounds Low and High.
</p>
<p>
Dynamically, this instruction panics if X evaluates to a nil *array
pointer.
</p>
<p>
Type() returns string if the type of X was string, otherwise a
*types.Slice with the same element type as X.
</p>
<p>
Pos() returns the ast.SliceExpr.Lbrack if created by a x[:] slice
operation, the ast.CompositeLit.Lbrace if created by a literal, or
NoPos if not explicit in the source (e.g. a variadic argument slice).
</p>
<p>
Example printed form:
</p>
<pre>t1 = slice t0[1:]
</pre>

			<pre>type Slice struct {
<span id="Slice.X"></span>    X              <a href="index.html#Value">Value</a> <span class="comment">// slice, string, or *array</span>
<span id="Slice.Low"></span>    Low, High, Max <a href="index.html#Value">Value</a> <span class="comment">// each may be nil</span>
    <span class="comment">// contains filtered or unexported fields</span>
}
</pre>

			

			

			
			
			

			

			
				
				<h3 id="Slice.Name">func (*Slice) <a href="http://localhost:6060/src/golang.org/x/tools/go/ssa/ssa.go?s=49432:49464#L1442">Name</a>
					<a class="permalink" href="index.html#Slice.Name">&#xb6;</a>
					
					
				</h3>
				<pre>func (v *<a href="index.html#Slice">Slice</a>) Name() <a href="http://localhost:6060/pkg/builtin/#string">string</a></pre>
				
				
				
				
			
				
				<h3 id="Slice.Operands">func (*Slice) <a href="http://localhost:6060/src/golang.org/x/tools/go/ssa/ssa.go?s=55919:55968#L1663">Operands</a>
					<a class="permalink" href="index.html#Slice.Operands">&#xb6;</a>
					
					
				</h3>
				<pre>func (v *<a href="index.html#Slice">Slice</a>) Operands(rands []*<a href="index.html#Value">Value</a>) []*<a href="index.html#Value">Value</a></pre>
				
				
				
				
			
				
				<h3 id="Slice.Pos">func (*Slice) <a href="http://localhost:6060/src/golang.org/x/tools/go/ssa/ssa.go?s=49647:49681#L1445">Pos</a>
					<a class="permalink" href="index.html#Slice.Pos">&#xb6;</a>
					
					
				</h3>
				<pre>func (v *<a href="index.html#Slice">Slice</a>) Pos() <a href="http://localhost:6060/pkg/go/token/">token</a>.<a href="http://localhost:6060/pkg/go/token/#Pos">Pos</a></pre>
				
				
				
				
			
				
				<h3 id="Slice.Referrers">func (*Slice) <a href="http://localhost:6060/src/golang.org/x/tools/go/ssa/ssa.go?s=49577:49622#L1444">Referrers</a>
					<a class="permalink" href="index.html#Slice.Referrers">&#xb6;</a>
					
					
				</h3>
				<pre>func (v *<a href="index.html#Slice">Slice</a>) Referrers() *[]<a href="index.html#Instruction">Instruction</a></pre>
				
				
				
				
			
				
				<h3 id="Slice.String">func (*Slice) <a href="http://localhost:6060/src/golang.org/x/tools/go/ssa/print.go?s=4534:4565#L181">String</a>
					<a class="permalink" href="index.html#Slice.String">&#xb6;</a>
					
					
				</h3>
				<pre>func (v *<a href="index.html#Slice">Slice</a>) String() <a href="http://localhost:6060/pkg/builtin/#string">string</a></pre>
				
				
				
				
			
				
				<h3 id="Slice.Type">func (*Slice) <a href="http://localhost:6060/src/golang.org/x/tools/go/ssa/ssa.go?s=49307:49343#L1440">Type</a>
					<a class="permalink" href="index.html#Slice.Type">&#xb6;</a>
					
					
				</h3>
				<pre>func (v *<a href="index.html#Slice">Slice</a>) Type() <a href="http://localhost:6060/pkg/go/types/">types</a>.<a href="http://localhost:6060/pkg/go/types/#Type">Type</a></pre>
				
				
				
				
			
		
			
			
			<h2 id="Store">type <a href="http://localhost:6060/src/golang.org/x/tools/go/ssa/ssa.go?s=38858:38934#L1166">Store</a>
				<a class="permalink" href="index.html#Store">&#xb6;</a>
				
				
			</h2>
			<p>
The Store instruction stores Val at address Addr.
Stores can be of arbitrary types.
</p>
<p>
Pos() returns the position of the source-level construct most closely
associated with the memory store operation.
Since implicit memory stores are numerous and varied and depend upon
implementation choices, the details are not specified.
</p>
<p>
Example printed form:
</p>
<pre>*x = y
</pre>

			<pre>type Store struct {
<span id="Store.Addr"></span>    Addr <a href="index.html#Value">Value</a>
<span id="Store.Val"></span>    Val  <a href="index.html#Value">Value</a>
    <span class="comment">// contains filtered or unexported fields</span>
}
</pre>

			

			

			
			
			

			

			
				
				<h3 id="Store.Block">func (*Store) <a href="http://localhost:6060/src/golang.org/x/tools/go/ssa/ssa.go?s=49851:49894#L1449">Block</a>
					<a class="permalink" href="index.html#Store.Block">&#xb6;</a>
					
					
				</h3>
				<pre>func (v *<a href="index.html#Store">Store</a>) Block() *<a href="index.html#BasicBlock">BasicBlock</a></pre>
				
				
				
				
			
				
				<h3 id="Store.Operands">func (*Store) <a href="http://localhost:6060/src/golang.org/x/tools/go/ssa/ssa.go?s=56027:56076#L1667">Operands</a>
					<a class="permalink" href="index.html#Store.Operands">&#xb6;</a>
					
					
				</h3>
				<pre>func (s *<a href="index.html#Store">Store</a>) Operands(rands []*<a href="index.html#Value">Value</a>) []*<a href="index.html#Value">Value</a></pre>
				
				
				
				
			
				
				<h3 id="Store.Parent">func (*Store) <a href="http://localhost:6060/src/golang.org/x/tools/go/ssa/ssa.go?s=49773:49815#L1448">Parent</a>
					<a class="permalink" href="index.html#Store.Parent">&#xb6;</a>
					
					
				</h3>
				<pre>func (v *<a href="index.html#Store">Store</a>) Parent() *<a href="index.html#Function">Function</a></pre>
				
				
				
				
			
				
				<h3 id="Store.Pos">func (*Store) <a href="http://localhost:6060/src/golang.org/x/tools/go/ssa/ssa.go?s=52487:52518#L1510">Pos</a>
					<a class="permalink" href="index.html#Store.Pos">&#xb6;</a>
					
					
				</h3>
				<pre>func (s *<a href="index.html#Store">Store</a>) Pos() <a href="http://localhost:6060/pkg/go/token/">token</a>.<a href="http://localhost:6060/pkg/go/token/#Pos">Pos</a></pre>
				
				
				
				
			
				
				<h3 id="Store.Referrers">func (*Store) <a href="http://localhost:6060/src/golang.org/x/tools/go/ssa/ssa.go?s=49994:50044#L1451">Referrers</a>
					<a class="permalink" href="index.html#Store.Referrers">&#xb6;</a>
					
					
				</h3>
				<pre>func (v *<a href="index.html#Store">Store</a>) Referrers() *[]<a href="index.html#Instruction">Instruction</a></pre>
				
				
				
				
			
				
				<h3 id="Store.String">func (*Store) <a href="http://localhost:6060/src/golang.org/x/tools/go/ssa/print.go?s=8198:8229#L339">String</a>
					<a class="permalink" href="index.html#Store.String">&#xb6;</a>
					
					
				</h3>
				<pre>func (s *<a href="index.html#Store">Store</a>) String() <a href="http://localhost:6060/pkg/builtin/#string">string</a></pre>
				
				
				
				
			
		
			
			
			<h2 id="Type">type <a href="http://localhost:6060/src/golang.org/x/tools/go/ssa/ssa.go?s=3493:3554#L68">Type</a>
				<a class="permalink" href="index.html#Type">&#xb6;</a>
				
				
			</h2>
			<p>
A Type is a Member of a Package representing a package-level named type.
</p>

			<pre>type Type struct {
    <span class="comment">// contains filtered or unexported fields</span>
}
</pre>

			

			

			
			
			

			

			
				
				<h3 id="Type.Name">func (*Type) <a href="http://localhost:6060/src/golang.org/x/tools/go/ssa/ssa.go?s=50062:50090#L1453">Name</a>
					<a class="permalink" href="index.html#Type.Name">&#xb6;</a>
					
					
				</h3>
				<pre>func (t *<a href="index.html#Type">Type</a>) Name() <a href="http://localhost:6060/pkg/builtin/#string">string</a></pre>
				
				
				
				
			
				
				<h3 id="Type.Object">func (*Type) <a href="http://localhost:6060/src/golang.org/x/tools/go/ssa/ssa.go?s=50376:50412#L1457">Object</a>
					<a class="permalink" href="index.html#Type.Object">&#xb6;</a>
					
					
				</h3>
				<pre>func (t *<a href="index.html#Type">Type</a>) Object() <a href="http://localhost:6060/pkg/go/types/">types</a>.<a href="http://localhost:6060/pkg/go/types/#Object">Object</a></pre>
				
				
				
				
			
				
				<h3 id="Type.Package">func (*Type) <a href="http://localhost:6060/src/golang.org/x/tools/go/ssa/ssa.go?s=50530:50563#L1459">Package</a>
					<a class="permalink" href="index.html#Type.Package">&#xb6;</a>
					
					
				</h3>
				<pre>func (t *<a href="index.html#Type">Type</a>) Package() *<a href="index.html#Package">Package</a></pre>
				
				
				
				
			
				
				<h3 id="Type.Pos">func (*Type) <a href="http://localhost:6060/src/golang.org/x/tools/go/ssa/ssa.go?s=50142:50172#L1454">Pos</a>
					<a class="permalink" href="index.html#Type.Pos">&#xb6;</a>
					
					
				</h3>
				<pre>func (t *<a href="index.html#Type">Type</a>) Pos() <a href="http://localhost:6060/pkg/go/token/">token</a>.<a href="http://localhost:6060/pkg/go/token/#Pos">Pos</a></pre>
				
				
				
				
			
				
				<h3 id="Type.RelString">func (*Type) <a href="http://localhost:6060/src/golang.org/x/tools/go/ssa/ssa.go?s=50600:50652#L1460">RelString</a>
					<a class="permalink" href="index.html#Type.RelString">&#xb6;</a>
					
					
				</h3>
				<pre>func (t *<a href="index.html#Type">Type</a>) RelString(from *<a href="http://localhost:6060/pkg/go/types/">types</a>.<a href="http://localhost:6060/pkg/go/types/#Package">Package</a>) <a href="http://localhost:6060/pkg/builtin/#string">string</a></pre>
				
				
				
				
			
				
				<h3 id="Type.String">func (*Type) <a href="http://localhost:6060/src/golang.org/x/tools/go/ssa/ssa.go?s=50449:50479#L1458">String</a>
					<a class="permalink" href="index.html#Type.String">&#xb6;</a>
					
					
				</h3>
				<pre>func (t *<a href="index.html#Type">Type</a>) String() <a href="http://localhost:6060/pkg/builtin/#string">string</a></pre>
				
				
				
				
			
				
				<h3 id="Type.Token">func (*Type) <a href="http://localhost:6060/src/golang.org/x/tools/go/ssa/ssa.go?s=50301:50335#L1456">Token</a>
					<a class="permalink" href="index.html#Type.Token">&#xb6;</a>
					
					
				</h3>
				<pre>func (t *<a href="index.html#Type">Type</a>) Token() <a href="http://localhost:6060/pkg/go/token/">token</a>.<a href="http://localhost:6060/pkg/go/token/#Token">Token</a></pre>
				
				
				
				
			
				
				<h3 id="Type.Type">func (*Type) <a href="http://localhost:6060/src/golang.org/x/tools/go/ssa/ssa.go?s=50221:50253#L1455">Type</a>
					<a class="permalink" href="index.html#Type.Type">&#xb6;</a>
					
					
				</h3>
				<pre>func (t *<a href="index.html#Type">Type</a>) Type() <a href="http://localhost:6060/pkg/go/types/">types</a>.<a href="http://localhost:6060/pkg/go/types/#Type">Type</a></pre>
				
				
				
				
			
		
			
			
			<h2 id="TypeAssert">type <a href="http://localhost:6060/src/golang.org/x/tools/go/ssa/ssa.go?s=34485:34585#L987">TypeAssert</a>
				<a class="permalink" href="index.html#TypeAssert">&#xb6;</a>
				
				
			</h2>
			<p>
The TypeAssert instruction tests whether interface value X has type
AssertedType.
</p>
<p>
If !CommaOk, on success it returns v, the result of the conversion
(defined below); on failure it panics.
</p>
<p>
If CommaOk: on success it returns a pair (v, true) where v is the
result of the conversion; on failure it returns (z, false) where z
is AssertedType&#39;s zero value.  The components of the pair must be
accessed using the Extract instruction.
</p>
<p>
If AssertedType is a concrete type, TypeAssert checks whether the
dynamic type in interface X is equal to it, and if so, the result
of the conversion is a copy of the value in the interface.
</p>
<p>
If AssertedType is an interface, TypeAssert checks whether the
dynamic type of the interface is assignable to it, and if so, the
result of the conversion is a copy of the interface value X.
If AssertedType is a superinterface of X.Type(), the operation will
fail iff the operand is nil.  (Contrast with ChangeInterface, which
performs no nil-check.)
</p>
<p>
Type() reflects the actual type of the result, possibly a
2-types.Tuple; AssertedType is the asserted type.
</p>
<p>
Pos() returns the ast.CallExpr.Lparen if the instruction arose from
an explicit T(e) conversion; the ast.TypeAssertExpr.Lparen if the
instruction arose from an explicit e.(T) operation; or the
ast.CaseClause.Case if the instruction arose from a case of a
type-switch statement.
</p>
<p>
Example printed form:
</p>
<pre>t1 = typeassert t0.(int)
t3 = typeassert,ok t2.(T)
</pre>

			<pre>type TypeAssert struct {
<span id="TypeAssert.X"></span>    X            <a href="index.html#Value">Value</a>
<span id="TypeAssert.AssertedType"></span>    AssertedType <a href="http://localhost:6060/pkg/go/types/">types</a>.<a href="http://localhost:6060/pkg/go/types/#Type">Type</a>
<span id="TypeAssert.CommaOk"></span>    CommaOk      <a href="http://localhost:6060/pkg/builtin/#bool">bool</a>
    <span class="comment">// contains filtered or unexported fields</span>
}
</pre>

			

			

			
			
			

			

			
				
				<h3 id="TypeAssert.Name">func (*TypeAssert) <a href="http://localhost:6060/src/golang.org/x/tools/go/ssa/ssa.go?s=49432:49464#L1442">Name</a>
					<a class="permalink" href="index.html#TypeAssert.Name">&#xb6;</a>
					
					
				</h3>
				<pre>func (v *<a href="index.html#TypeAssert">TypeAssert</a>) Name() <a href="http://localhost:6060/pkg/builtin/#string">string</a></pre>
				
				
				
				
			
				
				<h3 id="TypeAssert.Operands">func (*TypeAssert) <a href="http://localhost:6060/src/golang.org/x/tools/go/ssa/ssa.go?s=56121:56175#L1671">Operands</a>
					<a class="permalink" href="index.html#TypeAssert.Operands">&#xb6;</a>
					
					
				</h3>
				<pre>func (v *<a href="index.html#TypeAssert">TypeAssert</a>) Operands(rands []*<a href="index.html#Value">Value</a>) []*<a href="index.html#Value">Value</a></pre>
				
				
				
				
			
				
				<h3 id="TypeAssert.Pos">func (*TypeAssert) <a href="http://localhost:6060/src/golang.org/x/tools/go/ssa/ssa.go?s=49647:49681#L1445">Pos</a>
					<a class="permalink" href="index.html#TypeAssert.Pos">&#xb6;</a>
					
					
				</h3>
				<pre>func (v *<a href="index.html#TypeAssert">TypeAssert</a>) Pos() <a href="http://localhost:6060/pkg/go/token/">token</a>.<a href="http://localhost:6060/pkg/go/token/#Pos">Pos</a></pre>
				
				
				
				
			
				
				<h3 id="TypeAssert.Referrers">func (*TypeAssert) <a href="http://localhost:6060/src/golang.org/x/tools/go/ssa/ssa.go?s=49577:49622#L1444">Referrers</a>
					<a class="permalink" href="index.html#TypeAssert.Referrers">&#xb6;</a>
					
					
				</h3>
				<pre>func (v *<a href="index.html#TypeAssert">TypeAssert</a>) Referrers() *[]<a href="index.html#Instruction">Instruction</a></pre>
				
				
				
				
			
				
				<h3 id="TypeAssert.String">func (*TypeAssert) <a href="http://localhost:6060/src/golang.org/x/tools/go/ssa/print.go?s=6328:6364#L255">String</a>
					<a class="permalink" href="index.html#TypeAssert.String">&#xb6;</a>
					
					
				</h3>
				<pre>func (v *<a href="index.html#TypeAssert">TypeAssert</a>) String() <a href="http://localhost:6060/pkg/builtin/#string">string</a></pre>
				
				
				
				
			
				
				<h3 id="TypeAssert.Type">func (*TypeAssert) <a href="http://localhost:6060/src/golang.org/x/tools/go/ssa/ssa.go?s=49307:49343#L1440">Type</a>
					<a class="permalink" href="index.html#TypeAssert.Type">&#xb6;</a>
					
					
				</h3>
				<pre>func (v *<a href="index.html#TypeAssert">TypeAssert</a>) Type() <a href="http://localhost:6060/pkg/go/types/">types</a>.<a href="http://localhost:6060/pkg/go/types/#Type">Type</a></pre>
				
				
				
				
			
		
			
			
			<h2 id="UnOp">type <a href="http://localhost:6060/src/golang.org/x/tools/go/ssa/ssa.go?s=21368:21492#L567">UnOp</a>
				<a class="permalink" href="index.html#UnOp">&#xb6;</a>
				
				
			</h2>
			<p>
The UnOp instruction yields the result of Op X.
ARROW is channel receive.
MUL is pointer indirection (load).
XOR is bitwise complement.
SUB is negation.
NOT is logical negation.
</p>
<p>
If CommaOk and Op=ARROW, the result is a 2-tuple of the value above
and a boolean indicating the success of the receive.  The
components of the tuple are accessed using Extract.
</p>
<p>
Pos() returns the ast.UnaryExpr.OpPos, if explicit in the source.
For receive operations (ARROW) implicit in ranging over a channel,
Pos() returns the ast.RangeStmt.For.
For implicit memory loads (STAR), Pos() returns the position of the
most closely associated source-level construct; the details are not
specified.
</p>
<p>
Example printed form:
</p>
<pre>t0 = *x
t2 = &lt;-t1,ok
</pre>

			<pre>type UnOp struct {
<span id="UnOp.Op"></span>    Op      <a href="http://localhost:6060/pkg/go/token/">token</a>.<a href="http://localhost:6060/pkg/go/token/#Token">Token</a> <span class="comment">// One of: NOT SUB ARROW MUL XOR ! - &lt;- * ^</span>
<span id="UnOp.X"></span>    X       <a href="index.html#Value">Value</a>
<span id="UnOp.CommaOk"></span>    CommaOk <a href="http://localhost:6060/pkg/builtin/#bool">bool</a>
    <span class="comment">// contains filtered or unexported fields</span>
}
</pre>

			

			

			
			
			

			

			
				
				<h3 id="UnOp.Name">func (*UnOp) <a href="http://localhost:6060/src/golang.org/x/tools/go/ssa/ssa.go?s=49432:49464#L1442">Name</a>
					<a class="permalink" href="index.html#UnOp.Name">&#xb6;</a>
					
					
				</h3>
				<pre>func (v *<a href="index.html#UnOp">UnOp</a>) Name() <a href="http://localhost:6060/pkg/builtin/#string">string</a></pre>
				
				
				
				
			
				
				<h3 id="UnOp.Operands">func (*UnOp) <a href="http://localhost:6060/src/golang.org/x/tools/go/ssa/ssa.go?s=56209:56257#L1675">Operands</a>
					<a class="permalink" href="index.html#UnOp.Operands">&#xb6;</a>
					
					
				</h3>
				<pre>func (v *<a href="index.html#UnOp">UnOp</a>) Operands(rands []*<a href="index.html#Value">Value</a>) []*<a href="index.html#Value">Value</a></pre>
				
				
				
				
			
				
				<h3 id="UnOp.Pos">func (*UnOp) <a href="http://localhost:6060/src/golang.org/x/tools/go/ssa/ssa.go?s=49647:49681#L1445">Pos</a>
					<a class="permalink" href="index.html#UnOp.Pos">&#xb6;</a>
					
					
				</h3>
				<pre>func (v *<a href="index.html#UnOp">UnOp</a>) Pos() <a href="http://localhost:6060/pkg/go/token/">token</a>.<a href="http://localhost:6060/pkg/go/token/#Pos">Pos</a></pre>
				
				
				
				
			
				
				<h3 id="UnOp.Referrers">func (*UnOp) <a href="http://localhost:6060/src/golang.org/x/tools/go/ssa/ssa.go?s=49577:49622#L1444">Referrers</a>
					<a class="permalink" href="index.html#UnOp.Referrers">&#xb6;</a>
					
					
				</h3>
				<pre>func (v *<a href="index.html#UnOp">UnOp</a>) Referrers() *[]<a href="index.html#Instruction">Instruction</a></pre>
				
				
				
				
			
				
				<h3 id="UnOp.String">func (*UnOp) <a href="http://localhost:6060/src/golang.org/x/tools/go/ssa/print.go?s=3381:3411#L139">String</a>
					<a class="permalink" href="index.html#UnOp.String">&#xb6;</a>
					
					
				</h3>
				<pre>func (v *<a href="index.html#UnOp">UnOp</a>) String() <a href="http://localhost:6060/pkg/builtin/#string">string</a></pre>
				
				
				
				
			
				
				<h3 id="UnOp.Type">func (*UnOp) <a href="http://localhost:6060/src/golang.org/x/tools/go/ssa/ssa.go?s=49307:49343#L1440">Type</a>
					<a class="permalink" href="index.html#UnOp.Type">&#xb6;</a>
					
					
				</h3>
				<pre>func (v *<a href="index.html#UnOp">UnOp</a>) Type() <a href="http://localhost:6060/pkg/go/types/">types</a>.<a href="http://localhost:6060/pkg/go/types/#Type">Type</a></pre>
				
				
				
				
			
		
			
			
			<h2 id="Value">type <a href="http://localhost:6060/src/golang.org/x/tools/go/ssa/ssa.go?s=4031:6460#L89">Value</a>
				<a class="permalink" href="index.html#Value">&#xb6;</a>
				
				
			</h2>
			<p>
A Value is an SSA value that can be referenced by an instruction.
</p>

			<pre>type Value interface {
    <span class="comment">// Name returns the name of this value, and determines how</span>
    <span class="comment">// this Value appears when used as an operand of an</span>
    <span class="comment">// Instruction.</span>
    <span class="comment">//</span>
    <span class="comment">// This is the same as the source name for Parameters,</span>
    <span class="comment">// Builtins, Functions, FreeVars, Globals.</span>
    <span class="comment">// For constants, it is a representation of the constant&#39;s value</span>
    <span class="comment">// and type.  For all other Values this is the name of the</span>
    <span class="comment">// virtual register defined by the instruction.</span>
    <span class="comment">//</span>
    <span class="comment">// The name of an SSA Value is not semantically significant,</span>
    <span class="comment">// and may not even be unique within a function.</span>
    Name() <a href="http://localhost:6060/pkg/builtin/#string">string</a>

    <span class="comment">// If this value is an Instruction, String returns its</span>
    <span class="comment">// disassembled form; otherwise it returns unspecified</span>
    <span class="comment">// human-readable information about the Value, such as its</span>
    <span class="comment">// kind, name and type.</span>
    String() <a href="http://localhost:6060/pkg/builtin/#string">string</a>

    <span class="comment">// Type returns the type of this value.  Many instructions</span>
    <span class="comment">// (e.g. IndexAddr) change their behaviour depending on the</span>
    <span class="comment">// types of their operands.</span>
    Type() <a href="http://localhost:6060/pkg/go/types/">types</a>.<a href="http://localhost:6060/pkg/go/types/#Type">Type</a>

    <span class="comment">// Parent returns the function to which this Value belongs.</span>
    <span class="comment">// It returns nil for named Functions, Builtin, Const and Global.</span>
    Parent() *<a href="index.html#Function">Function</a>

    <span class="comment">// Referrers returns the list of instructions that have this</span>
    <span class="comment">// value as one of their operands; it may contain duplicates</span>
    <span class="comment">// if an instruction has a repeated operand.</span>
    <span class="comment">//</span>
    <span class="comment">// Referrers actually returns a pointer through which the</span>
    <span class="comment">// caller may perform mutations to the object&#39;s state.</span>
    <span class="comment">//</span>
    <span class="comment">// Referrers is currently only defined if Parent()!=nil,</span>
    <span class="comment">// i.e. for the function-local values FreeVar, Parameter,</span>
    <span class="comment">// Functions (iff anonymous) and all value-defining instructions.</span>
    <span class="comment">// It returns nil for named Functions, Builtin, Const and Global.</span>
    <span class="comment">//</span>
    <span class="comment">// Instruction.Operands contains the inverse of this relation.</span>
    Referrers() *[]<a href="index.html#Instruction">Instruction</a>

    <span class="comment">// Pos returns the location of the AST token most closely</span>
    <span class="comment">// associated with the operation that gave rise to this value,</span>
    <span class="comment">// or token.NoPos if it was not explicit in the source.</span>
    <span class="comment">//</span>
    <span class="comment">// For each ast.Node type, a particular token is designated as</span>
    <span class="comment">// the closest location for the expression, e.g. the Lparen</span>
    <span class="comment">// for an *ast.CallExpr.  This permits a compact but</span>
    <span class="comment">// approximate mapping from Values to source positions for use</span>
    <span class="comment">// in diagnostic messages, for example.</span>
    <span class="comment">//</span>
    <span class="comment">// (Do not use this position to determine which Value</span>
    <span class="comment">// corresponds to an ast.Expr; use Function.ValueForExpr</span>
    <span class="comment">// instead.  NB: it requires that the function was built with</span>
    <span class="comment">// debug information.)</span>
    Pos() <a href="http://localhost:6060/pkg/go/token/">token</a>.<a href="http://localhost:6060/pkg/go/token/#Pos">Pos</a>
}</pre>

			

			

			
			
			

			

			
		
	

	





	
	
		<h2 id="pkg-subdirectories">Subdirectories</h2>
	
	<div class="pkg-dir">
		<table>
			<tr>
				<th class="pkg-name">Name</th>
				<th class="pkg-synopsis">Synopsis</th>
			</tr>

			
			<tr>
				<td colspan="2"><a href="../index.html">..</a></td>
			</tr>
			

			
				<tr>
				
					<td class="pkg-name" style="padding-left: 0px;">
						<a href="interp/index.html">interp</a>
					</td>
				
					<td class="pkg-synopsis">
						Package ssa/interp defines an interpreter for the SSA representation of Go programs.
					</td>
				</tr>
			
				<tr>
				
					<td class="pkg-name" style="padding-left: 0px;">
						<a href="ssautil/index.html">ssautil</a>
					</td>
				
					<td class="pkg-synopsis">
						
					</td>
				</tr>
			
		</table>
	</div>



<div id="footer">
Build version go1.11.5.<br>
Except as <a href="https://developers.google.com/site-policies#restrictions">noted</a>,
the content of this page is licensed under the
Creative Commons Attribution 3.0 License,
and code is licensed under a <a href="http://localhost:6060/LICENSE">BSD license</a>.<br>
<a href="http://localhost:6060/doc/tos.html">Terms of Service</a> |
<a href="http://www.google.com/intl/en/policies/privacy/">Privacy Policy</a>
</div>

</div><!-- .container -->
</div><!-- #page -->

</body>
</html>

